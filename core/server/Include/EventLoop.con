import standard.lib.thread
import standard.net.socket

define MAX_CPU_SLEEP	1000

class __EventEvent {
	var deleg;
	var when;
	var rerun;
	var socket;
	var data;

	__EventEvent(deleg, when, rerun = 0) {
		this.deleg = deleg;
		this.when = when;
		if (rerun < 0)
			rerun = 0;
		this.rerun = rerun;
	}

	run(loop) {
		if (!this.deleg)
			return true;
		if (!this.when)
			return this.deleg(loop);
		var now = Date.now();
		if (this.when <= now) {
			if (this.deleg(loop))
				return true;
			if (this.rerun > 0) {
				this.when = now + this.rerun;
				return false;
			}
			return true;
		}
		return false;
	}

	runRead(loop) {
		if (!this.deleg)
			return true;
		if (rerun > 0)
			this.when = Date.now() + rerun;
		return this.deleg(this.data, loop);
	}

}

class EventLoop {
	protected var[] events;
	protected var[] sockets;
	protected var[] socketevents;
	protected var running;
	protected var cpu_sleep;
	protected var iotimeout_objects;

	public var minSleep = 0;
	// dummy variable
	private var Socket;

	schedule(delegate e, interval = 0) {
		if (!interval)
			interval = 1;
		cpu_sleep = 0;
		events[length events] = new __EventEvent(e, Date.now() + interval, interval);
	}

	timeout(delegate e, when) {
		if (!when)
			when = 1;
		cpu_sleep = 0;
		var timeout = 0;
		if (when) {
			timeout = Date.now() + when;
			iotimeout_objects ++;
		}
		events[length events] = new __EventEvent(e, timeout, when);
	}

	add(delegate e) {
		cpu_sleep = 0;
		events[length events] = new __EventEvent(e, 0, 0);
	}

	addRead(iodescriptor, delegate e, timeout = 0) {
		var socket;
		if (typeof iodescriptor == "class")
			socket = iodescriptor.Socket;
		else
			socket = iodescriptor;
		var key = "" + socket;
		sockets[length sockets] = socket;
		var when = 0;
		if (timeout > 0)
			when = Date.now() + timeout;
		var ev = new __EventEvent(e, when, timeout);
		ev.socket = socket;
		ev.data = iodescriptor;
		socketevents[key] = ev;
		if (timeout > 0)
			iotimeout_objects ++;
	}

	iterate() {
		if (!(length this.events)) {
			cpu_sleep = MAX_CPU_SLEEP;
			if (!socketevents)
				running = false;
			return;
		}

		var events2 = new [];
		var max_date = 0;
		var no_sleep = 0;
		for (var i = 0; i < length this.events; i ++) {
			var e = this.events[i];
			try {
				if ((e) && (!e.run(this))) {
					events2[length events2] = e;
					if ((!max_date) || (e.when < max_date)) {
						max_date = e.when;
						if (!e.when)
							no_sleep = true;
					}
				}
			} catch (var exc) {
				console.error(LOG_THIS, exc);
			}
		}
		if (no_sleep) {
			cpu_sleep = this.minSleep;
		} else {
			if (max_date) {
				cpu_sleep = (max_date - Date.now()) / 2;
				if (cpu_sleep > MAX_CPU_SLEEP)
					cpu_sleep = MAX_CPU_SLEEP;
			} else
				cpu_sleep = MAX_CPU_SLEEP;
		}
		this.events = events2;
	}

	protected __remove_sockets() {
		var sockets2 = new [];
		var socketevents2 = new [];
		var iotimeout_objects2 = 0;
		for (var i = 0; i < length socketevents; i++) {
			var e = socketevents[i];
			if ((e) && (e.socket > 0) && ((!e.when) || (e.when >= Date.now()))) {
				sockets2[length sockets2] = e.socket;
				socketevents2["" + e.socket] = e;
				if (e.rerun)
					iotimeout_objects2 ++;
			}
		}
		this.sockets = sockets2;
		this.socketevents = socketevents2;
		this.iotimeout_objects = iotimeout_objects2;
	}

	protected __timedout() {
		var iotimeout_objects2 = this.iotimeout_objects;
		if (iotimeout_objects2 > 0) {
			var expired = false;
			for (var i = 0; i < length socketevents; i++) {
				var e = socketevents[i];
				if ((e) && (e.when <= Date.now())) {
					expired = true;
					break;
				}
			}
			if (expired)
				this.__remove_sockets();
		}
	}

	protected __poll(timeout) {
		if (timeout < 0)
			timeout = 0;
		if ((SocketPoll(sockets, var outsockets, timeout)) && (outsockets)) {
			var remove_sockets = 0;
			for (var i = 0; i < length outsockets; i ++) {
				var socket = outsockets[i];
				if (socket) {
					var key = "" + socket;
					var e = socketevents[key];
					try {
						if ((!e) || (e.runRead(this))) {
							socketevents[key] = null;
							remove_sockets ++;
						}
					} catch (var exc) {
						socketevents[key] = null;
						remove_sockets ++;
						console.error(LOG_THIS, exc);
					}
				}
			}
			if (remove_sockets)
				this.__remove_sockets();
		} else
		if (this.iotimeout_objects)
			this.__timedout();
	}

	run() {
		running = true;
		while (running) {
			if (this.sockets) {
				this.__poll(cpu_sleep);
			} else {
				if (cpu_sleep > 0)
					Sleep(cpu_sleep);
			}
			iterate();
		}
	}

	quit() {
		running = false;
	}
}
