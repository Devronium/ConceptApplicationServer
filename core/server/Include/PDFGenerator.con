import standard.lib.str
import standard.lang.serialize
import standard.C.math

include PDFFontMetric.con
include PDFFontEncoding.con
include PDFFontMetricEncoding.con

define PDF_A4_W			595
define PDF_A4_H			842
define PDF_A4			595, 842
define PDF_STANDARD_FONTS	["Times-Roman", "Times-Italic", "Times-Bold", "Times-BoldItalic", "Helvetica", "Helvetica-Oblique", "Helvetica-Bold", "Helvetica-BoldOblique", "Courier", "Courier-Oblique", "Courier-Bold", "Courier-BoldOblique", "Symbol", "ZapfDingbats"]
define PDF_STANDARD_ENCODINGS	["cp1251", "iso-8859-4", "cp1255", "iso-8859-11", "cp1257", "cp1258", "cp1253", "cp874", "iso-8859-2", "cp1250", "iso-8859-7", "iso-8859-9", "cp1252", "cp1254", "iso-8859-1", "iso-8859-15", "iso-8859-5", "koi8-r", "iso-8859-16", "koi8-u", "symbol"]
define PDF_DEFAULT_FONT		"helvetica"

class PDFText {
	var font;
	var x;
	var y;
	var text;
	var size;
	var color;

	PDFText(x, y, text, fontsize, fontname, color, escape) {
		this.x = x;
		this.y = y;
		this.size =fontsize;
		this.font = fontname;
		if (escape)
			this.text = StrReplace(StrReplace(StrReplace(text, "\\", "\\\\"), ")", "\\)"), "(", "\\(");
		else
			this.text = text;
		this.color = color;
	}
}

class PDFPath {
	var path;

	PDFPath(path) {
		this.path = path;
	}
}

class PDFPage {
	var Width;
	var Height;
	var Owner;

	var[] Elements;
	var[] Fonts;
	var[] UsedImages;
	var[] ImageIndex;

	var Color = "";
	var FillColor = "";
	var LineWidth = 1;

	protected var CurrentFillColor = "";
	protected var CurrentColor = "";
	protected var CurrentLineWidth = -1;

	public var Font = "Helvetica";
	public var FontSize = 12;

	public var MarginTop = 20;
	public var MarginBottom = 20;
	public var MarginLeft = 20;
	public var MarginRight = 20;

	protected var TextX;
	protected var TextY;
	protected var __lastwidth;

	PDFPage(Owner, Width, Height) {
		this.Width = Width;
		this.Height = Height;
		this.Owner = Owner;

		this.TextX = MarginLeft;
		this.TextY = Height - MarginTop - MarginBottom;
	}

	protected __NewPage() {
		var page = this.Owner.NewPage(Width, Height);
		page.Font = Font;
		page.FontSize = FontSize;
		page.MarginTop = MarginTop;
		page.MarginBottom = MarginBottom;
		page.MarginLeft = MarginLeft;
		page.MarginBottom = MarginBottom;
		page.Color = Color;
		page.FillColor = FillColor;
		page.LineWidth = LineWidth;
		return page;
	}

	protected __AppendLines(lines) {
		var last_line = length lines - 1;
		for (var i = 0; i < length lines; i++) {
			var line = lines[i];
			this.Print(TextX, TextY, line, FontSize, Font);
			TextX = MarginLeft;
			if (i < last_line) {
				TextY -= FontSize;
				if (TextY < MarginBottom) {
					var lines2 = new [];
					for (var j = i + 1; j < length lines; j++)
						lines2[length lines2] = lines[j];
					if (lines2) {
						var page = this.__NewPage();
						return page.__AppendLines(lines2);
					}
				}
			}
			
		}
		if (lines)
			TextX = MarginLeft + __lastwidth;
		return this;
	}

	Append(text) {
		return __AppendLines(this.Owner.Wrap(text, Font, FontSize, Width - MarginLeft - MarginRight, __lastwidth));
	}

	operator << (text) {
		return this.Append(text);
	}

	Print(number x, number y, text, fontsize = 12, fontname = "", escape = true) {
		fontname = trim(fontname);
		Elements[length Elements] = new PDFText(x, y, text, fontsize, fontname, Color, escape);
		if (fontname)
			Fonts[ToLower(fontname)] = this.Owner.__UseFont(fontname);
	}

	UpdateParams() {
		var str = "";
		if (CurrentColor != Color) {
			CurrentColor = Color;
			str += "" + CurrentColor + " RG";
		}
		if (CurrentFillColor != FillColor) {
			CurrentFillColor = FillColor;
			if (str)	
				str += " ";
			str += "" + CurrentFillColor + " rg";
		}
		if (CurrentLineWidth != LineWidth) {
			CurrentLineWidth = LineWidth;
			if (str)	
				str += " ";
			str += "" + LineWidth + " w";
		}
		if (str)
			Elements[length Elements] = new PDFPath(str);
	}

	Rectangle(number x, number y, number width, number height, fill = false) {
		UpdateParams();
		var fill_str = "S";
		if (fill_str)
			fill_str = "B";
		Elements[length Elements] = new PDFPath("$x $y m $x $y $width $height re h $fill_str");
	}

	Line(number x1, number y1, number x2, number y2, dashed_param = "") {
		UpdateParams();
		Elements[length Elements] = new PDFPath("$x1 $y1 m $dashed_param $x2 $y2 l h S");
	}

	Image(string name, number x, number y, scale_w = 0, scale_h = 0) {
		var image = this.Owner.Images[name];
		if (image) {
			if (!UsedImages[name]) {
				ImageIndex[name] = length UsedImages - 1;
				UsedImages[name] = image;
			}
			var size = "";
			if ((scale_w) && (scale_h))
				size = "$scale_w 0 0 $scale_h 0 0 cm\r\n";
			Elements[length Elements] = new PDFPath("q\r\n1 0 0 1 $x $y cm\r\n$size/Im${ImageIndex[name]} Do\r\nQ");
			return true;
		}
		return false;
	}

	__resources() {
		var resources = "";
		if (Fonts) {
			resources += "/Font<<";
			for (var i = 0; i < length Fonts; i++) {
				var name = Fonts[i];
				var offset = this.Owner.__getfont(name) + 1;
				resources += "/$name $offset 0 R";
			}
			resources += ">>";
		}
		if (UsedImages) {
			resources += "/ProcSet[/PDF/ImageB]/XObject <<";
			for (i = 0; i < length UsedImages; i++) {
				var img = UsedImages[i];
				if (img)
					resources += "/Im$i ${img.obj_id} 0 R";
			}
			resources += ">>";
		}
		return resources;
	}

	__render(offsets, var pdf) {
		var stream = "";
		if (Elements) {
			var current_color = "";
			var current_font = "";
			var current_size = 0;
			for (var i = 0; i < length Elements; i++) {
				var element = Elements[i];	
				if (stream)
					stream += "\r\n";
				var font_data = "";
				switch (classof element) {
					case "PDFText":
						if (current_color != element.color) {
							current_color = element.color;
							stream += "${current_color} rg\r\n";
						}
						if (element.text) {
							if ((current_font != element.font) || (current_size != element.size)) {
								if (element.font)
									current_font = element.font;
								if (element.size)
									current_size = element.size;
								if ((current_font) && (current_size)) {
									var fontname = Fonts[ToLower(current_font)];
									font_data = "/$fontname ${current_size} Tf";
								}
							}
							stream += "BT$font_data ${element.x} ${element.y} Td(${element.text})Tj ET";
						}
						break;
					case "PDFPath":
						stream += element.path;
						break;
				}
			}
		}
		return stream;
	}
}

class PDFEmbeddedFile {
	var content;
	var name;
	var type;

	PDFEmbeddedFile(var content, name, type) {
		this.content = content;
		this.name = name;
		this.type = type;
	}
}

class PDFImage {
	var content;
	var width;
	var height;
	var obj_id;

	PDFImage(var content, width, height) {
		this.content = content;
		this.width = width;
		this.height = height;
	}
}

class PDFGenerator {
	var DefaultPageWidth;
	var DefaultPageHeight;
	var UseCompression = true;
	var Lang = "(EN-US)";
	var Title = "";
	var Creator = "";
	var Producer = "";
	var Author = "";
	var Subject = "";
	var Keywords = "";
	protected var Unicode = false;
	var Encoding = "";

	protected var[] Pages;
	protected var[] Fonts;
	protected var[] FontsMetric;
	protected var[] FontNames;
	protected var[] FontOffsets;
	protected var[] Blobs;
	protected var[] EmbeddedFonts;
	var[] Images;
	var Metrics;
	var EncodingMetrics;

	PDFGenerator(DefaultPageWidth = PDF_A4_W, DefaultPageHeight = PDF_A4_H) {
		this.DefaultPageWidth = DefaultPageWidth;
		this.DefaultPageHeight = DefaultPageHeight;
		this.Metrics = PDF_FONT_METRIC;
		this.EncodingMetrics = PDF_FONT_ENCODING_METRIC;
	}

	protected LoadEncodingMetrics(fontname_lo) {
		var metrics = this.EncodingMetrics;
		var res = metrics[fontname_lo];
		if (res) {
			var encoding = ToLower(this.Encoding);
			if (!encoding)
				encoding = "iso-8859-1";
			if (res) {
				res = res[encoding];
				if (res)
					FontsMetric[fontname_lo] = res;
			}
		}
		return res;
	}

	protected WVector(fontname) {
		if (this.Encoding)
			var arr = this.FontsMetric[fontname] ?? LoadEncodingMetrics(fontname);

		if (!arr) {
			if (!IsSet(this.Metrics, fontname))
				fontname = PDF_DEFAULT_FONT;
			arr = this.Metrics[fontname];
		}
		return arr;
	}

	Measure(string text, string fontname, number size) {
		if (text) {
			fontname = ToLower(fontname);
			var arr = this.WVector(fontname);

			var w_size = 0;
			for (var i = 0; i < length text; i++)
				w_size += (arr[ord(text[i])] ?? 0.6) * size;

			return w_size;
		}
		return 0;
	}

	Wrap(string text, string fontname, number size, width, var last_width = 0) {
		var[] res;
		if (text) {
			fontname = ToLower(fontname);
			if (!IsSet(this.Metrics, fontname))
				fontname = PDF_DEFAULT_FONT;

			var arr = this.Metrics[fontname];
			var w_size = last_width;
			var last_line = "";
			var line = "";
			var last_separator = 0;

			for (var i = 0; i < length text; i++) {
				var l = text[i];
				if (l == "\t") {
					text[i] = "    ";
					l = " ";
				}
				if (l == "\r")
					continue;
				if (l == "\n") {
					res[length res] = line;
					last_line = "";
					line = "";
					w_size = 0;
					continue;
				} else {
					w_size += arr[ord(l)] * size;
					if ((ceil(w_size) >= width) && (last_line)) {
						i = last_separator;
						line = "";
						res[length res] = last_line;
						last_line = "";
						w_size = 0;
						continue;
					}
					line += l;
				}

				switch (l) {
					case " ":
					case ".":
					case ",":
					case "-":
					case "#":
					case "!":
					case "?":
					case ";":
					case ":":
					case ")":
					case "(":
					case "[":
					case "]":
					case "/":
					case "\\":
					case "{":
					case "}":
					case "+":
					case "=":
					case "\t":
					case "\n":
					case "\r":
						last_separator = i;
						last_line = line;
						break;
				}
			}
			if ((line) || (l == "\n"))
				res[length res] = line;
			last_width = w_size;
			return res;
		}
		return res;
	}

	NewPage(Width = 0, Height = 0) {
		if (Width <= 0)
			Width = DefaultPageWidth;
		if (Height <= 0)
			Height = DefaultPageHeight;
		var page = new PDFPage(this, Width, Height);
		Pages[length Pages] = page;
		return page;
	}

	EmbedFont(fontname, ttfdata) {
		EmbeddedFonts[fontname] = ttfdata;
	}

	protected __offset(offset) {
		var res = "" + offset;
		while (length res < 10)
			res = "0" + res;
		return res;
	}

	protected __object(offsets, var pdf, object_data) {
		var offset = __offset(length pdf);
		var obj_id = length offsets + 1;
		offsets[length offsets] = offset;
		pdf += "$obj_id 0 obj\r\n" + object_data + "\r\nendobj\r\n";
		return offset;
	}

	protected __xref(offsets, var pdf, root, info_id) {
		var offset = length pdf;
		var obj_count = length offsets + 1;
		pdf += "xref\r\n";

		pdf += "0 $obj_count\r\n";
		pdf += "0000000000 65535 f\r\n";
		for (var i = 0; i < length offsets; i++)
			pdf += offsets[i] + " 00000 n\r\n";
		if (info_id)
			pdf += "trailer <</Size $obj_count/Root $root 0 R/Info $info_id 0 R>>\r\n";
		else
			pdf += "trailer <</Size $obj_count/Root $root 0 R>>\r\n";
		return offset;
	}

	public __UseFont(string fontname) {
		var fontname_lo = ToLower(fontname);
		var font = Fonts[fontname_lo];
		if (font)
			return FontNames[fontname_lo];

		Fonts[fontname_lo] = fontname;
		var fname = "F" + (length Fonts);
		FontNames[fontname_lo] = fname;
		return fname;
	}

	protected __stream(offsets, var pdf, object_data) {
		var extra = "";
		if (UseCompression) {
			extra = "/Filter/FlateDecode";
			object_data = compress(object_data);
		}
		return this.__object(offsets, pdf, "<</Length ${length object_data}$extra>>\r\nstream\r\n$object_data\r\nendstream");
	}

	protected __register_fonts(offsets, var pdf) {
		FontOffsets = new [];
		var unicode_str = "";
		var encoding = "";
		var encoding_ref = "";
		var charset = ToLower(this.Encoding);
		switch (charset) {
			case "":
				break;
			case "iso-8859-1":
				encoding_ref = PDF_ISO_8859_1;
				break;
			case "iso-8859-2":
				encoding_ref = PDF_ISO_8859_2;
				break;
			case "cp1251":
				encoding_ref = PDF_CP1251;
				break;
			case "iso-8859-4":
				encoding_ref = PDF_ISO_8859_4;
				break;
			case "cp1255":
				encoding_ref = PDF_CP1255;
				break;
			case "iso-8859-11":
				encoding_ref = PDF_ISO_8859_11;
				break;
			case "cp1257":
				encoding_ref = PDF_CP1257;
				break;
			case "cp1258":
				encoding_ref = PDF_CP1258;
				break;
			case "cp1253":
				encoding_ref = PDF_CP1253;
				break;
			case "cp874":
				encoding_ref = PDF_CP874;
				break;
			case "cp1250":
				encoding_ref = PDF_CP1250;
				break;
			case "iso-8859-7":
				encoding_ref = PDF_ISO_8859_7;
				break;
			case "iso-8859-9":
				encoding_ref = PDF_ISO_8859_9;
				break;
			case "cp1252":
				encoding_ref = PDF_CP1252;
				break;
			case "cp1254":
				encoding_ref = PDF_CP1254;
				break;
			case "iso-8859-15":
				encoding_ref = PDF_ISO_8859_15;
				break;
			case "iso-8859-5":
				encoding_ref = PDF_ISO_8859_5;
				break;
			case "koi8-r":
				encoding_ref = PDF_KOI8_R;
				break;
			case "iso-8859-16":
				encoding_ref = PDF_ISO_8859_16;
				break;
			case "koi8-u":
				encoding_ref = PDF_KOI8_U;
				break;
			case "symbol":
				encoding_ref = PDF_SYMBOL;
				break;
			default:
				throw "Unsupported encoding ${this.Encoding}";
		}
		if (encoding_ref) {
			this.__object(offsets, pdf, "<</Type/Encoding/Differences[$encoding_ref]>>");
			encoding = "/Encoding ${length offsets} 0 R";
		}

		if (EmbeddedFonts) {
			var keys = GetKeys(EmbeddedFonts);
			if (keys) {
				for (var i = 0; i < length EmbeddedFonts; i++) {
					var font_name = keys[i];	
					var font_data = EmbeddedFonts[i];
					if ((font_name) && (font_data)) {
						var font_id = length offsets + 3;
						var font_desc_id = length offsets + 2;
						this.__object(offsets, pdf, "<</Type/Font/SubType/TrueType $font_desc_id 0 R");
						var font_flags = 32;
						this.__object(offsets, pdf, "<</Type/FontDescriptor/FontName/$font_name/Flags $font_flags/FontFile2 $font_id 0 R");
						this.__stream(offsets, pdf, font_data);
					}
				}
			}
		}
		if (Unicode) {
			this.__stream(offsets, pdf, "/CIDInit /ProcSet findresource begin 12 dict begin begincmap /CIDSystemInfo << /Registry (Adobe) /Ordering (UCS) /Supplement 0 >> def /CMapName /Adobe-Identity-UCS def /CMapType 2 def 1 begincodespacerange <0000> <FFFF> endcodespacerange 1 beginbfrange <0000> <FFFF> <0000> endbfrange endcmap CMapName currentdict /CMap defineresource pop end end");
			var unicode_id = length offsets;
			unicode_str = "/ToUnicode $unicode_id 0 R/Encoding/Identity-H";
		}

		for (i = 0; i < length Fonts; i++) {
			var font = Fonts[i];
			if (font) {
				var reg_name = FontNames[i];
				FontOffsets[reg_name] = length offsets;
				if (unicode_str) {
					this.__object(offsets, pdf, "<</Type/Font/Subtype/Type0/BaseFont/$font$unicode_str/DescendantFonts [${length offsets + 2} 0 R]>>");
					this.__object(offsets, pdf, "<</Type/Font/Subtype/CIDFontType2/BaseFont/$font/CIDToGIDMap/Identity/CIDSystemInfo<</Registry (Adobe)/Ordering (USC)/Supplement 0>>>>");
				} else {
					if (encoding) {
						var fontname_lo = ToLower(font);
						if ((fontname_lo != "symbol") && (fontname_lo != "zapfdingbats")) {
							var widths = "";
							if (encoding_ref) {
								var arr = this.WVector(fontname_lo);
								if (arr) {

									var wvector = "";
									var start = -1;
									for (var j = 0; j <= 255; j++) {
										var wsize = arr[j];
										if ((start == -1) && (wsize))
											start = j;
										if (start >= 0) {
											if (wvector)
												wvector += " ";
											wvector += arr[j] * 1000;
										}
									}
									if (wvector)
										widths = "/FirstChar $start/LastChar 255/Widths [$wvector]";
								}
							}
							this.__object(offsets, pdf, "<</Type/Font/Subtype/Type1/BaseFont/$font$unicode_str$encoding$widths>>");
						} else
							this.__object(offsets, pdf, "<</Type/Font/Subtype/Type1/BaseFont/$font$unicode_str>>");
					} else
						this.__object(offsets, pdf, "<</Type/Font/Subtype/Type1/BaseFont/$font$unicode_str>>");
				}
			}
		}
	}

	__getfont(fontid) {
		if (FontOffsets)
			return FontOffsets[fontid];
		return "0";
	}

	Embed(var content, name, subtype = "") {
		if ((content) && (name))
			Blobs[length Blobs] = new PDFEmbeddedFile(content, name, subtype);
	}

	UseImage(key, var content, width, height) {
		if (content)
			Images[ToLower(key)] = new PDFImage(content, width, height);
	}

	protected __embed(offsets, var pdf) {
		var public_files = "";
		for (var i = 0; i < length Blobs; i++) {
			var blob = Blobs[i];
			if (blob) {
				var file_id = length offsets + 2;
				this.__object(offsets, pdf, "<</Type/Filespec/F(${blob.name})/EF<</F $file_id 0 R>>>> ");
				var bdata = "<</Type/EmbeddedFile/Size ${length blob.content}";
				if (blob.type)
					bdata += "/Subtype/" + StrReplace(blob.type, "/", "#2F");
				bdata += "/Length ${length blob.content}>>\r\nstream\r\n";
				bdata += blob.content;
				bdata += "\r\nendstream";
				this.__object(offsets, pdf, bdata);
				if (public_files)
					public_files += " ";
				public_files += "(${blob.name}) ${file_id - 1} 0 R";
			}
		}
		return public_files;
	}

	protected __embed_images(offsets, var pdf) {
		for (var i = 0; i < length Images; i++) {
			var image = Images[i];
			if (image) {
				var size = "";
				if (image.width)
					size += "/Width ${image.width}";
				if (image.height)
					size += "/Height ${image.height}";
				image.obj_id = length offsets + 1;
				this.__object(offsets, pdf, "<</Type/XObject/Subtype/Image/ColorSpace/DeviceRGB/Length ${length image.content}$size/Filter/DCTDecode/BitsPerComponent 8>>\r\nstream\r\n${image.content}\r\nendstream");
			}
		}
	}

	Done() {
		Pages = new [];
	}

	__wide(str) {
		var res = "<feff";
		for (var i = 0; i < length str; i++) {
			var s = NumberToHex(ord(str[i]));
			if (length s == 1)
				s = "0" + s;
			res += "00" + s;
		}
		res += ">";
		return res;
	}

	Generate() {
		if (!Pages)
			throw "PDFGenerator.Generate: no pages defined";
		var[] offsets;
		var pdf = "%PDF-1.6\r\n";
		var title_id = 0;
		var info = "";
		if (Title)
			info += "/Title" + this.__wide(Title);
		if (Creator)
			info += "/Creator" + this.__wide(Creator);
		if (Author)
			info += "/Author" + this.__wide(Author);
		if (Subject)
			info += "/Subject" + this.__wide(Subject);
		if (Producer)
			info += "/Producer" + this.__wide(Producer);
		if (Keywords)
			info += "/Keywords" + this.__wide(Keywords);

		if (info) {
			title_id = length offsets + 1;
			this.__object(offsets, pdf, "<<$info>>");
		}
		__register_fonts(offsets, pdf);

		var public_files = __embed(offsets, pdf);
		__embed_images(offsets, pdf);
		var root = length offsets + 1;
		var pages_id = root + 1;
		var kids = "";
		var page_id = pages_id + 1;
		for (var i = 0; i < length Pages; i++) {
			var page = Pages[i];
			if (page) {
				if (kids)
					kids += " ";
				kids += "$page_id 0 R";
				page_id += 3;
			}
		}
		var attachments = "";
		if (public_files)
			attachments = "/Names<</EmbeddedFiles<</Names[$public_files]>>>>";
		this.__object(offsets, pdf, "<</Type/Catalog/Lang ${Lang}/Pages $pages_id 0 R$attachments>>/ViewerPreferences<</DisplayDocTitle true>>");
		this.__object(offsets, pdf, "<</Type/Pages/Kids[$kids]/Count ${length Pages}>>");

		for (i = 0; i < length Pages; i++) {
			page = Pages[i];
			if (page) {
				var res_data = page.__resources();
				var resources = length offsets + 2;
				var contents = length offsets + 3;
				this.__object(offsets, pdf, "<</Type/Page/Parent $pages_id 0 R/Resources $resources 0 R/MediaBox[0 0 ${page.Width} ${page.Height}]/Contents $contents 0 R>>");
				var stream = page.__render(offsets, pdf);
				this.__object(offsets, pdf, "<<$res_data>>");
				__stream(offsets, pdf, stream);
			}
		}

		var offset = __xref(offsets, pdf, root, title_id);
		pdf += "startxref\r\n";
		pdf += "" + offset + "\r\n";
		pdf += "%%EOF";
		Done();
		return pdf;
	}
}
