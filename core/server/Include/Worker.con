import standard.lib.thread

class Worker {
	var _workerobj;
	var _workerthread;
	var _shared_context;

	Worker(classname, string parameter = "", shared_context = null) {
		_workerobj = CreateWorker(classname, _workerthread, parameter, shared_context);
		if (_workerthread) {
			var iterations=0;
			while (!ThreadIsActive(_workerthread)) {
				iterations++;
				if (iterations>100000000)
					break;
			}
		}
		if (shared_context)
			this._shared_context = shared_context;
	}

	static SharedContext() {
		return WorkerSharedContext();
	}

	static SharedContextRelease(shared_context) {
		if (shared_context)
			WorkerSharedRelease(shared_context);
	}

	Join() {
		if (_workerobj) {
			WaitThread(_workerthread);
			FreeWorker(_workerobj);
			_workerobj = null;
			_workerthread = 0;
		}
	}


	AddData(string data, priority = 0) {
		if (_workerobj) {
			if (priority > 0)
				return AddWorkerData(_workerobj, data, priority);
			return AddWorkerData(_workerobj, data);
		}
		return -1;
	}

	GetResult(var data, timeout_ms = 0) {
		if (_workerobj) {
			if (timeout_ms)
				return GetWorkerResultData(_workerobj, data, timeout_ms);
			return GetWorkerResultData(_workerobj, data);
		}
		return -1;
	}

	static Pending(var data, timeout_ms = 0) {
		if (timeout_ms)
			return GetWorkerData(data, timeout_ms);
		return GetWorkerData(data);
	}

	static Result(data) {
		return AddWorkerResultData(data);
	}

	static Get(masterkey, key) {
		return WorkerSharedGet(masterkey, key);
	}

	static GetSet(masterkey, key, var data) {
		return WorkerSharedGetSet(masterkey, key, data);
	}

	static Set(masterkey, key, var data) {
		return WorkerSharedSet(masterkey, key, data);
	}

	static Remove(masterkey, key = "") {
		return WorkerSharedRemove(masterkey, key);
	}

	GetKey(masterkey, key) {
		if (!_shared_context)
			throw "No shared context set";
		return WorkerSharedGet(masterkey, key, _shared_context);
	}

	GetSetKey(masterkey, key, var data) {
		if (!_shared_context)
			throw "No shared context set";
		return WorkerSharedGetSet(masterkey, key, data, _shared_context);
	}

	SetKey(masterkey, key, var data) {
		if (!_shared_context)
			throw "No shared context set";
		return WorkerSharedSet(masterkey, key, data, _shared_context);
	}

	RemoveKey(masterkey, key = "") {
		if (!_shared_context)
			throw "No shared context set";
		return WorkerSharedRemove(masterkey, key, _shared_context);
	}

	Exit() {
		if ((_workerthread) && (_workerobj)) {
			var res = KillThread(_workerthread);
			FreeWorker(_workerobj);
			_workerobj = null;
			_workerthread = 0;
		}
		return 0;
	}

	IsActive() {
		return ThreadIsActive(_workerthread);
	}

	finalize() {
		this.Join();
	}
}
