import standard.lib.str

class SQLParser {
	static alpha(c) {
		if (((c >= "A") && (c <= "Z")) || ((c >= "a") && (c <= "z")))
			return true;
		return false;
	}

	static numeric(c) {
		if ((c >= "0") && (c <= "9"))
			return true;
		return false;
	}

	static alphanumeric(c) {
		if (((c >= "A") && (c <= "Z")) || ((c >= "a") && (c <= "z")) || ((c >= "0") && (c <= "9")) || (c == "_") || (c == "\$") || (c == "."))
			return true;
		return false;
	}

	static parseQuote(q, var buffer, var err, var offset, var val, expr = false) {
		val = "";
		switch (q) {
			case '"':
			case "'":
				// 2 types of quotes supported
				val += q;
				break;
			default:
				return false;
		}
		while (offset < length buffer) {
			var c = buffer[offset++];
			val += c;
			if (c == "\\") {
				// skip one
				val += buffer[offset];
				offset++;
				continue;
			}
			if (c == q)
				return true;
		}
		if (err)
			err += "\n";
		err += "Forgot to close quotes";
		return false;
	}

	static parseAtom(var buffer, var err, var offset, list = 0) {
		var command = "";
		while (offset < length buffer) {
			var c = buffer[offset++];
			if (SQLParser::alphanumeric(c))
				command += c;
			else
			if (command) {
				offset--;
				break;
			} else
			if (SQLParser::parseQuote(c, buffer, err, offset, command))
				break;
			else {
				switch (c) {
					case "<":
					case ">":
						var next = buffer[offset];
						if (next == "=") {
							c += next;
							offset++;
						}
					case "*":
					case "+":
					case "-":
					case "=":
					case "^":
					case ",":
					case ";":
						return c;
					case " ":
					case "\t":
						break;
					case '(':
						if (list == 1)
							return c;
						list = 0;
					case ')':
						if (list == 2)
							return c;
						list = 0;
					default:
						if (err)
							err += "\n";
						err += "Unexpected character '$c'";
						return "";
				}
			}
		}
		return trim(command);
	}

	static strip(atom) {
		if (length atom >= 2) {
			switch (atom[0]) {
				case "'":
				case '"':	
					return SubStr(atom, 1, length atom - 2);
			}
		}
		return atom;
	}

	static removeone(var arr) {
		var one = "";
		if (arr) {
			var[] new_arr;
			var len = length arr - 1;
			one = ToUpper(arr[len]);
			for (var i = 0; i < len; i++)
				new_arr[i] = arr[i];
			arr = new_arr;
		}
		return one;
	}

	static parseList(var buffer, var err, var offset, list = 0, var func = null) {
		var[] fields;
		var expect_comma = false;
		var ref_list = list;
		if (ref_list == 3)
			ref_list = 1;
		var target_foo;
		do {
			var prec_offset = offset;
			var command = SQLParser::parseAtom(buffer, err, offset, ref_list);
			if (!command) {
				if (err)
					err += "\n";
				err += "Syntax error";
				return false;
			}
			if (list == 3) {
				if ((command == "(") && (ref_list == 1)) {
					var f = SQLParser::removeone(fields);
					if (!f) {
						if (err)
							err += "\n";
						err += "Syntax error in aggregation function";
						return false;
					}
					if (!func)
						func = new [];

					target_foo = [f, [ ]];
					func[length func] = target_foo;
					ref_list = 2;
					expect_comma = false;
					continue;
				}
				if ((command == ")") && (ref_list == 2)) {
					ref_list = 1;
					expect_comma = true;
					target_foo = null;
					continue;
				}
			}
			if (expect_comma) {
				if (command != ",") {
					offset = prec_offset;
					return fields;
				}
				expect_comma = false;
			} else {
				var str = SQLParser::strip(command);
				if (target_foo)
					target_foo[1][length target_foo[1]] = str;
				else
					fields[length fields] = str;
				expect_comma = true;
			}
		} while (command);
		return fields;
	}

	static parseNumber(var buffer, var err, var offset) {
		var command = SQLParser::parseAtom(buffer, err, offset);
		if (!command) {
			if (err)
				err += "\n";
			err += "Number expected";
			return 0;
		}
		var val = value command;
		if ("" + val != command) {
			if (err)
				err += "\n";
			err += "Invalid number value '$command'";
		}
		return val;
	}

	static prepare(val, var err) {
		if (typeof val == "string") {
			switch (val[0]) {
				case "'":
				case '"':
					return SQLParser::strip(val);
				default:
					var new_val = value val;
					if ("" + new_val != val) {
						if (err)
							err += "\n";
						err += "Invalid number value '$val'";
					} else
						return new_val;
			}
		}
		return val;
	}

	static parseWhere(var buffer, var err, var offset) {
		var state = -1;
		var[] criteria;
		var condition;
		var variable = "";
		var op = "";
		do {
			var prev_offset = offset;
			var command = SQLParser::parseAtom(buffer, err, offset);
			if (command) {
				switch (state) {
					case -1:
					case 0:
						variable = SQLParser::strip(command);
						condition = criteria[variable];
						if (!condition) {
							condition = new [];
							criteria[variable] = condition;
						}
						state = 1;
						break;
					case 1:
						op = ToUpper(command);
						state = 2;
						if (op == "IN") {
							command = SQLParser::parseAtom(buffer, err, offset, 1);
							if (command != "(") {
								if (err)
									err += "\n";
								err += "'(' expected after IN operator";
								command = "";
								break;
							}
							var list = SQLParser::parseList(buffer, err, offset, 2);
							command = SQLParser::parseAtom(buffer, err, offset, 2);
							if (command != ")") {
								if (err)
									err += "\n";
								err += "')' expected";
								command = "";
								break;
							}
							command = list;
						} else
							break;
					case 2:
						var val = SQLParser::prepare(command, err);
						if ((op == "=") || (op == "IN")) {
							if (condition) {
								if (err)
									err += "\n";
								err += "Impossible condition (same variable, multiple values; use 'IN' operator)";
							} else
								criteria[variable] = val;
						}
						condition[op] = val;
						state = 3;
						break;
					case 3:
						state = 0;
						if (ToUpper(command) != "AND") {
							offset = prev_offset;
							command = "";
						}
						break;
				}
			}
		} while (command);
		if ((state != 0) && (state != 3)) {
			if (err)
				err += "\n";
			err += "Invalid WHERE syntax";
		}
		return criteria;
	}

	static parseJoin(var buffer, var err, var offset) {
		var command = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		if (!command) {
			if (err)
				err += "\n";
			err += "Expected collection name after 'JOIN'";
			return null;
		}
		var collection = command;
		command = ToUpper(SQLParser::parseAtom(buffer, err, offset));
		if (command != "ON") {
			if (err)
				err += "\n";
			err += "Expected 'ON' after 'JOIN collection'";
			return null;
		}
		var field = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		var eq = SQLParser::parseAtom(buffer, err, offset);
		var field2 = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		if ((!field) || (!field2) || (eq != "=")) {
			if (err)
				err += "\n";
			err += "Expected 'field1 = field2' after 'JOIN collection ON'";
			return null;
		}
		return [collection, [field => field2]];
	}

	static parseSelect(var buffer, var err, var offset, syntax) {
		var fields = SQLParser::parseList(buffer, err, offset, 3, var funct);
		if (!fields) {
			if (funct) {
				fields = ["*"];
			} else {
				if (err)
					err += "\n";
				err += "Missing fields in SELECT";
				return false;
			}
		}
		syntax["SELECT"] = fields;
		if (funct)
			syntax["MOD"] = funct;

		if (err)
			false;

		var command = SQLParser::parseAtom(buffer, err, offset);
		if ((!command) || (ToUpper(command) != "FROM")) {
			if (err)
				err += "\n";
			err += "Syntax error in SELECT: expecting 'FROM', found '$command'";
			return false;
		}
		var from = SQLParser::parseAtom(buffer, err, offset);
		if (!from) {
			if (err)
				err += "\n";
			err += "Syntax error in SELECT: expecting collection name after 'FROM'";
			return false;
		}
		syntax["FROM"] = SQLParser::strip(from);
		var last_join;
		do {
			command = ToUpper(SQLParser::parseAtom(buffer, err, offset));
			if (command) {
				switch (command) {
					case ";":
						return true;
					case "WHERE":
						syntax["WHERE"] = SQLParser::parseWhere(buffer, err, offset);
						break;
					case "OFFSET":
						syntax["OFFSET"] = SQLParser::parseNumber(buffer, err, offset);
						break;
					case "LIMIT":
						syntax["LIMIT"] = SQLParser::parseNumber(buffer, err, offset);
						break;
					case "ORDER":
						var direction = ToUpper(SQLParser::parseAtom(buffer, err, offset));
						if ((direction == "ASC") || (direction == "ASCENDING"))
							syntax["ORDER"] = 1;
						else
						if ((direction == "DESC") || (direction == "DESCENDING"))
							syntax["ORDER"] = -1;
						else {
							if (err)
								err += "\n";
							err += "Syntax error in SELECT/ORDER: expected 'ASC' or 'DESC', received '$direction'";
						}
						command = direction;
						break;
					case "LEFT":
					case "BASE":
						var recursive_join = true;
						if (command == "BASE")
							recursive_join = false;
						command = ToUpper(SQLParser::parseAtom(buffer, err, offset));
						if (command == "JOIN") {
							var join = syntax["JOIN"];
							if (!join) {
								join = new [];
								syntax["JOIN"] = join;
							}
							var join_now = SQLParser::parseJoin(buffer, err, offset);
							if (join_now) {
								if ((recursive_join) && (last_join)) {
									last_join[length last_join] = join_now;
								} else {
									join[length join] = join_now;
									last_join = join_now;
								}
							}
						} else {
							if (err)
								err += "\n";
							err += "Syntax error in SELECT/LEFT: expected 'JOIN', received '$command'";
						}
						break;
					default:
						if (err)
							err += "\n";
						err += "Syntax error in SELECT: unexpected '$command'";
						return false;
				}
			}
		} while (command);
		return true;
	}

	static parse(buffer, var err = null) {
		var[] statements;
		err = "";
		var offset = 0;
		do {
			var command = ToUpper(SQLParser::parseAtom(buffer, err, offset));
			if (command) {
				var syntax = new [];
				switch (command) {
					case "SELECT":
						if (!SQLParser::parseSelect(buffer, err, offset, syntax)) {
							command = "";
							syntax = null;
						}
						break;
					case "INSERT":
						break;
					case "UPDATE":
						break;
					case "DELETE":
						break;
					case "DROP":
						break;
					default:
						if (err)
							err += "\n";
						err += "Unsupported command '$command'";
						command = "";
						break;
				}
				if (syntax)
					statements[length statements] = syntax;
			}
		} while (command);
		return statements;
	}
}
