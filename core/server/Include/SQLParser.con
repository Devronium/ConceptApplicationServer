import standard.lib.str
import standard.lib.json
import standard.lib.cripto

class SQLParser {
	static error(var err, offset, message) {
		if (err)
			err += "\n";
		err += message;
		if (offset > 0)
			err += " at char $offset";
	}

	static alpha(c) {
		if (((c >= "A") && (c <= "Z")) || ((c >= "a") && (c <= "z")) || (c == "_") || (c == "\$") || (c == "."))
			return true;
		return false;
	}

	static numeric(c) {
		if ((c >= "0") && (c <= "9"))
			return true;
		return false;
	}

	static alphanumeric(c) {
		if (((c >= "A") && (c <= "Z")) || ((c >= "a") && (c <= "z")) || ((c >= "0") && (c <= "9")) || (c == "_") || (c == "\$") || (c == "."))
			return true;
		return false;
	}

	static parseQuote(q, var buffer, var err, var offset, var val, expr = false) {
		val = "";
		switch (q) {
			case '"':
			case "'":
				// 2 types of quotes supported
				val += q;
				break;
			default:
				return false;
		}
		while (offset < length buffer) {
			var c = buffer[offset++];
			val += c;
			if (c == "\\") {
				// skip one
				val += buffer[offset];
				offset++;
				continue;
			}
			if (c == q)
				return true;
		}
		SQLParser::error(err, offset, "Forgot to close quotes");
		return false;
	}

	static parseJSON(q, var buffer, var err, var offset, var val) {
		val = "";
		switch (q) {
			case '{':
				val += q;
				q = "}";
				break;
			case "[":
				val += q;
				q = "]";
				break;
			default:
				return false;
		}
		while (offset < length buffer) {
			var c = buffer[offset++];
			if (SQLParser::parseQuote(c, buffer, err, offset, var json_val)) {
				val += json_val;
			} else
				val += c;
			if (c == q)
				return true;
		}
		SQLParser::error(err, offset, "Forgot to close JSON object");
		return false;
	}

	static parseAtom(var buffer, var err, var offset, list = 0, silent = false) {
		var command = "";
		while (offset < length buffer) {
			var c = buffer[offset++];
			if (SQLParser::alphanumeric(c))
				command += c;
			else
			if (command) {
				offset--;
				break;
			} else
			if (SQLParser::parseQuote(c, buffer, err, offset, command))
				break;
			else
			if (SQLParser::parseJSON(c, buffer, err, offset, command)) {
				break;
			} else {
				if ((c == "-") && (!command) && (SQLParser::numeric(buffer[offset]))) {
					command += c;
					continue;
				}
				switch (c) {
					case "<":
					case ">":
						var next = buffer[offset];
						if (next == "=") {
							c += next;
							offset++;
						} else
						if ((c == "<") && (next == ">")) {
							c = "!=";
							offset++;
						}
					case "*":
					case "+":
					case "-":
					case "=":
					case "^":
					case ",":
					case ";":
						return c;
					case " ":
					case "\t":
						break;
					case "!":
						next = buffer[offset];
						if (next == "=") {
							c += next;
							offset++;
							return c;
						} else {
							SQLParser::error(err, offset, "Unexpected operator '$c'");
							return "";
						}
					case '(':
						if (list == 1)
							return c;
						list = 0;
					case ')':
						if (list == 2)
							return c;
						list = 0;
					default:
						if (silent)
							return c;
						SQLParser::error(err, offset, "Unexpected character '$c'");
						return "";
				}
			}
		}
		return trim(command);
	}

	static strip(atom) {
		if (length atom >= 2) {
			switch (atom[0]) {
				case "'":
				case '"':	
					return SubStr(atom, 1, length atom - 2);
			}
		}
		return atom;
	}

	static is_string(atom) {
		if ((atom[0] == '"') || (atom[0] == "'"))
			return true;
		return false;
	}

	static OneParameter(func, parameters, var err, offset) {
		if (length parameters != 1) {
			SQLParser::error(err, offset, "$func expects one parameter");
			return "";
		}
		return SQLParser::prepare(parameters[0], err);
	}

	static escapestr(var str) {
		var val = StrReplace(str, "\\", "\\\\");
		val = StrReplace(val, "'", "\\'");
		val = StrReplace(val, "\"", "\\'");
		return val;
	}

	static eval(func, parameters, var err, offset) {
		func = ToUpper(func);
		switch (func) {
			case "SHA256":
				return '"' + sha256("" + SQLParser::OneParameter(func, parameters, err, offset)) + '"';
				break;
			case "SHA1":
				return '"' + sha1("" + SQLParser::OneParameter(func, parameters, err, offset)) + '"';
				break;
			case "MD5":
				return '"' + md5("" + SQLParser::OneParameter(func, parameters, err, offset)) + '"';
				break;
			case "CRC32":
				return '"' + crc32("" + SQLParser::OneParameter(func, parameters, err, offset)) + '"';
				break;
			case "UPPER":
				return '"' + SQLParser::escapestr(UTF8ToUpper("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
				break;
			case "LOWER":
				return '"' + SQLParser::escapestr(UTF8ToLower("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
				break;
			case "METAPHONE":
				return '"' + SQLParser::escapestr(Metaphone("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
			case "DOUBLEMETAPHONE":
				return '"' + SQLParser::escapestr(DoubleMetaphone("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
			case "SOUNDEX":
				return '"' + SQLParser::escapestr(Soundex("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
			case "TRIM":
				return '"' + SQLParser::escapestr(trim("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
			case "LTRIM":
				return '"' + SQLParser::escapestr(ltrim("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
			case "RTRIM":
				return '"' + ltrim("" + SQLParser::OneParameter(func, parameters, err, offset)) + '"';
			case "HEX":
				var parameter = SQLParser::OneParameter(func, parameters, err, offset);
				if (typeof parameter == "string")
					return '"' + ToLower(StringToHex(parameter)) + '"';
				return '"' + ToLower(NumberToHex(parameter)) + '"';
			case "BINHEX":
				return '"' + SQLParser::escapestr(HexToString("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
				break;
			case "BINNUMBER":
				return '"' + HexToNumber("" + SQLParser::OneParameter(func, parameters, err, offset)) + '"';
				break;
			case "OIDSTRING":
				return '"' + ToLower(StringToHex("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
			case "OID":
				return '"' + SQLParser::escapestr(HexToString("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
			case "URIENCODE":
				return '"' + SQLParser::escapestr(URIEncode("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
			case "URIDECODE":
				return '"' + SQLParser::escapestr(URIDecode("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
			case "HTML":
				return '"' + SQLParser::escapestr(ToHTML("" + SQLParser::OneParameter(func, parameters, err, offset))) + '"';
			case "CONCAT":
				parameter = "";
				for (var i = 0; i < length parameters; i++)
					parameter += SQLParser::prepare(parameters[i], err);
				return '"' + parameter + '"';
				break;
		}
		return "0";
	}

	static parseValue(var buffer, var err, var offset, list = 0) {
		var atom = SQLParser::parseAtom(buffer, err, offset, list);
		if ((atom) && (atom != "(") && (atom != ")")) {
			if (SQLParser::is_string(atom))
				return atom;
			var prec_offset = offset;
			if (SQLParser::alpha(atom[0])) {
				// if list, silent is true
				var param = SQLParser::parseAtom(buffer, err, offset, 1, list);
				if (param == "(") {
					var parameters = SQLParser::parseList(buffer, err, offset, 2, null, false);
					var end_list = SQLParser::parseAtom(buffer, err, offset, 2);
					if (end_list != ")") {
						SQLParser::error(err, offset, "')' expected");
						return atom;
					}
					return SQLParser::eval(atom, parameters, err, offset);
				}
			}
			offset = prec_offset;
		}
		return atom;
	}

	static removeone(var arr) {
		var one = "";
		if (arr) {
			var[] new_arr;
			var len = length arr - 1;
			one = ToUpper(arr[len]);
			for (var i = 0; i < len; i++)
				new_arr[i] = arr[i];
			arr = new_arr;
		}
		return one;
	}

	static parseList(var buffer, var err, var offset, list = 0, var func = null, strip = true) {
		var[] fields;
		var expect_comma = false;
		var ref_list = list;
		if (ref_list == 3)
			ref_list = 1;
		var target_foo;
		do {
			var prec_offset = offset;
			var command = SQLParser::parseValue(buffer, err, offset, ref_list);
			if (!command) {
				if ((ref_list == 1) && (list == 3))
					return fields;
				SQLParser::error(err, offset, "Syntax error");
				return false;
			}
			if (list == 3) {
				if ((command == "(") && (ref_list == 1)) {
					var f = SQLParser::removeone(fields);
					if (!f) {
						SQLParser::error(err, offset, "Syntax error in aggregation function");
						return false;
					}
					if (!func)
						func = new [];

					target_foo = [f, [ ]];
					func[length func] = target_foo;
					ref_list = 2;
					expect_comma = false;
					continue;
				}
				if ((command == ")") && (ref_list == 2)) {
					ref_list = 1;
					expect_comma = true;
					target_foo = null;
					continue;
				}
			}
			if (expect_comma) {
				if (command != ",") {
					offset = prec_offset;
					return fields;
				}
				expect_comma = false;
			} else {
				var str;
				if (strip)
					str = SQLParser::strip(command);
				else
					str = command;

				if (target_foo)
					target_foo[1][length target_foo[1]] = str;
				else
					fields[length fields] = str;
				expect_comma = true;
			}
		} while (command);
		return fields;
	}

	static parseNumber(var buffer, var err, var offset) {
		var command = SQLParser::parseAtom(buffer, err, offset);
		if (!command) {
			SQLParser::error(err, offset, "Number expected");
			return 0;
		}
		var val = value command;
		if ("" + val != command) {
			SQLParser::error(err, offset, "Invalid number value '$command'");
		}
		return val;
	}

	static prepare(val, var err, var json = false) {
		if (typeof val == "string") {
			switch (val[0]) {
				case "'":
				case '"':
					return SQLParser::strip(val);
				case '{':
				case '[':
					if (json)
						return JSONDeserialize(val);
				default:
					var new_val = value val;
					if ("" + new_val != val) {
						SQLParser::error(err, -1, "Invalid number value '$val'");
					} else
						return new_val;
			}
		}
		return val;
	}

	static prepareList(val, var err, var json = false) {
		if (typeof val == "array") {
			var[] val2;
			for (var i = 0; i < length val; i++)
				val2[i] = SQLParser::prepare(val[i], err, json);
			return val2;
		}
		return SQLParser::prepare(val, err, json);
	}

	static parseWhere(var buffer, var err, var offset) {
		var state = -1;
		var[] criteria;
		var condition;
		var variable = "";
		var op = "";
		do {
			var prev_offset = offset;
			var command = SQLParser::parseValue(buffer, err, offset);
			var is_list = false;
			if (command) {
				switch (state) {
					case -1:
					case 0:
						variable = SQLParser::strip(command);
						condition = criteria[variable];
						if (!condition) {
							condition = new [];
							criteria[variable] = condition;
						}
						state = 1;
						break;
					case 1:
						op = ToUpper(command);
						state = 2;
						if (op == "NOT") {
							command = ToUpper(SQLParser::parseAtom(buffer, err, offset, 1));
							if (command != "IN") {
								SQLParser::error(err, offset, "'IN' expected after 'NOT', found '$command'");
							}
							op = "NOT IN";
						}
						if ((op == "IN")  || (op == "NOT IN")) {
							is_list = true;
							command = SQLParser::parseAtom(buffer, err, offset, 1);
							if (command != "(") {
								SQLParser::error(err, offset, "'(' expected after IN operator");
								command = "";
								break;
							}
							var list = SQLParser::parseList(buffer, err, offset, 2, null, false);
							command = SQLParser::parseAtom(buffer, err, offset, 2);
							if (command != ")") {
								SQLParser::error(err, offset, "')' expected");
								command = "";
								break;
							}
							command = list;
						} else
							break;
					case 2:
						if (is_list)
							var val = SQLParser::prepareList(command, err);
						else
							val = SQLParser::prepare(command, err);
						if ((op == "=") || (op == "IN") || (op == "NOT IN") || (op == "!=")) {
							if (condition) {
								SQLParser::error(err, offset, "Impossible condition (same variable, multiple values; use 'IN' operator)");
							} else
							if ((op == "=") || (op == "IN"))
								criteria[variable] = val;
						}
						if (op == "NOT IN")
							op = "!=";
						condition[op] = val;
						state = 3;
						break;
					case 3:
						state = 0;
						if (ToUpper(command) != "AND") {
							offset = prev_offset;
							command = "";
						}
						break;
				}
			}
		} while (command);
		if ((state != 0) && (state != 3)) {
			SQLParser::error(err, offset, "Invalid WHERE syntax");
		}
		return criteria;
	}

	static parseSet(var buffer, var err, var offset) {
		var state = -1;
		var[] criteria;
		var variable = "";
		var op = "";
		do {
			var prev_offset = offset;
			var command = SQLParser::parseValue(buffer, err, offset);
			if (command) {
				switch (state) {
					case -1:
					case 0:
						variable = SQLParser::strip(command);
						state = 1;
						break;
					case 1:
						op = ToUpper(command);
						if (op != "=") {
							SQLParser::error(err, offset, "'=' expected, '$command' received");
						}
						state = 2;
						break;
					case 2:
						criteria[variable] = SQLParser::prepare(command, err, true);
						state = 3;
						break;
					case 3:
						state = 0;
						if (command != ",") {
							offset = prev_offset;
							command = "";
						}
						break;
				}
			}
		} while (command);
		if ((state != 0) && (state != 3)) {
			SQLParser::error(err, offset, "Invalid SET syntax");
		}
		return criteria;
	}

	static parseJoin(var buffer, var err, var offset, var join_ref) {
		join_ref = "";
		var command = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		if (!command) {
			SQLParser::error(err, offset, "Expected collection name after 'JOIN'");
			return null;
		}
		var collection = command;
		command = ToUpper(SQLParser::parseAtom(buffer, err, offset));
		if (command != "ON") {
			SQLParser::error(err, offset, "Expected 'ON' after 'JOIN collection'");
			return null;
		}
		var field = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		var pos = Pos(field, ".");
		if (pos > 0) {
			join_ref = SubStr(field, 0, pos - 1);
			field = SubStr(field, pos);
		}
		var eq = SQLParser::parseAtom(buffer, err, offset);
		var field2 = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		if ((!field) || (!field2) || (eq != "=")) {
			SQLParser::error(err, offset, "Expected 'field1 = field2' after 'JOIN collection ON'");
			return null;
		}
		return [collection, [field => field2]];
	}

	static parseSelect(var buffer, var err, var offset, syntax) {
		var fields = SQLParser::parseList(buffer, err, offset, 3, var funct);
		if (!fields) {
			if (funct) {
				fields = ["*"];
			} else {
				SQLParser::error(err, offset, "Missing fields in SELECT");
				return false;
			}
		}
		syntax["SELECT"] = fields;
		if (funct)
			syntax["MOD"] = funct;

		if (err)
			false;

		var command = SQLParser::parseAtom(buffer, err, offset);
		if ((!funct) && ((!command) || (command  == ";")) && (fields) && (fields[0] != "*")) {
			syntax["DUMMY"] = true;
			return true;
		}
		if ((!command) || (ToUpper(command) != "FROM")) {
			SQLParser::error(err, offset, "Syntax error in SELECT: expecting 'FROM', found '$command'");
			return false;
		}
		var from = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		if (!from) {
			SQLParser::error(err, offset, "Syntax error in SELECT: expecting collection name after 'FROM'");
			return false;
		}
		syntax["FROM"] = from;
		var last_join;
		var[] join_ref;
		do {
			command = ToUpper(SQLParser::parseAtom(buffer, err, offset));
			if (command) {
				switch (command) {
					case ";":
						return true;
					case "WHERE":
						syntax["WHERE"] = SQLParser::parseWhere(buffer, err, offset);
						break;
					case "OFFSET":
						syntax["OFFSET"] = SQLParser::parseNumber(buffer, err, offset);
						break;
					case "LIMIT":
						syntax["LIMIT"] = SQLParser::parseNumber(buffer, err, offset);
						break;
					case "ORDER":
						var direction = ToUpper(SQLParser::parseAtom(buffer, err, offset));
						if ((direction == "ASC") || (direction == "ASCENDING"))
							syntax["ORDER"] = 1;
						else
						if ((direction == "DESC") || (direction == "DESCENDING"))
							syntax["ORDER"] = -1;
						else {
							SQLParser::error(err, offset, "Syntax error in SELECT/ORDER: expected 'ASC' or 'DESC', received '$direction'");
						}
						command = direction;
						break;
					case "LEFT":
						command = ToUpper(SQLParser::parseAtom(buffer, err, offset));
						if (command == "JOIN") {
							var join = syntax["JOIN"];
							if (!join) {
								join = new [];
								syntax["JOIN"] = join;
							}
							var join_now = SQLParser::parseJoin(buffer, err, offset, var join_collection);
							if (join_now) {
								var join_with = join_now[0];
								var target_join = last_join;
								if (join_collection) {
									target_join = join_ref[join_collection];
									if ((!target_join) && (join_collection != from)) {
										SQLParser::error(err, offset, "Unknown collection '$join_collection' in 'JOIN'");
									}
								}
								join_ref[join_with] = join_now;
								if (target_join) {
									last_join[length last_join] = join_now;
								} else {
									join[length join] = join_now;
									last_join = join_now;
								}
							}
						} else {
							SQLParser::error(err, offset, "Syntax error in SELECT/LEFT: expected 'JOIN', received '$command'");
						}
						break;
					default:
						SQLParser::error(err, offset, "Syntax error in SELECT: unexpected '$command'");
						return false;
				}
			}
		} while (command);
		return true;
	}

	static parseInsert(var buffer, var err, var offset, syntax) {
		var command = ToUpper(SQLParser::parseAtom(buffer, err, offset));
		if (command != "INTO") {
			SQLParser::error(err, offset, "Expected 'INTO' after 'INSERT'");
			return false;
		}
		var collection = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		if (!collection) {
			SQLParser::error(err, offset, "Expected collection name after 'INSERT INTO'");
			return false;
		}
		var atom = ToUpper(SQLParser::parseAtom(buffer, err, offset, 1));
		var list = null;
		var expect_json = false;
		switch (atom) {
			case "(":
				list = SQLParser::parseList(buffer, err, offset, 2);
				if (SQLParser::parseAtom(buffer, err, offset, 2) != ")") {
					SQLParser::error(err, offset, "Expected ')'");
					return false;
				}
				atom = ToUpper(SQLParser::parseAtom(buffer, err, offset));
				if (atom != "VALUES") {
					SQLParser::error(err, offset, "Expected 'VALUES' after collection name: unexpected '$atom'");
					return false;
				}
				if (!list)
					expect_json = true;
				break;
			case "VALUES":
				expect_json = true;
				break;
			default:
				SQLParser::error(err, offset, "Expected 'VALUES' after collection name: unexpected '$atom'");
				return false;
		}
		var obj;
		if (expect_json) {
			atom = SQLParser::parseAtom(buffer, err, offset);
			obj = SQLParser::prepare(atom, err, true);
			if (typeof obj != "array") {
				SQLParser::error(err, offset, "Invalid JSON object '$atom'");
				return false;
			}
		} else {
			atom = SQLParser::parseAtom(buffer, err, offset, 1);
			if (atom != "(") {
				SQLParser::error(err, offset, "Expected '(' after 'VALUES'");
				return false;
			}
			var values = SQLParser::parseList(buffer, err, offset, 2, null, false);
			if (SQLParser::parseAtom(buffer, err, offset, 2) != ")") {
				SQLParser::error(err, offset, "Expected ')'");
				return false;
			}
			if ((!values) || (length list != length values)) {
				SQLParser::error(err, offset, "Values count mismatch in 'INSERT INTO collection(field_list) VALUES(value_list)");
				return false;
			}
			obj = new [];
			for (var i = 0; i < length list; i++) {
				var field = SQLParser::strip(list[i]);
				if (field == '$') {
					SQLParser::error(err, offset, "Cannot use object volatile reference in INSERT. Use UPDATE instead");
					return false;
				}
				obj[field] = SQLParser::prepare(values[i], err, true);
			}
		}
		syntax["INSERT"] = obj;
		syntax["INTO"] = collection;
		if (!obj) {
			SQLParser::error(err, offset, "Nothing to 'INSERT'");
			return false;
		}
		atom = SQLParser::parseAtom(buffer, err, offset);
		if ((atom) && (atom != ";")) {
			SQLParser::error(err, offset, "Expected ';'");
			return false;
		}
		return true;
	}

	static parseDelete(var buffer, var err, var offset, syntax) {
		syntax["DELETE"] = "*";
		var command = SQLParser::parseAtom(buffer, err, offset);
		if ((!command) || (ToUpper(command) != "FROM")) {
			SQLParser::error(err, offset, "Syntax error in DELETE: expecting 'FROM', found '$command'");
			return false;
		}
		var from = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		if (!from) {
			SQLParser::error(err, offset, "Syntax error in DELETE: expecting collection name after 'FROM'");
			return false;
		}
		syntax["FROM"] = from;
		var has_where = false;
		do {
			command = ToUpper(SQLParser::parseAtom(buffer, err, offset));
			if (command) {
				switch (command) {
					case ";":
						return true;
					case "OFFSET":
						syntax["OFFSET"] = SQLParser::parseNumber(buffer, err, offset);
						break;
					case "LIMIT":
						syntax["LIMIT"] = SQLParser::parseNumber(buffer, err, offset);
						break;
					case "ORDER":
						var direction = ToUpper(SQLParser::parseAtom(buffer, err, offset));
						if ((direction == "ASC") || (direction == "ASCENDING"))
							syntax["ORDER"] = 1;
						else
						if ((direction == "DESC") || (direction == "DESCENDING"))
							syntax["ORDER"] = -1;
						else {
							SQLParser::error(err, offset, "Syntax error in DELETE/ORDER: expected 'ASC' or 'DESC', received '$direction'");
						}
						command = direction;
						break;
					case "WHERE":
						if (!has_where) {
							has_where = true;
							syntax["WHERE"] = SQLParser::parseWhere(buffer, err, offset);
							break;
						}
					default:
						SQLParser::error(err, offset, "Syntax error in DELETE: unexpected '$command'");
						return false;
				}
			}
		} while (command);
		return true;
	}

	static parseDropIndex(var buffer, var err, var offset, syntax) {
		var atom = ToUpper(SQLParser::parseAtom(buffer, err, offset));
		if (atom != "ON") {
			SQLParser::error(err, offset, "Expected 'ON' after 'DROP INDEX'");
			return false;
		}
		var from = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		if (!from) {
			SQLParser::error(err, offset, "Syntax error in DROP INDEX: expecting collection name after 'DROP INDEX ON'");
			return false;
		}
		syntax["DROP INDEX"] = from;
		atom = SQLParser::parseAtom(buffer, err, offset, 1);
		if (atom != "(") {
			SQLParser::error(err, offset, "Syntax error in DROP INDEX: expecting field list");
			return false;
		}
		var list = SQLParser::parseList(buffer, err, offset, 2);
		if (SQLParser::parseAtom(buffer, err, offset, 2) != ")") {
			SQLParser::error(err, offset, "Expected ')'");
			return false;
		}
		syntax["ON"] = list;
		atom = SQLParser::parseAtom(buffer, err, offset);
		if ((atom) && (atom != ";")) {
			SQLParser::error(err, offset, "Expected ';'");
			return false;
		}
		if (!list) {
			SQLParser::error(err, offset, "Field list is empty");
			return false;
		}
		return true;
	}

	static parseDrop(var buffer, var err, var offset, syntax) {
		var atom = ToUpper(SQLParser::parseAtom(buffer, err, offset));
		if (atom == "INDEX")
			return SQLParser::parseDropIndex(buffer, err, offset, syntax);
		if (atom != "COLLECTION") {
			SQLParser::error(err, offset, "Expected 'COLLECTION' or 'INDEX' after 'DROP'");
			return false;
		}		
		var from = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		if (!from) {
			SQLParser::error(err, offset, "Syntax error in DROP: expecting collection name after 'COLLECTION'");
			return false;
		}
		syntax["DROP"] = from;
		atom = SQLParser::parseAtom(buffer, err, offset);
		if ((atom) && (atom != ";")) {
			SQLParser::error(err, offset, "Expected ';'");
			return false;
		}
		return true;
	}


	static parseCreateIndex(var buffer, var err, var offset, syntax) {
		var atom = ToUpper(SQLParser::parseAtom(buffer, err, offset));
		var bm25 = false;
		var lang_id = "";
		if (atom == "BM25") {
			atom = ToUpper(SQLParser::parseAtom(buffer, err, offset, 1));
			if (atom == "(") {
				atom = SQLParser::strip(ToLower(SQLParser::parseAtom(buffer, err, offset, 2)));
				if (atom != ")") {
					lang_id = atom;
					atom = SQLParser::parseAtom(buffer, err, offset, 2);
				}
				if (atom != ")") {
					SQLParser::error(err, offset, "Expected ')', received '$atom'");
				}
				atom = ToUpper(SQLParser::parseAtom(buffer, err, offset));
			}
			bm25 = true;
		}
		if (atom != "INDEX") {
			if (bm25)
				SQLParser::error(err, offset, "Expected 'INDEX' after 'CREATE BM25', received '$atom'");
			else
				SQLParser::error(err, offset, "Expected 'INDEX' or 'BM25' after 'CREATE', received '$atom'");
			return false;
		}
		atom = ToUpper(SQLParser::parseAtom(buffer, err, offset));
		if (atom != "ON") {
			SQLParser::error(err, offset, "Expected 'ON' after 'CREATE INDEX'");
			return false;
		}
		var from = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		if (!from) {
			SQLParser::error(err, offset, "Syntax error in CREATE INDEX: expecting collection name after 'CREATE INDEX ON'");
			return false;
		}
		syntax["INDEX"] = from;
		if (bm25) {
			syntax["BM25"] = true;
			syntax["LANG"] = lang_id;
		}
		atom = SQLParser::parseAtom(buffer, err, offset, 1);
		if (atom != "(") {
			if ((bm25) && ((!atom) || (atom == ";")))
				return true;
			SQLParser::error(err, offset, "Syntax error in CREATE INDEX: expecting field list, received '$atom'");
			return false;
		}
		var list = SQLParser::parseList(buffer, err, offset, 2);
		if (SQLParser::parseAtom(buffer, err, offset, 2) != ")") {
			SQLParser::error(err, offset, "Expected ')'");
			return false;
		}
		syntax["ON"] = list;
		atom = SQLParser::parseAtom(buffer, err, offset);
		if ((atom) && (atom != ";")) {
			SQLParser::error(err, offset, "Expected ';'");
			return false;
		}
		if (!list) {
			SQLParser::error(err, offset, "Field list is empty");
			return false;
		}
		return true;
	}

	static parseUpdate(var buffer, var err, var offset, syntax) {
		var from = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		if (!from) {
			SQLParser::error(err, offset, "Syntax error in UPDATE: expecting collection name");
			return false;
		}
		syntax["UPDATE"] = from;
		var has_where = false;
		do {
			var command = ToUpper(SQLParser::parseAtom(buffer, err, offset));
			if (command) {
				switch (command) {
					case ";":
						return true;
					case "OFFSET":
						syntax["OFFSET"] = SQLParser::parseNumber(buffer, err, offset);
						break;
					case "LIMIT":
						syntax["LIMIT"] = SQLParser::parseNumber(buffer, err, offset);
						break;
					case "ORDER":
						var direction = ToUpper(SQLParser::parseAtom(buffer, err, offset));
						if ((direction == "ASC") || (direction == "ASCENDING"))
							syntax["ORDER"] = 1;
						else
						if ((direction == "DESC") || (direction == "DESCENDING"))
							syntax["ORDER"] = -1;
						else {
							SQLParser::error(err, offset, "Syntax error in UPDATE/ORDER: expected 'ASC' or 'DESC', received '$direction'");
						}
						command = direction;
						break;
					case "SET":
						// to do
						syntax["SET"] = SQLParser::parseSet(buffer, err, offset);
						break;
					case "WHERE":
						if (!has_where) {
							has_where = true;
							syntax["WHERE"] = SQLParser::parseWhere(buffer, err, offset);
							break;
						}
					default:
						SQLParser::error(err, offset, "Syntax error in UPDATE: unexpected '$command'");
						return false;
				}
			}
		} while (command);
		return true;
	}

	static parseSequence(var buffer, var err, var offset, syntax) {
		var from = SQLParser::strip(SQLParser::parseAtom(buffer, err, offset));
		if (!from) {
			SQLParser::error(err, offset, "Syntax error in SEQUENCE: expecting sequence name after 'SEQUENCE'");
			return false;
		}
		syntax["SEQUENCE"] = from;
		var atom = ToUpper(SQLParser::parseAtom(buffer, err, offset));
		if (atom == "INCREMENT") {
			atom = SQLParser::parseAtom(buffer, err, offset);
			if (ToUpper(atom) == "BY")
				atom = SQLParser::parseAtom(buffer, err, offset);
			atom = SQLParser::prepare(SQLParser::strip(atom), err);
			syntax["INCREMENT"] = atom;
			atom = SQLParser::parseAtom(buffer, err, offset);
		} else
			syntax["INCREMENT"] = 1;
		if ((atom) && (atom != ";")) {
			SQLParser::error(err, offset, "Expected ';'");
			return false;
		}
		return true;
	}

	static parse(buffer, var err = null) {
		var[] statements;
		err = "";
		var offset = 0;
		do {
			var command = ToUpper(SQLParser::parseAtom(buffer, err, offset));
			if (command) {
				var syntax = new [];
				switch (command) {
					case "SELECT":
						if (!SQLParser::parseSelect(buffer, err, offset, syntax)) {
							command = "";
							syntax = null;
						}
						break;
					case "INSERT":
						if (!SQLParser::parseInsert(buffer, err, offset, syntax)) {
							command = "";
							syntax = null;
						}
						break;
					case "UPDATE":
						if (!SQLParser::parseUpdate(buffer, err, offset, syntax)) {
							command = "";
							syntax = null;
						}
						break;
					case "DELETE":
						if (!SQLParser::parseDelete(buffer, err, offset, syntax)) {
							command = "";
							syntax = null;
						}
						break;
					case "DROP":
						if (!SQLParser::parseDrop(buffer, err, offset, syntax)) {
							command = "";
							syntax = null;
						}
						break;
					case "CREATE":
						if (!SQLParser::parseCreateIndex(buffer, err, offset, syntax)) {
							command = "";
							syntax = null;
						}
						break;
					case "SEQUENCE":
						if (!SQLParser::parseSequence(buffer, err, offset, syntax)) {
							command = "";
							syntax = null;
						}
						break;
					case ";":
						// ignore it
						break;
					default:
						SQLParser::error(err, offset, "Unsupported command '$command'");
						command = "";
						break;
				}
				if (syntax)
					statements[length statements] = syntax;
			}
		} while (command);
		return statements;
	}
}
