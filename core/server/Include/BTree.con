include File.con
import standard.lang.serialize
import standard.C.casts
import standard.C.math

define NODE_LOGICAL_ELEMENTS 	3
define NODE_VAL_OFFSET		1
define NODE_RIGHT_OFFSET 	2

//define NODE_SIZE		24
//define PACK_MASK		"i64i64i64"
//define LEFT_RIGHT_MASK	"i64i64i64i64"
//define PAYLOAD_MASK		"i64i64"

define NODE_SIZE		25
define PACK_MASK		"*8i64i64"
define LEFT_RIGHT_MASK		"u64*8i64u64"
define PAYLOAD_MASK		"*8i64"

define NODE_SIZE_NOVAL		25
define PACK_MASK_NOVAL		"i64*8u64"
define LEFT_RIGHT_MASK_NOVAL	"u64i64*8u64"
define PAYLOAD_MASK_NOVAL	"i64*8"

define LINKEDLIST_NODE_SIZE	16
define LINKEDLIST_NODE		"i64u64"

define PAYLOAD_ELEMENTS		2
define PAGE_SYNC		page[i++], page[i++], page[i]


define PAGE_SIZE		30

define BTREE_HEADER_SIZE 	64
define STATIC_COMPARE_CODE	{ if (node > val) cmp = 1; else if (node == val) cmp = 0; else cmp = -1; }

define QUERY_ELEMENT_VALID	1
define QUERY_ELEMENT_NEXT	2
define QUERY_ELEMENT_PREV	4
define QUERY_ELEMENT_ALL	7
// not equal but in interval
define QUERY_SKIP		6
define QUERY_LESS		QUERY_ELEMENT_NEXT
define QUERY_GREAT		QUERY_ELEMENT_PREV
define QUERY_EQUAL		QUERY_ELEMENT_VALID
define QUERY_INTERVAL		QUERY_ELEMENT_ALL
define INLINE_RECURSIVE_RESET	if (fseek(f_handle, offset, SEEK_SET)) throw "B-Tree seek error in " + @class + "." + @member + ", offset: $offset";page = ReadPage(elements);trace[length trace] = offset;target_node = -1;bottom_layer = !(page[0]);pos = int32(elements/2);delta = elements - pos;left = 0;right = 0;cmp = 0;node = 0; if ((elements < PAGE_SIZE) || (!bottom_layer)) continue; break;

class BTreeFile {
	protected var f;
	protected var f_handle;
	protected var cached_fmt = "";
	protected var cached_root;
	protected var has_garbage_cache = true;
	protected var has_garbage_node_cache = true;
	protected var ReverseKeyVal;

	public var compare;
	public var UserData;
	public property File { get f }

	BTreeFile(f, compare_func = null, userdata = null, ReverseKeyVal = false) {
		this.f = f;
		this.f_handle = f.Handle;
		this.compare = compare_func;
		this.UserData = userdata;
		this.ReverseKeyVal = ReverseKeyVal;
	}

	protected AddPage(var offset, pages = 1, append = true, elements = 0) {
		if (ReverseKeyVal)
			var buf = pack("u16:" + (NODE_SIZE_NOVAL * PAGE_SIZE + 10), elements);
		else
			buf = pack("u16:" + (NODE_SIZE * PAGE_SIZE + 10), elements);
		if (buf) {
			if (append) {
				if (has_garbage_cache)
					offset = this.PopGarbage();
				else
					offset = 0;
				if (offset <= 0) {
					//if (!f.Seek(0, SEEK_END))
					if (fseek(f_handle, 0, SEEK_END))
						throw "B-Tree seek error in " + @class + "." + @member;
				} else {
					//if (!f.Seek(offset))
					if (fseek(f_handle, offset, SEEK_SET))
						throw "B-Tree seek error in " + @class + "." + @member;
				}
			}
			offset = ftell(f_handle);//f.Tell();
			while (pages-- > 0) {
				if (f.Write(buf) != length buf)
					return -3;
			}
			return length buf;
		}
		return -2;
	}

	protected SeekToPage(page_num) {
		if (ReverseKeyVal)
			var offset = BTREE_HEADER_SIZE + page_num * (PAGE_SIZE * NODE_SIZE_NOVAL + 10);
		else
			offset = BTREE_HEADER_SIZE + page_num * (PAGE_SIZE * NODE_SIZE + 10);
		return f.Seek(offset);
	}

	protected CacheFormat() {
		var limit = PAGE_SIZE * NODE_LOGICAL_ELEMENTS + 1;
		var fmt = "i64";
		if (this.ReverseKeyVal) {
			for (var i = 1; i < limit; i += NODE_LOGICAL_ELEMENTS) 
				fmt += PACK_MASK_NOVAL;
		} else {
			for (i = 1; i < limit; i += NODE_LOGICAL_ELEMENTS) 
				fmt += PACK_MASK;
		}
		cached_fmt = fmt;
		return fmt;
	}

	protected ReadPage(var val = null) {
		if (ReverseKeyVal)
			var bytes = PAGE_SIZE * NODE_SIZE_NOVAL + 10;
		else
			bytes = PAGE_SIZE * NODE_SIZE + 10;

		//if (f.Read(var buf, bytes) != bytes) {
		if (fread(var buf, 1, bytes, f_handle) != bytes) {
			val = -1;
			return null;
		}
		val = unpack("u16", buf)[0];

		var fmt = cached_fmt;
		if (!fmt)
			fmt = CacheFormat();
		var d = unpack(fmt, buf, 2);
		return d;
	}

	protected FullSyncPage(page, elements, offset) {
		//if (!f.Seek(offset))
		if (fseek(f_handle, offset, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;
		var buf = pack("i64", page[0]);
		var page_size = PAGE_SIZE * NODE_LOGICAL_ELEMENTS + 1;
		if (ReverseKeyVal) {
			for (var i = 1; i < page_size; i++)
				buf += pack(PACK_MASK_NOVAL, PAGE_SYNC);
		} else {
			for (i = 1; i < page_size; i++)
				buf += pack(PACK_MASK, PAGE_SYNC);
		}
		f.Write(pack("u16", elements) + buf);
	}

	protected MakePlace(page, pos, elements, offset = -1, val = 0, stored_val = 0) {
		var idx = pos * NODE_LOGICAL_ELEMENTS + 1;
		var limit = elements * NODE_LOGICAL_ELEMENTS + 1;
		for (var i = limit; i > idx; i--) {
			var v = page[i - 1];
			page[i + NODE_RIGHT_OFFSET] = v;
		}
		page[idx - 1] = 0;
		page[idx] = val;
		page[idx + NODE_VAL_OFFSET] = stored_val;

		if (offset >= 0)
			this.FullSyncPage(page, elements + 1, offset);
		return pos;
	}

	protected ValidatePage(offset, error, check_count = true) {
		if (!f.Seek(offset))
			throw "B-Tree seek error in " + @class + "." + @member;
		var page = ReadPage(var elements);
		var limit = elements * PAYLOAD_ELEMENTS  + 1;
		var[] values;
		var idx = 0;
		for (var i = 1; i < limit; i += NODE_LOGICAL_ELEMENTS) {
			var node = ""+page[i];
			idx++;
			if ((node == 0) && (check_count))
				throw "$error: Invalid elements count $idx/$elements";

			if (values[node])
				throw "$error: offset $offset, value $idx/$elements : $node";

			values[node] = true;
		}
	}

	protected AddToPage(page, val, stored_val, left_link, right_link, elements) {
		var i;

		var target_node = -1;
		var compare = this.compare;

		var pos = int32(elements/2);
		var delta = elements - pos;
		var cmp;

		if (elements <= PAGE_SIZE) {
			while (true) {
				if ((pos < 0) || (pos >= elements))
					return null;
				i = pos * NODE_LOGICAL_ELEMENTS + 1;
				var node = page[i];
				var node_val = page[i + NODE_VAL_OFFSET];
				if (compare)
					cmp = compare(node, page[i + NODE_VAL_OFFSET], val, stored_val, this, 2);
				else
					STATIC_COMPARE_CODE
				if (!cmp) {
					target_node = pos;
					if (!ReverseKeyVal) {
						if ((left_link) || (right_link))
							throw "B-Tree add to page error in " + @class + "." + @member;
						var new_node;
						if (node_val < 0)
							new_node = this.CreateLinkNode(stored_val, -node_val);
						else
							new_node = this.CreateLinkNode(stored_val, this.CreateLinkNode(node_val));
						val = node;
						stored_val = -new_node;
					}
					break;
				}

				if (delta) {
					var prec_pos = pos;
					if (cmp < 0) {
						pos += delta;
						if (pos >= elements) {
							pos = elements - 1;
							if (prec_pos == pos)
								delta = 0;
						}
					} else {
						pos -= delta;
						if (pos < 0) {
							pos = 0;
							if (prec_pos == pos)
								delta = 0;
						}
					}
				}
				if (!delta) {
					if (cmp > 0)
						target_node = MakePlace(page, pos, elements, -1, val, stored_val);
					else
					if (cmp < 0)
						target_node = MakePlace(page, pos + 1, elements, -1, val, stored_val);
					break;
				}
				if (delta == 1)
					delta = 0;
				else
					delta = int32(delta/2) + delta % 2;
			}
		}
		if (target_node < 0)
			target_node  = pos;
		i = target_node * NODE_LOGICAL_ELEMENTS + 1;

		page[i - 1] = left_link;
		page[i] = val;
		page[i + NODE_VAL_OFFSET] = stored_val;
		page[i + NODE_RIGHT_OFFSET] = right_link;
	}

	protected PageContains(page, val, stored_val = -1) {
		var compare = this.compare;
		for (var i = 1; i < length page; i+= NODE_LOGICAL_ELEMENTS) {
			var node = page[i];
			var cmp;
			if (compare)
				cmp = compare(node, page[i + NODE_VAL_OFFSET], val, stored_val, this, false);
			else
			if (node == val)
				cmp = 0;
			if (!cmp) // node == val
				return true;
		}
		return false;
	}

	protected Split(page, elements, prev_offset, val, stored_val, var tree_root, pos = -1, left_link = 0, right_link = 0) {
		if (pos < 0)
			pos = length prev_offset - 1;

		var i;
		var node;
		if (!page) {
			var left_offset = prev_offset[pos];
			//if (!f.Seek(left_offset))
			if (fseek(f_handle, left_offset, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member;
			page = ReadPage(elements);
			if (elements < PAGE_SIZE) {
				AddToPage(page, val, stored_val, left_link, right_link, elements);
				FullSyncPage(page, elements + 1, left_offset);
				return;
			}
		}
		var pack_mask;
		var left_right_mask;
		var node_size;
		if (ReverseKeyVal) {
			pack_mask = PACK_MASK_NOVAL;
			left_right_mask = LEFT_RIGHT_MASK_NOVAL;
			node_size = NODE_SIZE_NOVAL;
		} else {
			pack_mask = PACK_MASK;
			left_right_mask = LEFT_RIGHT_MASK;
			node_size = NODE_SIZE;
		}
		AddToPage(page, val, stored_val, left_link, right_link, elements);

		// left
		var size = AddPage(left_offset);

		var middle = int32(PAGE_SIZE / 2) + 1;
		var middle_val = middle * NODE_LOGICAL_ELEMENTS;
		node = page[middle_val + 1];
		var node_val = page[middle_val + 2];
		//var node_flags = page[middle_val + 3];

		var buf = pack("i64", page[0]);
		var limit = middle_val + NODE_RIGHT_OFFSET;
		for (i = 1; i < limit; i++)
			buf += pack(pack_mask, PAGE_SYNC);

		//if (!f.Seek(left_offset))
		if (fseek(f_handle, left_offset, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;

		f.Write(pack("u16", middle) + buf);

		var right_offset = prev_offset[pos];

		// right
		//if (!f.Seek(right_offset))
		if (fseek(f_handle, right_offset, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;
		AddPage(null, 1, false);

		var start = middle_val + NODE_LOGICAL_ELEMENTS;
		buf = pack("i64", page[start++]);
		for (i = start; i < length page; i++)
			buf  += pack(pack_mask, PAGE_SYNC);

		//if (!f.Seek(right_offset))
		if (fseek(f_handle, right_offset, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;

		f.Write(pack("u16", (length buf - 1) / node_size) + buf);

		if (!pos) {
			var node_buf = pack(left_right_mask, left_offset, node, node_val, right_offset);
			size = AddPage(var offset);
			//if (!f.Seek(offset))
			if (fseek(f_handle, offset, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member;
			f.Write(pack("u16", 1) + node_buf);

			if (tree_root > 0)
				tree_root = offset;
			else
				this.WriteRoot(offset);
		} else {
			Split(null, 0, prev_offset, node, node_val, tree_root, pos - 1, left_offset, right_offset);
		}
	}

	private SyncNode(offset, index, key, val) {
		//if (!f.Seek(offset + 10 + index * NODE_SIZE))
		if (ReverseKeyVal) {
			if (fseek(f_handle, offset + 10 + index * NODE_SIZE_NOVAL, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member;
			f.Write(pack(PAYLOAD_MASK_NOVAL, key, val));
		} else {
			if (fseek(f_handle, offset + 10 + index * NODE_SIZE, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member;
			f.Write(pack(PAYLOAD_MASK, key, val));
		}
	}

	private RecursiveAdd(offset, trace, val, stored_val, var tree_root, no_replace) {
		//if (!f.Seek(offset))
		if (fseek(f_handle, offset, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member + ", offset: $offset";
		var page = ReadPage(var elements);
		trace[length trace] = offset;

		var target_node = -1;
		var bottom_layer = !(page[0]);
		var compare = this.compare;

		var pos = int32(elements/2);
		var delta = elements - pos;
		var cmp;
		var sync_elements = true;

		if ((elements < PAGE_SIZE) || (!bottom_layer)) {
			while (true) {
				if ((pos < 0) || (pos >= elements))
					return null;

				var i = pos * NODE_LOGICAL_ELEMENTS + 1;
				var left = page[i-1];
				var node = page[i];
				var node_val = page[i+NODE_VAL_OFFSET];
				var right = page[i+NODE_RIGHT_OFFSET];

				if (compare)
					cmp = compare(node, node_val, val, stored_val, this, bottom_layer);
				else
					STATIC_COMPARE_CODE
				if (!cmp) {
					if (no_replace == 1) {
						if (node != val)
							return false;
						return true;
					} else
					if (!ReverseKeyVal) {
						var new_node;
						if (node_val < 0)
							new_node = this.CreateLinkNode(stored_val, -node_val);
						else
							new_node = this.CreateLinkNode(stored_val, this.CreateLinkNode(node_val));
						val = node;
						stored_val = -new_node;
					}
					sync_elements = false;
					// update
					target_node = pos;
					//elements--;
					break;
				}

				if (delta) {
					var prec_pos = pos;
					if (cmp < 0) {
						pos += delta;
						if (pos >= elements) {
							pos = elements - 1;
							if (prec_pos == pos)
								delta = 0;
						}
					} else {
						pos -= delta;
						if (pos < 0) {
							pos = 0;
							if (prec_pos == pos)
								delta = 0;
						}
					}
				}
				if (!delta) {
					if (cmp > 0) {
						if (left) {
							offset = left;
							INLINE_RECURSIVE_RESET
							//return RecursiveAdd(left, trace, val, stored_val, tree_root, no_replace);
						}
						if (elements < PAGE_SIZE) {
							MakePlace(page, pos, elements, offset, val, stored_val);
							return true;
						}
					} else
					if (cmp < 0) {
						if (right) {
							offset = right;
							INLINE_RECURSIVE_RESET
							//return RecursiveAdd(right, trace, val, stored_val, tree_root);
						}
						if (elements < PAGE_SIZE) {
							MakePlace(page, pos + 1, elements, offset, val, stored_val);
							return true;
						}
					}
					break;
				}
				if (delta == 1)
					delta = 0;
				else
					delta = int32(delta/2) + delta % 2;
			}
		}

		if (target_node >= 0) {
			this.SyncNode(offset, target_node, val, stored_val);
			//if (!f.Seek(offset))
			if (sync_elements) {
				if (fseek(f_handle, offset, SEEK_SET))
					throw "B-Tree seek error in " + @class + "." + @member;
				f.Write(pack("u16", elements/* + 1*/));
			}
			return true;
		}

		if ((cmp < 0) && (left))
			return RecursiveAdd(left, trace, val, stored_val, tree_root, no_replace);
		else
		if ((cmp > 0) && (right))
			return RecursiveAdd(right, trace, val, stored_val, tree_root, no_replace);

		Split(page, elements, trace, val, stored_val, tree_root);
		return true;
	}

	public Add(key, val, no_replace = false, var tree_root = -1) {
		var[] trace;
		if (this.GoToRoot(tree_root, var offset)) {
			return RecursiveAdd(offset, trace, key, val, tree_root, no_replace);
		} else {
			if (tree_root > 0)
				throw "B-Tree subtree error (non-existent) " + @class + "." + @member;
			this.WriteHeader();
			AddPage(offset);

			//if (!f.Seek(offset))
			if (fseek(f_handle, offset, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member;
			var page = ReadPage();
			if (!page)
				throw "I/O error in B-Tree";
			this.SyncNode(offset, 0, key, val);
			//if (!f.Seek(offset))
			if (fseek(f_handle, offset, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member;
			f.Write(pack("u16", 1));
		}
		return true;
	}

	protected GoToRoot(var subtree_offset = -1, var ref_root = null) {
		if (subtree_offset > 0) {
			ref_root = subtree_offset;
			return f.Seek(subtree_offset);
		}

		if (cached_root) {
			ref_root = cached_root;
			if (f.Seek(cached_root))
				return true;
			else
				cached_root = 0;
		}
		//if (!f.Seek(3))
		if (fseek(f_handle, 3, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;
		//if (f.Read(var buf, 8) == 8) {
		if (fread(var buf, 1, 8, f_handle) == 8) {
			var arr = unpack("u64", buf);
			var address = BTREE_HEADER_SIZE + arr[0];
			if (!f.Seek(address))
				throw "B-Tree seek error in " + @class + "." + @member;
			cached_root = address;
			ref_root = address;
			return true;
		}
		ref_root = -1;
		return false;
	}

	protected WriteHeader(root_offset = BTREE_HEADER_SIZE) {
		//if (!f.Seek(0))
		if (fseek(f_handle, 0, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;
		cached_root = root_offset;
		return f.Write(pack("su64u64u64s:" + BTREE_HEADER_SIZE, "DBX", root_offset - BTREE_HEADER_SIZE, 0, 0, "ConceptDB index file"));
	}

	protected WriteRoot(root_offset = BTREE_HEADER_SIZE) {
		//if (!f.Seek(3))
		if (fseek(f_handle, 3, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;
		cached_root = root_offset;
		return f.Write(pack("u64", root_offset - BTREE_HEADER_SIZE));
	}


	protected PushGarbageNode(offset) {
		if (offset <= 0)
			return -2;

		if (fseek(f_handle, 19, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;
		if (fread(var buf, 1, 8, f_handle) != 8)
			throw "B-Tree read error in " + @class + "." + @member;
		var prec_garbage = unpack("u64", buf)[0];

		if (fseek(f_handle, offset + 8, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;

		f.Write(pack("u64", prec_garbage));

		if (fseek(f_handle, 19, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;
		has_garbage_node_cache = true;
		return f.Write(pack("u64", offset));
	}

	protected PopGarbageNode() {
		if (fseek(f_handle, 19, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member + ":" + @line;
		if (fread(var buf, 1, 8, f_handle) != 8)
			throw "B-Tree read error in " + @class + "." + @member + ":" + @line;
		var offset = unpack("u64", buf)[0];
		if (offset) {
			has_garbage_node_cache = true;
			if (fseek(f_handle, offset, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member + ":" + @line;

			if (fread(buf, 1, LINKEDLIST_NODE_SIZE, f_handle) != LINKEDLIST_NODE_SIZE)
				throw "B-Tree read error in " + @class + "." + @member + ":" + @line;

			var next_block = unpack(LINKEDLIST_NODE, buf)[1];
			if (fseek(f_handle, 19, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member + ":" + @line;
			f.Write(pack("u64", next_block));

			return offset;
		}
		has_garbage_node_cache = false;
		return 0;
	}

	

	protected PushGarbage(offset) {
		if (offset <= 0)
			return -2;

		//if (!f.Seek(11))
		if (fseek(f_handle, 11, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;
		//if (f.Read(var buf, 8) != 8)
		if (fread(var buf, 1, 8, f_handle) != 8)
			throw "B-Tree read error in " + @class + "." + @member;
		var garbage = unpack("u64", buf)[0];
		//if (!f.Seek(offset))
		if (fseek(f_handle, offset, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;
		f.Write(pack("u64", garbage));
		//if (!f.Seek(11))
		if (fseek(f_handle, 11, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;
		has_garbage_cache = true;
		return f.Write(pack("u64", offset));
	}

	protected PopGarbage() {
		//if (!f.Seek(11))
		if (fseek(f_handle, 11, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;
		//if (f.Read(var buf, 8) != 8)
		if (fread(var buf, 1, 8, f_handle) != 8)
			throw "B-Tree read error in " + @class + "." + @member;

		var offset = unpack("u64", buf)[0];
		if (offset) {
			has_garbage_cache = true;
			//if (!f.Seek(offset))
			if (fseek(f_handle, offset, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member;

			//if (f.Read(buf, 8) != 8)
			if (fread(buf, 1, 8, f_handle) != 8)
				throw "B-Tree read error in " + @class + "." + @member;

			var next_block = unpack("u64", buf)[0];
			//if (!f.Seek(11))
			if (fseek(f_handle, 11, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member;
			f.Write(pack("u64", next_block));

			return offset;
		}
		has_garbage_cache = false;
		return 0;
	}

	CountGarbagePages() {
		//if (!f.Seek(11))
		if (fseek(f_handle, 11, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member;
		var pages = 0;
		var offset;
		do {
			//if (f.Read(var buf, 8) != 8)
			if (fread(var buf, 1, 8, f_handle) != 8)
				throw "B-Tree read error in " + @class + "." + @member;
			offset = unpack("u64", buf)[0];
			if (offset) {
				pages++;
				//if (!f.Seek(offset))
				if (fseek(f_handle, offset, SEEK_SET))
					throw "B-Tree seek error in " + @class + "." + @member;
			}
		} while (offset);
		return pages;
	}

	GetTree(offset = 0, stack = null) {
		if (!offset) {
			GoToRoot();
			stack = new [];
		} else {
			if (!f.Seek(offset))
				throw "B-Tree seek error in " + @class + "." + @member;
		}
		stack["" + ftell(f_handle)] = true;
		var page = ReadPage(var elements);
		var[] res;
		if ((page) && (elements)) {
			var i = 0;
			var idx = 0;
			while (i < length page) {
				var val = page[i];
				if (i % NODE_LOGICAL_ELEMENTS == 0) {
					if (val) {
						if (stack[""+val]) {
							page[i] = "RECURSIVE ERROR: $val";
						} else
							page[i] = GetTree(val, stack);
					}
					res[length res] = page[i];
				} else {
					if ((idx >= elements) && (page[1]))
						break;

					res[length res] = page[i];
					if (i % NODE_LOGICAL_ELEMENTS == NODE_RIGHT_OFFSET)
						idx++;
				}
				i++;
			}
		}
		return res;
	}

	protected _WarmOSCache(offset = 0) {
		if (!offset)
			GoToRoot();
		else
		if (!f.Seek(offset))
			throw "B-Tree seek error in " + @class + "." + @member;
		
		var page = ReadPage(var elements);
		var idx = 0;
		var elements_count = 0;
		if ((page) && (elements)) {
			elements_count += elements;
			var i = 0;
			while (i < length page) {
				var val = page[i];
				if (i % NODE_LOGICAL_ELEMENTS == 0) {
					if (val)
						elements_count += _WarmOSCache(val);
					else
						break;
				} else {
					if ((idx >= elements) && (page[1]))
						break;

					if (i % NODE_LOGICAL_ELEMENTS == NODE_RIGHT_OFFSET)
						idx++;
				}
				i++;
			}
		}	
		return elements_count;
	}

	WarmOSCache() {
		return _WarmOSCache();
	}

	protected GetElements(filter_func, filter_param, var res, desc, offset = 0, var limit = -1, var start = -1, var pos = 0, additional_filter = null) {
		if (!offset)
			GoToRoot(-1, offset);
		else {
			//if (!f.Seek(offset))
			if (fseek(f_handle, offset, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member;
		}
		var page = ReadPage(var elements);
		var ReverseKeyVal = this.ReverseKeyVal;
		if ((page) && (elements > 0)) {
			var validated = QUERY_ELEMENT_ALL;
			if (desc) {
				var i = elements * NODE_LOGICAL_ELEMENTS;
				if ((filter_func) && (page[i])) {
					var temp_pos = i - NODE_LOGICAL_ELEMENTS;
					validated = filter_func(page[++temp_pos], page[temp_pos + NODE_VAL_OFFSET], filter_param);
					if (!validated)
						return res;

					if ((validated & QUERY_ELEMENT_NEXT) == 0) {
						if (validated & QUERY_ELEMENT_PREV)
							i -= NODE_LOGICAL_ELEMENTS;
						else
							return res;
					}
				}

				var prec_validated = -1;
				while (i >= 0) {
					var val = page[i];
					if (i % NODE_LOGICAL_ELEMENTS == 0) {
						if (val) {
							if ((filter_func) && (i > NODE_LOGICAL_ELEMENTS)) {
								var prec_key = page[i - NODE_LOGICAL_ELEMENTS + 1];
								var prec_val = page[i - NODE_LOGICAL_ELEMENTS + NODE_VAL_OFFSET+ 1];
								prec_validated = filter_func(prec_key, prec_val, filter_param);
								if (prec_validated & QUERY_ELEMENT_NEXT)
									GetElements(filter_func, filter_param, res, desc, val, limit, start, pos, additional_filter);
							} else
								GetElements(filter_func, filter_param, res, desc, val, limit, start, pos, additional_filter);
							if ((limit > 0) && (length res >= limit))
								return res;
						}
					} else {
						var key = page[--i];
						if (prec_validated != -1) {
							validated = prec_validated;
							prec_validated = -1;
						} else
						if (filter_func)
							validated = filter_func(key, val, filter_param);

						if ((validated & QUERY_ELEMENT_VALID) && (pos >= start)) {
							if (ReverseKeyVal)
								res[length res] = key;
							else {
								if (val < 0) {
									var limit2 = -1;
									if (limit > 0) {
										limit2 = limit - length res;
										if (limit2 <= 0)
											return res;
									}
									var start2 = start;
									if (start2 < 0)
										start2 = 0;
									var res2 = this.GetValues(-val, start2, limit2, additional_filter, filter_param);
									res += res2;
								} else
									res[length res] = val;
							}

							if ((limit > 0) && (length res >= limit))
								return res;
						}
						if ((filter_func) && ((validated & QUERY_ELEMENT_PREV) == 0))
							return res;

						if (i % NODE_LOGICAL_ELEMENTS == NODE_VAL_OFFSET)
							pos++;
					}
					i--;
				}
			} else {
				i = 0;
				var idx = 0;
				if ((filter_func) && (page[i])) {
					validated = filter_func(page[i + 1], page[i + NODE_VAL_OFFSET + 1], filter_param);
					if (!validated)
						return res;

					if ((validated & QUERY_ELEMENT_PREV) == 0) {
						if (validated & QUERY_ELEMENT_NEXT)
							i += NODE_LOGICAL_ELEMENTS;
						else
							return res;
					}
				}
				prec_validated = -1;
				var page_limit = elements * NODE_LOGICAL_ELEMENTS + 1;
				while (i < page_limit) {
					val = page[i];
					if (i % NODE_LOGICAL_ELEMENTS == 0) {
						if (val) {
							if ((filter_func) && (idx < elements - 1)) {
								var next_key = page[i + 1];
								var next_val = page[i + NODE_VAL_OFFSET+ 1];

								prec_validated = filter_func(next_key, next_val, filter_param);
								if (prec_validated & QUERY_ELEMENT_PREV)
									GetElements(filter_func, filter_param, res, desc, val, limit, start, pos, additional_filter);
							} else
								GetElements(filter_func, filter_param, res, desc, val, limit, start, pos, additional_filter);
							if ((limit > 0) && (length res >= limit))
								return res;
						}
					} else {
						if ((idx >= elements) && (page[1]))
							break;

						var val2 = page[++i];
						if (prec_validated != -1) {
							validated = prec_validated;
							prec_validated = -1;
						} else
						if (filter_func)
							validated = filter_func(val, val2, filter_param);

						if ((validated & QUERY_ELEMENT_VALID) && (pos >= start)) {
							if (ReverseKeyVal)
								res[length res] = val;
							else {
								if (val2 < 0) {
									limit2 = -1;
									if (limit > 0) {
										limit2 = limit - length res;
										if (limit2 <= 0)
											return res;
									}
									start2 = start;
									if (start2 < 0)
										start2 = 0;
									res2 = this.GetValues(-val2, start2, limit2, additional_filter, filter_param);
									res += res2;
								} else
									res[length res] = val2;
							}
							if ((limit > 0) && (length res >= limit))
								return res;
						}

						if ((filter_func) && ((validated & QUERY_ELEMENT_NEXT) == 0))
							return res;

						if (i % NODE_LOGICAL_ELEMENTS == NODE_RIGHT_OFFSET) {
							idx++;
							pos++;
						}
					}
					i++;
				}
			}
		}
		return res;
	}

	Query(filter_func = null, filter_param = null, desc = false, limit = -1, start = -1, additional_filter = null, subtree = 0) {
		var[] res;
		var pos = 0;
		if (limit == 0)
			return res;
		GetElements(filter_func, filter_param, res, desc, subtree, limit, start, pos, additional_filter);
		return res;
	}

	protected Find(val, var found, start = 0, limit = 1, extra_validation = null, user_data = null) {
		var page = ReadPage(var elements);
		if ((page) && (elements > 0)) {
			var compare = this.compare;
			var pos = int32(elements/2);
			var delta = elements - pos;
			while (true) {
				if ((pos < 0) || (pos >= elements))
					return null;
				var i = pos * NODE_LOGICAL_ELEMENTS + 1;
				var node = page[i];
				var node_val = page[i + NODE_VAL_OFFSET];
				var cmp;
				if (compare)
					cmp = compare(node, node_val, val, -1, this, false);
				else
					STATIC_COMPARE_CODE
				if (!cmp) {
					found = true;
					if ((!ReverseKeyVal) && (node_val < 0))
						return this.GetValues(-node_val, start, limit, extra_validation, user_data);

					if (start > 0)
						return 0;
					return node_val;
				}

				if (delta) {
					var prec_pos = pos;
					if (cmp < 0) {
						pos += delta;
						if (pos >= elements) {
							pos = elements - 1;
							if (prec_pos == pos)
								break;
						}
					} else {
						pos -= delta;
						if (pos < 0) {
							pos = 0;
							if (prec_pos == pos)
								break;
						}
					}
				} else
					break;
				if (delta == 1)
					delta = 0;
				else
					delta = int32(delta/2) + delta % 2;
			}

			i = pos * NODE_LOGICAL_ELEMENTS;

			if (cmp > 0)
				pos = page[i];
			else
				pos = page[i + 3];
			if (pos) {
				//if (!f.Seek(pos))
				if (fseek(f_handle, pos, SEEK_SET))
					throw "B-Tree seek error in " + @class + "." + @member;
				return Find(val, found, start, limit, extra_validation, user_data);
			}
		}
		return null;
	}

	Get(key, var found = false, start = 0, limit = 1, extra_validation = null, user_data = null, subtree = -1) {
		found = false;
		GoToRoot(subtree);
		return Find(key, found, start, limit, extra_validation, user_data);
	}

	operator[](key) {
		return Get(key);
	}

	protected GetSuccessor(offset, var new_key, var new_val, at_right = false, var score = 0) {
		score = 0;
		while (offset) {
			//if (!f.Seek(offset))
			if (fseek(f_handle, offset, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member;
			var page = ReadPage(var elements);
			if ((page) && (elements)) {
				score++;
				var prev_offset = offset;
				if (at_right)
					offset = page[elements * NODE_LOGICAL_ELEMENTS];
				else
					offset = page[0];

				if (!offset) {
					if (at_right) {
						var pos = (elements - 1) * NODE_LOGICAL_ELEMENTS + NODE_VAL_OFFSET;
						new_key = page[pos];
						new_val = page[pos + 1];
					} else {
						new_key = page[NODE_VAL_OFFSET];
						new_val = page[NODE_VAL_OFFSET + 1];
						var limit = elements * NODE_LOGICAL_ELEMENTS + 1;
						for (var i = 0; i < limit; i++)
							page[i] = page[i + NODE_LOGICAL_ELEMENTS];
					}
					this.FullSyncPage(page, elements - 1, prev_offset);
					return true;
				}
			} else
				break;
		}
		return false;
	}

	protected GetBestSuccessor(offset, var new_key, var new_val, at_right = false) {
		var prec_page;
		var prec_elements;
		while (offset) {
			//if (!f.Seek(offset))
			if (fseek(f_handle, offset, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member;
			var page = ReadPage(var elements);
			if ((page) && (elements)) {
				prec_page = page;
				prec_elements = elements;

				if (at_right)
					offset = page[elements * NODE_LOGICAL_ELEMENTS];
				else
					offset = page[0];

				if (!offset)
					break;
			} else
				break;
		}
		if (prec_page) {
			page = prec_page;
			elements = prec_elements;

			if (at_right) {
				var pos = (elements - 1) * NODE_LOGICAL_ELEMENTS + NODE_VAL_OFFSET;
				new_key = page[pos];
				new_val = page[pos + 1];
			} else {
				new_key = page[NODE_VAL_OFFSET];
				new_val = page[NODE_VAL_OFFSET + 1];
			}
			return true;
		}
		return false;
	}

	protected DeleteFromPage(page, pos, elements, offset = -1) {
		var idx = pos * NODE_LOGICAL_ELEMENTS;
		if (page[idx]) {
			if ((GetSuccessor(page[idx + NODE_LOGICAL_ELEMENTS], var new_key, var new_val, false, var score_right)) ||
				(GetSuccessor(page[idx], new_key, new_val, true, var score_left))) {
				page[++idx] = new_key;
				page[idx + NODE_VAL_OFFSET] = new_val;
				if (offset >= 0)
					this.FullSyncPage(page, elements, offset);
				return true;
			}
			// special case ... empty page at left, empty page at right
			var has_best_value = false;
			if (score_right)
				has_best_value = GetBestSuccessor(page[idx + NODE_LOGICAL_ELEMENTS], new_key, new_val, false);
			else
			if (score_left)
				has_best_value = GetBestSuccessor(page[idx], new_key, new_val, true);
			if (has_best_value) {
				if (this.Delete(new_key)) {
					if (offset >= 0) {
						//if (f.Seek(offset))
						if (fseek(f_handle, offset, SEEK_SET))
							page = ReadPage(elements);
						if (!page)
							throw "B-Tree internal error in delete";
					}
					page[++idx] = new_key;
					page[idx + NODE_VAL_OFFSET] = new_val;
					if (offset >= 0)
						this.FullSyncPage(page, elements, offset);	
				}
				return true;
			}
		}

		var left_page = 0;
		var right_page = 0;

		if (elements > 1) {
			left_page = page[idx];
			var limit = elements * NODE_LOGICAL_ELEMENTS + 1;
			for (var i = idx; i < limit; i++)
				page[i] = page[i + NODE_LOGICAL_ELEMENTS];
			elements--;
		} else {
			left_page = page[0];
			right_page = page[NODE_LOGICAL_ELEMENTS];

			page = new [];
			limit = PAGE_SIZE * NODE_LOGICAL_ELEMENTS + 1;
			for (i = 0; i < limit; i++)
				page[i] = 0;
			elements = 0;
		}
			
		if (offset >= 0) {
			this.FullSyncPage(page, elements, offset);
			if (left_page)
				this.PushGarbage(left_page);

			if (right_page)
				this.PushGarbage(right_page);
		}
		return true;
	}

	protected DeleteByKey2(val, stored_val) {
		var offset = ftell(f_handle);//f.Tell();
		var page = ReadPage(var elements);
		if ((page) && (elements > 0)) {
			var compare = this.compare;
			var pos = int32(elements/2);
			var delta = elements - pos;
			while (true) {
				if ((pos < 0) || (pos >= elements))
					return null;
				var i = pos * NODE_LOGICAL_ELEMENTS + 1;
				var node = page[i];
				var node_val = page[i + NODE_VAL_OFFSET];
				var cmp;

				if (compare)
					cmp = compare(node, node_val, stored_val, val, this, false);
				else
					STATIC_COMPARE_CODE

				if (!cmp) {
					if ((!ReverseKeyVal) && (node_val < 0)) {
						// to do
						// return this.GetValues(-node_val, start, limit, extra_validation, user_data);
					}
					return DeleteFromPage(page, pos, elements, offset);
				}

				if (delta) {
					var prec_pos = pos;
					if (cmp < 0) {
						pos += delta;
						if (pos >= elements) {
							pos = elements - 1;
							if (prec_pos == pos)
								break;
						}
					} else {
						pos -= delta;
						if (pos < 0) {
							pos = 0;
							if (prec_pos == pos)
								break;
						}
					}
				} else
					break;
				if (delta == 1)
					delta = 0;
				else
					delta = int32(delta/2) + delta % 2;
			}

			i = pos * NODE_LOGICAL_ELEMENTS;

			if (cmp > 0)
				pos = page[i];
			else
				pos = page[i + 3];
			if (pos) {
				//if (!f.Seek(pos))
				if (fseek(f_handle, pos, SEEK_SET))
					throw "B-Tree seek error in " + @class + "." + @member;
				return this.DeleteByKey2(val, stored_val);
			}
		}
		return false;
	}

	protected DeleteByKey(val, stored_val = -1) {
		var offset = ftell(f_handle);//f.Tell();
		var page = ReadPage(var elements);
		if ((page) && (elements)) {
			var i = 0;
			var idx = 0;
			var compare = this.compare;
			while (i < length page) {
				if (idx >= elements)
					break;
				var left = page[i];
				var node = page[i + 1];
				var node_val = page[i + NODE_VAL_OFFSET + 1];

				var cmp;
				if (compare)	
					cmp = compare(node, node_val, val, stored_val, this, false);
				else
					STATIC_COMPARE_CODE
				if (!cmp) {
					// node == key
					if (!ReverseKeyVal) {
						if (node_val < 0) {
							if (this.DeleteValue(-node_val, stored_val, offset, idx, node, node_val))
								return true;
						}
					}
					return DeleteFromPage(page, idx, elements, offset);
				}
				if (cmp >= 0) { // node >= key
					if (left) {
						//if (!f.Seek(left))
						if (fseek(f_handle, left, SEEK_SET))
							throw "B-Tree seek error in " + @class + "." + @member;
						return DeleteByKey(val, stored_val);
					}
					return false;
				}

				idx++;
				i += NODE_LOGICAL_ELEMENTS;
			}
			var right = page[i];
			if (right) {
				//if (!f.Seek(right))
				if (fseek(f_handle, right, SEEK_SET))
					throw "B-Tree seek error in " + @class + "." + @member;
				return DeleteByKey(val, stored_val);
			}
		}
		return false;
	}

	Delete(key, val = -1, subtree = -1) {
		GoToRoot(subtree);
		return DeleteByKey2(key, val);
	}

	protected PageAtOffset(offset, var elements = null) {
		f.Seek(offset);
		return ReadPage(elements);
	}

	GetValues(offset, start = 0, limit = -1, extra_validation = null, userdata = null) {
		var[] res;

		while (offset > 0) {
			if (fseek(f_handle, offset, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member + ":" + @line;

			if (fread(var buf, 1, LINKEDLIST_NODE_SIZE, f_handle) != LINKEDLIST_NODE_SIZE)
				throw "B-Tree read error in " + @class + "." + @member + ":" + @line;

			var node = unpack(LINKEDLIST_NODE, buf);
			var val = node[0];
			var key = node[1];

			if ((!extra_validation) || (extra_validation(key, val, userdata, QUERY_INTERVAL, null))) {
				if (start > 0)
					start--;
				else {
					res[length res] = val;
					limit--;
					if (!limit)	
						break;
				}
			}
			offset = node[1];
		}
		return res;
	}

	GetValue(offset) {
		if (offset <= 0)
			return -1;

			
		if (fseek(f_handle, offset, SEEK_SET))
			throw "B-Tree seek error in " + @class + "." + @member + ":" + @line;

		if (fread(var buf, 1, LINKEDLIST_NODE_SIZE, f_handle) != LINKEDLIST_NODE_SIZE)
			throw "B-Tree read error in " + @class + "." + @member + ":" + @line;

		return unpack(LINKEDLIST_NODE, buf)[0];
	}

	CreateSubtree() {
		if (AddPage(var offset) > 0)
			return offset;

		throw "B-Tree error creating sub-tree";
	}

	CreateLinkNode(node_val, next_val = 0) {
		var node = pack(LINKEDLIST_NODE, node_val, next_val);
		if (has_garbage_node_cache) {
			var offset = this.PopGarbageNode();
			if (offset) {
				if (fseek(f_handle, offset, SEEK_SET))
					throw "B-Tree seek error in " + @class + "." + @member;
			}
		}
		if (offset <= 0) {
			if (fseek(f_handle, 0, SEEK_END))
				throw "B-Tree seek error in " + @class + "." + @member;
			offset = f.Tell();
		}
		f.Write(node);
		return offset;
	}

	protected DeleteValue(offset, val, page_offset, index, tree_node, tree_node_val, limit = 1) {
		var prec_offset = -1;
		var elements = 0;
		while (offset > 0) {
			if (fseek(f_handle, offset, SEEK_SET))
				throw "B-Tree seek error in " + @class + "." + @member + ":" + @line;

			if (fread(var buf, 1, LINKEDLIST_NODE_SIZE, f_handle) != LINKEDLIST_NODE_SIZE)
				throw "B-Tree read error in " + @class + "." + @member + ":" + @line;

			var node = unpack(LINKEDLIST_NODE, buf);
			if ((val < 0) || (node[0] == val)) {
				this.DeleteLinkNode(offset);
				if (prec_offset > 0) {
					if (fseek(f_handle, prec_offset + 8, SEEK_SET))
						throw "B-Tree seek error in " + @class + "." + @member;
					f.Write(pack("u64", node[1]));
				} else {
					SyncNode(page_offset, index, tree_node, -node[1]);
				}
				limit--;
				if (!limit) {
					if (node[1])
						elements++;
					break;
				}
			} else {
				elements++;
				prec_offset = offset;
			}
			offset = node[1];
		}
		return elements;
	}

	DeleteLinkNode(offset) {
		if (offset <= 0)
			return false;
		return this.PushGarbageNode(offset);
	}

	DestroySubtree(offset) {
		this.PushGarbage(offset);
	}
}
