import standard.lib.str
import standard.lib.vad

import standard.lang.serialize
import standard.lib.str
import standard.lib.cripto
import standard.lib.vad

include TCPSocket.con

class RemoteGPUClient {
	static stt(host, port, hmac_key, var buffer, codec = 8, lang = "", sample_rate = 8000, timeout = 1000, max_size = 48000) {
		try {
			var client = new TCPSocket();
			client.SetOption(SOL_SOCKET, SO_RCVTIMEO, timeout);
			client.SetOption(SOL_SOCKET, SO_RCVTIMEO, 10000);

			client.ConnectTimeout = timeout * 2;

			if (!client.Connect(host, port)) {
				console.warn(LOG_THIS, "error connecting to $host:$port");
				return "";
			}

			lang = ToLower(lang);
			if (lang == "auto")
				lang = "";

			var[] obj;
			obj["lang"] = lang;
			obj["codec"] = codec;
			obj["buffer"] = buffer;
			obj["sampleRate"] = sample_rate;
			obj["timestamp"] = Date.now();
			hmac_sha256(hmac_key, obj["buffer"] + obj["lang"] + obj["timestamp"], obj["auth"]);

			var buf = BinarizeObject(obj);
			var socket_buffer = pack("U32", length buf) + buf;

			var start = Date.now();
			do {
				var sent = client.Write(socket_buffer);
				if (sent < length socket_buffer)
					socket_buffer = SubStr(socket_buffer, sent);
				else
					break;
				if ((Date.now() - start)  > timeout) {
					console.warn(LOG_THIS, "write timeout to $host:$port");
					client.Close(true);
					return "";
				}
			} while (socket_buffer);

			var arr = unpack("U32", client.Read(4));
			var size = arr[0];

			client.SetOption(SOL_SOCKET, SO_RCVTIMEO, timeout);

			if ((size > 0) && (size <= max_size)) {
				start = Date.now();
				buffer = "";
				while (length buffer < max_size) {
					var data = client.Read(size - length buffer);
					if (!data)
						break;
					buffer += data;
					if ((Date.now() - start)  > timeout)
						break;
				}
				if (!buffer)
					throw "invalid buffer received";
				obj = UnBinarizeObject(buffer);
				if ((!obj) || (typeof obj != "array"))
					throw "invalid buffer";

				client.Close(true);
				return (obj["text"] ?? "");
			}
			console.warn(LOG_THIS, "buffer too big ($size)"); 
		} catch (var exc) {
			console.warn(LOG_THIS, exc);
		}
		client.Close(true);
		return "";
	}
}

class RemoteGPUStream {
	protected var audio_buffer = "";
	protected var last_vad_ms = 0;

	public var BufferTimeout = 8000;
	public var MinBufferSize = 2000;

	var modelSampleRate = 16000;
	var _frame_size;
	var _frame_size_ms = 20;

	var decodedText = "";

	var host = "";
	var port = 0;
	var key = "";
	var codec = 8;
	var lang = "";

	var _handle = true;

	RemoteGPUStream(host, port, key, lang, codec = 8, modelSampleRate = 16000) {
		this.modelSampleRate = modelSampleRate;
		_frame_size = _frame_size_ms * modelSampleRate / 1000 * 2;

		this.key = key;
		this.host = host;
		this.port = port;
		this.lang = lang;
		this.codec = codec;
	}


	feed(var full_buffer, before_decode_callback = null, before_decode_callback_data = null) {
		audio_buffer += full_buffer;

		var buf_size_ms = length audio_buffer / (modelSampleRate * 2) * 1000;
		if ((audio_buffer) && ((buf_size_ms - last_vad_ms) >= MinBufferSize)) {
			var no_voice = 0;

			var vad = fvad_new();
			fvad_set_sample_rate(vad, modelSampleRate);

			var voice_frames = 0;
			var max_voice_frames = 0;
			for (var i = 0; i < length audio_buffer; i += _frame_size) {
				if (fvad_process(vad, SubStr(audio_buffer, i, _frame_size))) {
					voice_frames ++;
					no_voice = 0;
					if (voice_frames > max_voice_frames)
						max_voice_frames = voice_frames;
				} else {
					no_voice ++;
					voice_frames = 0;
				}
			}

			fvad_free(vad);

			if (((no_voice >= 50) || (buf_size_ms > BufferTimeout)) && (max_voice_frames >= 10)) {
				if (before_decode_callback)
					before_decode_callback(before_decode_callback_data);
				var text = RemoteGPUClient::stt(this.host, this.port, this.key, audio_buffer, this.codec, this.lang, this.modelSampleRate);
				if (!text)
					text = "_____";
				if (text) {
					if (decodedText)
						decodedText += " ";
					decodedText += text;
				}

				audio_buffer = "";
				last_vad_ms = 0;
			} else
				last_vad_ms = buf_size_ms;
		}
	}

	decode() {
		return decodedText;
	}

	finish() {
		var text = decodedText;
		audio_buffer = "";
		decodedText = "";
		last_vad_ms = 0;
		return text;
	}

	reset() {
		this.finish();
	}

	close() {
		audio_buffer = "";
		last_vad_ms = 0;
		decodedText = "";
	}
}
