import standard.lang.serialize
import standard.lib.str
import standard.lib.cripto
import standard.lib.vad

include TCPSocket.con

class RemoteGPUClient {
	static stt(host, port, hmac_key, var buffer, codec = 8, lang = "", sample_rate = 8000, voice_ms = -1, timeout = 1000, max_size = 48000) {
		try {
			var client = new TCPSocket();
			client.SetOption(SOL_SOCKET, SO_RCVTIMEO, timeout);
			client.SetOption(SOL_SOCKET, SO_RCVTIMEO, 10000);
			client.ConnectTimeout = timeout * 2;

			if (!client.Connect(host, port)) {
				console.warn(LOG_THIS, "error connecting to $host:$port");
				return "";
			}

			lang = ToLower(lang);
			if (lang == "auto")
				lang = "";

			var[] obj;
			obj["lang"] = lang;
			obj["codec"] = codec;
			obj["buffer"] = buffer;
			obj["sampleRate"] = sample_rate;
			if (voice_ms >= 0)
				obj["voice"] = voice_ms;
			obj["timestamp"] = Date.now();
			hmac_sha256(hmac_key, obj["buffer"] + obj["lang"] + obj["timestamp"], obj["auth"]);

			var buf = BinarizeObject(obj);
			var socket_buffer = pack("U32", length buf) + buf;

			var start = Date.now();
			do {
				var sent = client.Write(socket_buffer);
				if (sent < length socket_buffer)
					socket_buffer = SubStr(socket_buffer, sent);
				else
					break;
				if ((Date.now() - start)  > timeout) {
					console.warn(LOG_THIS, "write timeout to $host:$port");
					client.Close(true);
					return "";
				}
			} while (socket_buffer);

			var arr = unpack("U32", client.Read(4));
			var size = arr[0];

			client.SetOption(SOL_SOCKET, SO_RCVTIMEO, timeout);

			if ((size > 0) && (size <= max_size)) {
				start = Date.now();
				buffer = "";
				while (length buffer < max_size) {
					var data = client.Read(size - length buffer);
					if (!data)
						break;
					buffer += data;
					if ((Date.now() - start)  > timeout)
						break;
				}
				if (!buffer)
					throw "invalid buffer received";
				obj = UnBinarizeObject(buffer);
				if ((!obj) || (typeof obj != "array"))
					throw "invalid buffer";

				client.Close(true);
				return (obj["text"] ?? "");
			}
			console.warn(LOG_THIS, "buffer too big ($size)"); 
		} catch (var exc) {
			console.warn(LOG_THIS, exc);
		}
		client.Close(true);
		return "";
	}
}

class RemoteGPUStream {
	protected var audio_buffer = "";
	protected var last_vad_ms = 0;
	protected var vadInterval = 0;
	var pause_until = 0;

	public var BufferTimeout = 8000;
	public var MinBufferSize = 2000;

	var modelSampleRate = 16000;
	var _frame_size;
	var _frame_size_ms = 20;

	var decodedText = "";

	var host = "";
	var port = 0;
	var key = "";
	var codec = 8;
	var lang = "";

	var _handle = true;

	RemoteGPUStream(host, port, key, lang, codec = 8, modelSampleRate = 16000) {
		this.modelSampleRate = modelSampleRate;
		_frame_size = _frame_size_ms * modelSampleRate / 1000 * 2;

		this.key = key;
		this.host = host;
		this.port = port;
		this.lang = lang;
		this.codec = codec;
	}

	feed(var full_buffer, before_decode_callback = null, before_decode_callback_data = null) {
		audio_buffer += full_buffer;

		if (pause_until) {
			if (pause_until > Date.now())
				return;
			pause_until = 0;
		}

		var buf_size_ms = length audio_buffer / (modelSampleRate * 2) * 1000;
		if (!vadInterval)
			vadInterval = MinBufferSize;
		if ((audio_buffer) && ((buf_size_ms - last_vad_ms) >= vadInterval)) {
			var no_voice = 0;

			var vad = fvad_new();
			fvad_set_mode(vad, 0);
			fvad_set_sample_rate(vad, modelSampleRate);

			var voice_frames = 0;
			var max_voice_frames = 0;
			var voice_ms = 0;
			var voice_started = false;
			var max_no_voice = 0;
			for (var i = 0; i < length audio_buffer; i += _frame_size) {
				if (fvad_process(vad, SubStr(audio_buffer, i, _frame_size))) {
					voice_frames ++;
					if (no_voice > max_no_voice)
						max_no_voice = no_voice;
					no_voice = 0;
					voice_ms += _frame_size_ms;
					if (voice_frames > max_voice_frames)
						max_voice_frames = voice_frames;
					voice_started = 1;
				} else {
					if (voice_started)
						no_voice ++;
					voice_frames = 0;
				}
			}
			fvad_free(vad);

			if ((no_voice > 25) && (no_voice < 50) && (max_no_voice > 50) && (max_voice_frames >= 50))
				no_voice = 50;

			if (((no_voice >= 50) || (buf_size_ms > BufferTimeout)) && (max_voice_frames >= 10)) {
				if (before_decode_callback)
					before_decode_callback(before_decode_callback_data);
				var text = RemoteGPUClient::stt(this.host, this.port, this.key, audio_buffer, this.codec, this.lang, this.modelSampleRate, voice_ms);
				if (!text)
					text = "_____";
				if (text) {
					if (decodedText)
						decodedText += " ";
					decodedText += text;
				}

				audio_buffer = "";
				last_vad_ms = 0;
				vadInterval = MinBufferSize;
			} else {
				last_vad_ms = buf_size_ms;
				vadInterval = 500;
			}
		}
	}

	pause(ms) {
		if (ms > 0)
			pause_until = Date.now() + ms;
		else
			pause_until = 0;
	}

	decode() {
		return decodedText;
	}

	finish() {
		var text = decodedText;
		audio_buffer = "";
		decodedText = "";
		last_vad_ms = 0;
		pause_until = 0;
		vadInterval = 0;
		return text;
	}

	reset() {
		this.finish();
	}

	close() {
		pause_until = 0;
		audio_buffer = "";
		last_vad_ms = 0;
		decodedText = "";
	}
}
