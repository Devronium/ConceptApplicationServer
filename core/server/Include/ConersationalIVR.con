import standard.lib.samplerate
import standard.lib.json

include IVR.con
include STT.con
include Worker.con

define STT_RESET	0
define STT_ADDBUFFER	1
define STT_TEXT		2
define STT_SCORER	3
define STT_TIMEDOUT	4

class IVRClientData {
	var count;
	var ivr_branch;
	var path;
	var hash;
	var ivr_path = "";
	var api;
	var UserData;
	var redirect = "";
	var finish_api = "";
	var answered = false;
	var timestamp;

	IVRClientData(ivr, ivr_tree, session) {
		this.ivr_branch = ivr_tree;
		this.hash = Murmur(session.sip.CallID);
		this.timestamp = microseconds();
		if (((ivr.OnAPI) || (ivr.OnEvent)) && (typeof ivr_tree == "array")) {
			if (ivr.OnAPI) {
				var k = GetKeys(ivr_tree)[0];
				if (k) {
					if (Pos(k, "\$api") == 1) {
						this.finish_api = trim(SubStr(k, 4));
						ivr.OnAPI(session, session.ClientData.ivr_path, this.finish_api, "open");
					}
				}
			}
			if (ivr.OnEvent)
				ivr.OnEvent(session, session.ClientData.ivr_path, "open");
		}
		if (ivr_tree) {
			var key = GetKeys(ivr_tree)[0];
			if ((key) && (Pos(k, "\$redirect") == 1)) {
				this.redirect = key;
				this.ivr_branch = null;
			}
		}
		// session.sip.NATMode = true;

		// if (session.sip.is_invite)
			session.sip.Record = true;
	}

	callDuration() {
		return floor((microseconds() - this.timestamp) / 1000);
	}
}

class STTWorkerData {
	var id;
	var type;
	var buffer;

	STTWorkerData(id, op_type, var buffer = "") {
		this.id = id;
		this.type = op_type;
		this.buffer = buffer;
	}
}

class STTWorkerObject {
	var id;
	var stream;
	var timestamp;
	var buffer_timestamp;
	var last_str = "";
	var send_timestamp;
	var text_timestamp;

	STTWorkerObject(id) {
		this.id = id;
		this.ping();
		this.reset();
		this.resetText();
	}

	ping() {
		this.timestamp = microseconds();
	}

	reset() {
		buffer_timestamp = microseconds();
		if (stream) {
			stream.close();
			delete stream;
		}
		last_str = "";
	}

	resetText() {
		this.text_timestamp = microseconds();
	}

	textAge() {
		return (microseconds() - this.text_timestamp) / 1000;
	}

	age() {
		return (microseconds() - this.buffer_timestamp) / 1000;
	}

	expired(max_timeout_ms) {
		max_timeout_ms *= 1000;

		if ((this.timestamp) && (microseconds() - this.timestamp > max_timeout_ms)) {
			if ((this.stream) && (this.stream._handle))
				this.stream.close();
			delete this.stream;
			return true;
		}
		return false;
	}

	canSend() {
		if (!send_timestamp)
			send_timestamp = microseconds();

		if (microseconds() - send_timestamp >= 500000) {
			send_timestamp = microseconds();
			return true;
		}

		return false;
	}

	finalize() {
		delete this.stream;
	}
}

class STTWorker {
	STTWorker(model_scorer) {
		console.log(LOG_THIS, "created worker for $model_scorer");

		var arr = StrSplit(model_scorer, ":");
		var stt = new STT(arr[0]);
		var scorer = arr[1] ?? "";
		var scorer_timestamp;
		if (scorer)
			scorer = "./scorers/$scorer";		
		scorer_timestamp = _filelast_mod(scorer);
		if (FileExists(scorer)) {
			try {
				stt.externalScorer = scorer;
			} catch (var scorer_exc) {
				console.error(LOG_THIS, scorer_exc);
			}
		}
		var max_response_length = value (arr[2]) ?? 48;

		var modelSampleRate = stt.modelSampleRate;
		var[] objects;

		var clear_time_stamp = microseconds();
		while (true) {
			if (Worker::Pending(var buffer, 1000)) {
				var obj = UnBinarizeObject(buffer);
				if (!obj)
					continue;

				try {
					if (obj.type == STT_SCORER) {
						stt.externalScorer = obj.buffer ?? "";
						console.log(LOG_THIS, "new scorer loaded ${obj.buffer}");
						continue;
					}

					var worker_obj;

					if (obj.type == STT_RESET) {
						worker_obj = objects[obj.id];
						if (worker_obj) {
							if ((worker_obj.stream) && (worker_obj.stream._handle))
								worker_obj.stream.close();
							delete worker_obj.stream;
							worker_obj.last_str = "";
						}
						objects[obj.id] = null;
					}
					if (!obj.buffer)
						continue;

					worker_obj = objects[obj.id];
					if (!worker_obj) {
						worker_obj = new STTWorkerObject(obj.id);
						objects[obj.id] = worker_obj;
					}

					if (!worker_obj.stream)
						worker_obj.stream = new STTStream(stt);

					var buf2 = resample(alaw2pcm(obj.buffer), 8000, modelSampleRate);
					worker_obj.stream.feed(buf2);


					if (worker_obj.textAge() >= 250) {
						var str = worker_obj.stream.decode();
						if ((str)  && (worker_obj.canSend())) {
							worker_obj.last_str = str;
							Worker::Result(BinarizeObject(new STTWorkerData(obj.id, STT_TEXT, str)));
							if (length str > max_response_length) {
								console.trace(LOG_THIS, "resetting buffer for ${obj.id}");
								worker_obj.reset();
							}
						}
						worker_obj.resetText();
					}
					if (worker_obj.age() >= 8000) {						
						console.trace(LOG_THIS, "resetting buffer for ${obj.id}");
						worker_obj.reset();
						Worker::Result(BinarizeObject(new STTWorkerData(obj.id, STT_TIMEDOUT, "")));
					}
					worker_obj.ping();
				} catch (var exc) {
					console.warn(LOG_THIS, exc);
				}
			}
			if (microseconds() - clear_time_stamp >= 3000000) {
				var new_obj = new [];
				var cleared = 0;
				for (var i = 0; i < length objects; i ++) {
					var ref_obj = objects[i];
					if ((ref_obj) && (!ref_obj.expired(3000)))
						new_obj[ref_obj.id] = ref_obj;
					else
						cleared ++;
				}
				objects = new_obj;
				clear_time_stamp = microseconds();
				if (cleared)
					console.log(LOG_THIS, "cleared $cleared session(s)");

				if (_filelast_mod(scorer) != scorer_timestamp) {
					try {
						scorer_timestamp = _filelast_mod(scorer);
						stt.externalScorer = scorer;
						console.log(LOG_THIS, "reloaded scorer (changed)");
					} catch (scorer_exc) {
						console.error(LOG_THIS, scorer_exc);
					}
				}
			}
		}
	}
}

class VoiceWorkerData {
	var text;
	var opaque;

	VoiceWorkerData(text, opaque = null) {
		this.text = text;
		this.opaque = opaque;
	}
}

class VoiceWorker {
	static key(text, voice) {
		return sha1("" + voice + "/" + text);
	}

	static exists(text, voice) {
		var fname = VoiceWorker::key(text, voice);
		return FileExists("./repository/alaw/$fname.alaw");
	}

	static ensureAudio(text, voice) {
		var fname = VoiceWorker::key(text, voice);
		if (!voice)
			return fname;

		console.log(LOG_THIS, "preparing $voice/[$text]");
		if (!FileExists("./repository/alaw/$fname.alaw")) {
			TTSHelper::tts(text, voice, "./repository/$fname.wav");
			_unlink("./repository/alaw/$fname.alaw");
			_system("ffmpeg -loglevel error -i \"./repository/$fname.wav\" -ac 1 -ar 8000 -f s8 -acodec pcm_alaw \"./repository/alaw/$fname.alaw\"");
		}
		return fname;
	}

	VoiceWorker(voice) {
		console.info(LOG_THIS, "created worker for $voice");
		while (true) {
			if (Worker::Pending(var buffer, 1000)) {
				var obj = UnBinarizeObject(buffer);
				if (!obj)
					continue;

				if (obj.text) {
					for (var i = 0; i < length obj.text; i ++) {
						var text = obj.text[i];
						if ((text) && (text[0] != "\$"))
							this.ensureAudio(text, voice);
					}
				}
				
				Worker::Result(buffer);
			}
		}
	}
}

class ConversationalIVR {
	var ivr;
	var[] stt_workers;
	var[] voice_workers;

	var trunk_dir = "./trunks/";
	var[] ivr_voice;
	var[] ivr_trees;
	var[] ivr_checksums;
	var[] ivr_timestamps;
	var[] ivr_model_keys;
	var[] ivr_timeout;
	var[] ivr_api_trees;
	var ivr_api_trees_dirty;

	var OnFinish;
	var OnBranch;
	var OnAPI;
	var OnEvent;

	var OnFirewall;

	var LoopCallback;
	var OnReloadConfig;

	var OnWriteRecording;
	var OnRegistered;

	var defaultVoice = "tts_models/en/vctk/vits";
	var[] sipUsers;

	var every_second;
	var reload_config_second;

	protected var _sip_username = "";
	OnRegister(msg, auth, extra_headers) {
		this._sip_username = "";
		console.trace(LOG_THIS, "REGISTER ${msg.ip}:${msg.port}");
		if (auth) {
			var code = ivr.stack.CheckAuth(auth, function(username) {
				if (IsSet(this.sipUsers, username)) {
					_sip_username = username;
					return this.sipUsers[username];
				}
				return "";
			});
			if ((code != 200) && (this.OnFirewall))
				this.OnFirewall(msg);

			if ((code == 200) && (this._sip_username) && (this.OnRegistered)) {
				var msg_server = msg.ip;
				if (msg.port != 5060)
					msg_server += ":" + msg.port;

				this.OnRegistered(_sip_username, msg_server);
			}
			return code;
		}
		return 401;
	}

	static sessionTo(session) {
		if (session.sip.is_invite)
			return session.From;
		return session.To;
	}

	sessionTree(session) {
		var callid = session.sip.CallID;
		var ivr_tree;
		if (IsSet(ivr_api_trees, callid))
			ivr_tree = ivr_api_trees[callid];
		if (!ivr_tree)
			ivr_tree = ivr_trees[sessionTo(session)];
		return ivr_tree;
	}

	DoTTS(text, voice = "", session = null, append = false) {
		var fname = VoiceWorker::key(text, voice);
		if (session) {
			if (!session.ClientData)
				session.ClientData = new IVRClientData(this, sessionTree(session), session);
			else
				session.ClientData.count = 0;
			if (append)
				session.Append(fname);
			else
				session.Load(fname);
		}

		return fname;
	}

	DoTTSAsync(text, voice = "", session = null, append = false) {
		var worker = this.voiceWorker(voice);
		if (!worker)
			return "";

		if (VoiceWorker::exists(text, voice))
			return DoTTS(text, voice, session, append);

		if (session) {
			var fname = VoiceWorker::key(text, voice ?? this.defaultVoice);
			worker.AddData(BinarizeObject(new VoiceWorkerData([text], [2, session.sip.CallID, fname, append])));
			return fname;
		}
		
		return "";
	}

	voice(to) {
		if (typeof to != "string") {
			if (to.sip.is_invite)
				to = to.From;
			else
				to = to.To;
		}
		if (IsSet(ivr_voice, to))
			return ivr_voice[to];
		return "";
	}

	OnGreeting(from, to, callid) {
		console.info(LOG_THIS, "call from $from to $to");
		var ivr_data;

		var ivr_tree;

		var trunk_path = trunk_dir + to + ".json";
		if (!FileExists(trunk_path)) {
			console.warn(LOG_THIS, "invalid trunk $to ($trunk_path)");
			return null;
		}

		ivr_tree = ivr_trees[to];
		if ((ivr_tree) && (time() - ivr_timestamps[to] >= 8)) {
			ivr_data = ReadFile(trunk_path);
			if (sha256(ivr_data) != ivr_checksums[to]) {
				ivr_tree = this.loadTree(to, JSONDeserialize(ivr_data));
				ivr_checksums[to] = sha256(ivr_data);
				ivr_timestamps[to] = time();
				ivr_trees[to] = ivr_tree;
				console.info(LOG_THIS, "trunk $to reloaded");
			}
		}

		if (!ivr_tree) {
			ivr_data = ReadFile(trunk_path);
			ivr_tree = JSONDeserialize(ivr_data);
			if (ivr_tree) {
				ivr_tree = this.loadTree(to, ivr_tree);
				if (ivr_tree) {
					ivr_checksums[to] = sha256(ivr_data);
					ivr_timestamps[to] = time();
					ivr_trees[to] = ivr_tree;
				}
			}
		}
		
		if (IsSet(ivr_api_trees, callid))
			ivr_tree = ivr_api_trees[callid] ?? ivr_tree;

		if (!ivr_tree) {
			console.warn(LOG_THIS, "invalid trunk $to");
			return null;
		}

		var msg = ivr_tree[0];
		var use_voice = this.voice(to);
		if (!VoiceWorker::exists(msg, use_voice))
			return null;

		return [this.DoTTS(msg, use_voice)];
	}

	OnAnswerGreeting(from, to, callid) {
		return this.OnGreeting(to, from, callid);
	}

	OnBegin(session) {
		if (!session.ClientData)
			session.ClientData = new IVRClientData(this, sessionTree(session), session);
		session.ClientData.answered = true;
	}

	protected chooseWorker(session, hash) {
		if (!session)
			return null;
		var to = session.To;
		if (session.sip.is_invite)
			to = session.From;

		if (!IsSet(this.ivr_model_keys, to))
			return null;

		var key = this.ivr_model_keys[to];
		if (!key)
			return null;

		var workers = stt_workers[key];
		if (!workers)
			return null;

		var len = length workers;
		if (!len)
			return null;
		
		return workers[hash % len];
	}

	OnAudioFrame(session, var buffer, var type) {
		if (!session.ClientData)
			session.ClientData = new IVRClientData(this, sessionTree(session), session);

		if (session.ClientData.count) {
			var stt_worker = this.chooseWorker(session, session.ClientData.hash);
			if (stt_worker)
				stt_worker.AddData(BinarizeObject(new STTWorkerData(session.sip.CallID, STT_ADDBUFFER, buffer)));
			else
				console.error(LOG_THIS, "no workers for ${session.To}, callid ${session.sip.CallID}");
		}
	}

	IVRFinished(session) {
		if ((!session) || (session.EndOnIVRFinished))
			return;

		if (!session.ClientData)
			session.ClientData = new IVRClientData(this, sessionTree(session), session);

		if (session.ClientData.redirect) {
			this.Raspuns(session.sip.CallID, session.ClientData.redirect);
			return;
		}

		var branch = session.ClientData.ivr_branch;
		if ((!branch) || (typeof branch == "string") || (length branch == 1)) {
			session.Close();
			return;
		}

		console.info(LOG_THIS, "start STT for ${session.sip.CallID}");
		session.ClientData.count = 1;

		var stt_worker = this.chooseWorker(session, session.ClientData.hash);
		if (stt_worker)
			stt_worker.AddData(BinarizeObject(new STTWorkerData(session.sip.CallID, STT_RESET)));
		else
			console.error(LOG_THIS, "no workers for ${session.To}, callid ${session.sip.CallID}");
	}

	protected writeRecording(session) {
		if (!session.sip.RecordBuffers)
			return;
		var keys = GetKeys(session.sip.RecordBuffers);
		if (keys) {
			var min_len = 0;
			for (var i = 0; i < length session.sip.RecordBuffers; i++) {
				var buf = session.sip.RecordBuffers[i];
				if (buf) {
					if ((!min_len) || (min_len > length buf))
						min_len = length buf;
				}
			}
			var folder = session.To;
			if (session.sip.is_invite)
				folder = session.From;
			_mkdir("rec/$folder");
			var path = "rec/$folder/" + time() + "-" + session.From + "-" + session.To + ".alaw";
			var params = "";
			var filter = "";
			var index = 0;
			for (i = 0; i < length keys; i++) {
				var k = keys[i];
				if (k) {
					buf = session.sip.RecordBuffers[k];
					if (buf) {
						var fname = path + ".$i.alaw";
						if ((min_len > 0) && (length buf != min_len))
							WriteFile(SubStr(buf, length buf - min_len), fname);
						else
							WriteFile(buf, fname);
				
						params += "-f alaw -ar 8000 -ac 1 -acodec pcm_alaw -i \"$fname\" ";
						filter += "[$index:a]";
						index++;
					}
				}
			}
			var output_file = path + ".mp3";
			_unlink(output_file);
			_system("ffmpeg -loglevel fatal $params-filter_complex \"${filter}amix\" -ac 1 -qscale:a 2 \"$output_file\" &");
			session.StopRecording();
			session.sip.RecordBuffers = null;
			if (this.OnWriteRecording)
				this.OnWriteRecording(session, output_file);
		}
	}

	OnEnd(session, callid, code) {
		if (IsSet(ivr_api_trees, callid)) {
			ivr_api_trees[callid] = null;
			ivr_api_trees_dirty ++;
			if (ivr_api_trees_dirty >= 8) {
				var keys = GetKeys(ivr_api_trees);
				var arr = new [];
				for (var i = 0; i < length keys; i ++) {
					var k = keys[i];
					if (k) {
						var tree = ivr_api_trees[k];
						if (tree)
							arr[k] = tree;
					}
				}
				ivr_api_trees = arr;
				console.log("cleared ${ivr_api_trees_dirty} placeholders");
				ivr_api_trees_dirty = 0;
			}
		}
		console.log(LOG_THIS, "call id ${callid} ended with code $code");
		if ((session) && (session.ClientData) && (session.ClientData.finish_api) && (this.OnAPI)) {
			this.OnAPI(session, session.ClientData.ivr_path, session.ClientData.finish_api, "close");
			session.ClientData.finish_api = "";
		}
		if ((session) && (session.ClientData) && (this.OnEvent))
			this.OnEvent(session, session.ClientData.ivr_path, "close");
		if (session)
			this.writeRecording(session);
	}

	static getId(session) {
		if (!session)
			return 0;
		return session.sip.CallID;
	}

	sessionById(id) {
		return this.ivr.GetSessionById(id);
	}

	api(id_session, message, tree = null) {
		if (typeof id_session == "string")
			id_session = this.ivr.GetSessionById(id_session);
		if (!id_session) {
			console.warn("session does not exists anymore");
			return false;
		}

		if ((!id_session.ClientData) || (!id_session.ClientData.api)) {
			console.warn("session is not in async api state");
			return false;
		}

		if ((id_session.ClientData.api == 2) && (!tree)) {
			id_session.EndOnIVRFinished = true;
			if (!message)
				id_session.Close();
		}

		id_session.ClientData.api = false;

		if (message)
			this.checkMessage(id_session.sip.CallID, message);

		if (tree)
			id_session.ClientData.ivr_branch = tree;

		return true;
	}

	Raspuns(id, text, append = false) {
		console.log(LOG_THIS, "[$text]");
		var session = this.ivr.GetSessionById(id);
		if (!session) {
			console.warn(LOG_THIS, "session $id does not exists");
			return;
		}

		if (text[0] == "\$") {
			if ((this.OnAPI) && (Pos(text, "\$api") == 1)) {
				session.ClientData.api = true;
				var message = this.OnAPI(session, session.ClientData.ivr_path, trim(SubStr(text, 4)), "tree");
				session.ClientData.count = 0;
				if (message) {
					this.checkMessage(id, message);
					session.ClientData.api = false;
				} else {
					// async call
					session.EndOnIVRFinished = false;
				}
				return;
			} else
			if (Pos(text, "\$redirect") == 1) {
				this.refer(session, trim(SubStr(text, 9)));
				session.ClientData.count = 0;
				session.EndOnIVRFinished = false;
				if (this.OnEvent)
					this.OnEvent(session, session.ClientData.ivr_path, "redirect");
				return;
			}
		}


		DoTTSAsync(text, this.voice(session), session, append);

		var stt_worker = this.chooseWorker(session, session.ClientData.hash);
		if (stt_worker)
			stt_worker.AddData(BinarizeObject(new STTWorkerData(id, STT_RESET)));
		else
			console.error(LOG_THIS, "no workers for ${session.To}, callid ${session.sip.CallID}");
	}

	OnIdle() {
		try {
			for (var i = 0; i < length stt_workers; i ++) {
				var arr = stt_workers[i];
				for (var j = 0; j < length arr; j ++)
					this.OnIdle_worker(arr[j]);
			}
			for (i = 0; i < length voice_workers; i ++)
				this.OnIdle_voiceWorker(voice_workers[i]);

			if (microseconds() - every_second >= 1000000) {
				this.ivr.stack.Reregister();
				this.every_second = microseconds();
			}
			if (this.OnReloadConfig) {
				if (time() - reload_config_second >= 30) {
					this.OnReloadConfig(this);
					this.reload_config_second = time();
				}
			}
			if (this.LoopCallback)
				this.LoopCallback();
		} catch (var exc) {
			console.error(LOG_THIS, exc);
		}
	}

	checkMessage(id, message, var append = false) {
		if (message) {
			if (typeof message == "array") {
				for (var i = 0; i < length message; i ++)
					Raspuns(id, message[i], append);
			} else
				Raspuns(id, message, append);
			append = true;
		}
	}

	TextEvent(session, text, id) {
		console.log(LOG_THIS, "text (id: ${id}): " + text);
		if (!session.ClientData.ivr_branch) {
			console.warn(LOG_THIS, "no branch");
			session.ClientData.count = 0;
			session.Close();
			return;
		}

		var keys = GetKeys(session.ClientData.ivr_branch);
		if (!keys) {
			console.warn(LOG_THIS, "no keys");
			return;
		}
				
		var message_understood = false;
		var append = false;
		for (var j = 0; j < length keys; j ++) {
			var k2 = keys[j];
			if (!k2)
				continue;
			if ((k2[0] == "/") && (k2[length k2 - 1] == "/")) {
				var regexp = new RegExp(SubStr(k2, 1, length k2 - 2));
				if (regexp.test(text))
					message_understood = true;
			} else {
				k2 = StrReplace(k2, ",", "|");
				k2 = StrReplace(k2, ".", "|");
				k2 = StrReplace(k2, ";", "|");
				k2 = StrReplace(k2, ":", "|");
				var arr = StrSplit(k2, "|");
				for (var jj = 0; jj < length arr; jj ++) {
					var k = arr[jj];
					if ((k) && (Pos(text, k) > 0)) {
						message_understood = true;
						break;
					}
				}
			}
			if (message_understood) {
				session.ClientData.ivr_path += "/" + k2;
				session.ClientData.ivr_branch = session.ClientData.ivr_branch[k2];

				try {
					if (this.OnBranch)
						this.checkMessage(id, this.OnBranch(session, session.ClientData.ivr_path), append);
				} catch (var exc) {
					console.error(LOG_THIS, exc);
				}

				if (session.ClientData.ivr_branch) {
					if (typeof session.ClientData.ivr_branch == "string") {
						try {
							if ((this.OnAPI) && (session.ClientData.finish_api)) {
								this.OnAPI(session, session.ClientData.ivr_path, session.ClientData.finish_api, "close");
								session.ClientData.finish_api = "";
							}
							if (this.OnFinish)
								this.checkMessage(id, this.OnFinish(session, session.ClientData.ivr_path), append);
						} catch (exc) {
							console.error(LOG_THIS, exc);
						}
						Raspuns(id, session.ClientData.ivr_branch, append);
						session.ClientData.ivr_branch = null;
						if (session.ClientData.api)
							session.ClientData.api = 2;
						else
							session.EndOnIVRFinished = true;
					} else
					if (session.ClientData.ivr_branch[0]) {
						Raspuns(id, session.ClientData.ivr_branch[0], append);
						if (length session.ClientData.ivr_branch == 1) {
							try {
								if ((this.OnAPI) && (session.ClientData.finish_api)) {
									this.OnAPI(session, session.ClientData.ivr_path, session.ClientData.finish_api, "close");
									session.ClientData.finish_api = "";
								}

								if ((this.OnFinish) && (!session.ClientData.api))
									this.checkMessage(id, this.OnFinish(session, session.ClientData.ivr_path), append);
							} catch (exc) {
								console.error(LOG_THIS, exc);
							}
							var key = GetKeys(session.ClientData.ivr_branch)[0];
							if ((key) && (key[0] == "\$"))
								session.ClientData.redirect = key;
							session.ClientData.ivr_branch = null;
							if (session.ClientData.api)
								session.ClientData.api = 2;
							else
							if (!session.ClientData.redirect)
								session.EndOnIVRFinished = true;
						}
					} else {
						try {
							if ((this.OnAPI) && (session.ClientData.finish_api)) {
								this.OnAPI(session, session.ClientData.ivr_path, session.ClientData.finish_api, "close");
								session.ClientData.finish_api = "";
							}

							if (this.OnFinish)
								this.checkMessage(id, this.OnFinish(session, session.ClientData.ivr_path), append);
						} catch (exc) {
							console.error(LOG_THIS, exc);
						}
						session.Close();
					}
				} else {
					try {
						if ((this.OnAPI) && (session.ClientData.finish_api)) {
							this.OnAPI(session, session.ClientData.ivr_path, session.ClientData.finish_api, "close");
							session.ClientData.finish_api = "";
						}

						if (this.OnFinish)
							this.checkMessage(id, this.OnFinish(session, session.ClientData.ivr_path), append);
					} catch (exc) {
						console.error(LOG_THIS, exc);
					}
					session.Close();
				}
				break;
			}
		}
	}

	OnIdle_worker(stt_worker) {
		stt_worker.GetAll(var data, 0, 100);
		if (data) {
			var[] ids;
			for (var i = length data - 1; i >= 0; i --) {
				var obj = UnBinarizeObject(data[i]);
				if ((!obj) || (ids[obj.id]))
					continue;

				ids[obj.id] = true;

				var session = ivr.GetSessionById(obj.id);
				if (!session) {
					console.warn(LOG_THIS, "invalid session id ${obj.id}");
					continue;
				}

				var text = obj.buffer;

				if (obj.type == STT_TIMEDOUT) {
					console.log(LOG_THIS, "session ${obj.id} stt timed out");
					if ((typeof session.ClientData.ivr_branch == "array") && (IsSet(session.ClientData.ivr_branch, "\$timeout"))) {
						text = "\$timeout";
					} else {
						if (IsSet(ivr_timeout, session.To))
							Raspuns(obj.id, ivr_timeout[session.To]);
						continue;
					}
				}
				this.TextEvent(session, text, obj.id);
			}

		}
	}

	protected voiceWorker(use_voice) {
		if (!use_voice)
			use_voice = this.defaultVoice;

		if (!use_voice)
			return null;

		var worker = voice_workers[use_voice];
		if (worker)
			return worker;

		worker = new Worker("VoiceWorker", use_voice);
		voice_workers[use_voice] = worker;

		return worker;
	}

	protected loadTree(to, ivr_tree, prev = null, var texts = null) {
		var voice = "";
		if ((!prev) && (ivr_tree)) {
			var config = ivr_tree["config"];
			if (!config) {
				console.error(LOG_THIS, "\"config\" field missing");
				return null;
			}
			ivr_tree = ivr_tree["tree"];
			if (ivr_tree) {
				this.addWorker(to, config["model"], config["scorer"], value config["workers"]);
				voice = config["voice"];
				if (voice)
					ivr_voice[to] = voice;
			} else
				console.error(LOG_THIS, "\"tree\" field missing");
			var ivr_timeout_message = config["timeout"];
			if ((ivr_timeout_message) && (typeof ivr_timeout_message == "string"))
				ivr_timeout[to] = ivr_timeout_message;
		}

		if (!ivr_tree)
			return ivr_tree;

		if (!prev)
			prev = new [];

		var first_call = false;
		if (!texts) {
			texts = new [];
			first_call = true;
		}

		var use_voice = this.voice(to);
		var keys = GetKeys(ivr_tree);
		for (var i = 0; i < length ivr_tree; i ++) {
			var branch = ivr_tree[i];
			switch (typeof branch) {
				case "array":
					if (prev)
						loadTree(to, branch, [ivr_tree] + prev, texts);
					else
						loadTree(to, branch, [ivr_tree], texts);
					break;
				case "string":
					if (branch[0] == "\$") {
						var arr = StrSplit(StrReplace(branch, "\t", " "), " ");
						switch (branch) {
							case "\$up":
							case "\$up1":
								if ((prev) && (prev[0]) && (keys[i]))
									ivr_tree[keys[i]] = prev[0];
								else
									console.warn(LOG_THIS, "invalid branch to go up");
								break;
							case "\$up2":
								if ((prev) && (length prev > 1) && (keys[i]))
									ivr_tree[keys[i]] = prev[1];
								else
									console.warn(LOG_THIS, "invalid branch to go up");
								break;
							case "\$include":
								if (arr[1]) {
									var trunk_path = trunk_dir + arr[1] + ".json";
									ivr_tree[keys[i]] = this.loadTree(to, JSONDeserialize(ReadFile(trunk_path)), ivr_tree, texts);
								} else
									console.warn(LOG_THIS, "include parameter missing");
								break;
							case "\$repeat":
								ivr_tree[keys[i]] = ivr_tree;
								break;
						}
					} else
					if ((branch) && (!VoiceWorker::exists(branch, use_voice)))
						texts[length texts] = branch;
					break;
			}
		}

		if ((first_call) && (texts) && (length texts)) {
			var worker = this.voiceWorker(voice);
			if (worker)
				worker.AddData(BinarizeObject(new VoiceWorkerData(texts)));
		}
		return ivr_tree;
	}

	OnClientRegister(registration) {
		console.log(LOG_THIS, "${registration.username}@${registration.server} registered");
	}

	OnResponseMessage(msg) {
		console.log(LOG_THIS, "${msg.ServerCode} for ${msg.Headers["call-id"]} (${msg.Headers["cseq"]}) received ");
	}

	OnDTMF(session, key) {
		if ((!session) || (!session.ClientData))
			return;

		// text event not started yet
		if (!session.ClientData.count)
			return;

		this.TextEvent(session, key, session.sip.CallID);
	}

	OnDTMFRelay(session, key) {
		if ((!session) || (!session.UserData) || (!session.UserData.ClientData))
			return;

		// text event not started yet
		if (!session.UserData.ClientData.count)
			return;

		this.TextEvent(session.UserData, key, session.CallID);
	}

	ConversationalIVR(sip_host, sip_port = 5060, in_band_dtmf = true) {
		ivr = new IVR(sip_host, sip_port, 40);

		if (in_band_dtmf)
			ivr.OnDTMF = this.OnDTMF;

		ivr.GreetingTo = this.OnGreeting;
		ivr.AnswerGreeting = this.OnAnswerGreeting;
		ivr.AudioFrame = this.OnAudioFrame;
		ivr.IVRFinished = this.IVRFinished;
		ivr.SessionFinished = this.OnEnd;
		ivr.Begin = this.OnBegin;

		ivr.stack.OnRegister = this.OnRegister;
		ivr.stack.OnClientRegister = this.OnClientRegister;
		ivr.stack.NATFriendly = true;
		ivr.stack.OnResponse = this.OnResponseMessage;

		ivr.stack.OnDTMFRelay = this.OnDTMFRelay;


		ivr.LoopCallback = this.OnIdle;
	}

	addWorker(to, model, scorer = "", count = 2) {
		if (!model) {
			console.error("invalid model");
			return;
		}

		var count2 = _floor(sysconf(_SC_NPROCESSORS_ONLN) / 2);
		if (count < count2)
			count = count2; 

		if (!count)
			count = 2;

		if (!scorer) {
			var auto_scorer = StrReplace(model, ".tflite", "");
			if (length auto_scorer > 2) {
				auto_scorer = auto_scorer[length auto_scorer - 2] + auto_scorer[length auto_scorer - 1];
				scorer = "default/$auto_scorer.scorer";
			}
		}
		var key = "$model:$scorer";
		var arr = stt_workers[key];
		if (!arr) {
			arr = new [];
			stt_workers[key] = arr;
		}

		var i;
		for (i = 0; i < length arr; i ++) {
			var stt_worker = arr[i];
			stt_worker.AddData(BinarizeObject(new STTWorkerData("", STT_SCORER, scorer)));
		}

		while (length arr < count)
			arr[length arr] = new Worker("STTWorker", "$model:$scorer");

		this.ivr_model_keys[to] = key;
	}

	addRoute(route, host, port = 5060) {
		this.ivr.stack.AddRoute(route, host, port);
	}

	getVoices(tree, voice, var arr = null) {
		if (!arr)
			arr = new [];

		switch (typeof tree) {
			case "string":
				if ((tree) && (tree[0] != '$') && (!VoiceWorker::exists(tree, voice)))
					arr[length arr] = tree;
				break;
			case "array":
				for (var i = 0; i < length tree; i ++)
					getVoices(tree[i], voice, arr);
				break;
		}
		return arr;
	}

	callSync(who, from, tree = null, max_duration = 1800) {
		var session = this.ivr.stack.Invite(who, from);
		console.log(LOG_THIS, "call $who by $from");
		if (session) {
			session.setExpires(max_duration);
			if (tree) {
				if (typeof tree == "string")
					tree = [tree];
				ivr_api_trees[session.CallID] = tree;
			}
			return session.CallID;
		}
		console.warn(LOG_THIS, "cannot call $who");
		return false;
	}

	callSyncAll(who, from, tree = null, max_duration = 1800) {
		var gateway_arr = StrSplit(who, "@");
		var gateway = "";
		if (length gateway_arr == 2) {
			who = gateway_arr[0];
			gateway = "@" + gateway_arr[1];
		}
		var arr = StrSplit(who, ",");
		var idx = 0;
		for (var i = 0; i < length arr; i ++) {
			var phone = trim(arr[i]);
			if (phone) {
				if (this.callSync(phone + gateway, from, tree, max_duration))
					idx ++;
			}
		}
		return idx;
	}

	OnIdle_voiceWorker(worker) {
		worker.GetAll(var data, 0, 100);
		if (data) {
			for (var i = 0; i < length data; i ++) {
				var obj = UnBinarizeObject(data[i]);
				if ((!obj) || (!obj.opaque))
					continue;

				switch (obj.opaque[0]) {
					case 1:
						this.callSyncAll(obj.opaque[1], obj.opaque[2], obj.opaque[3], obj.opaque[4]);
						break;
					case 2:
						var session = this.ivr.GetSessionById(obj.opaque[1]);
						var fname = obj.opaque[2];
						if ((session) && (fname)) {
							if (obj.opaque[3])
								session.Append(fname);
							else
								session.Load(fname);
						}
						break;
				}
			}

		}
	}

	call(who, from, tree = null, max_duration = 1800) {
		var voice = "";
		if (IsSet(ivr_voice, from))
			voice = ivr_voice[from];
		if (!voice)
			voice = this.defaultVoice;

		var texts = this.getVoices(tree, voice);
		if ((!texts) || (length texts == 0))
			return callSyncAll(who, from, tree, max_duration);

		var worker = voiceWorker(voice);
		if (!worker)
			return null;

		return worker.AddData(BinarizeObject(new VoiceWorkerData(texts, [1, who, from, tree, max_duration])));
	}

	register(username, password, sip_server, server_port = 5060) {
		this.every_second = microseconds();
		return this.ivr.stack.Register(username, password, sip_server, server_port);
	}

	refer(session, destination) {
		if (!session) {
			console.warn(LOG_THIS, "cannot refer: invalid session");
			return null;
		}
		var arr = StrSplit(destination, "|");
		if (length arr > 1)
			destination = arr[rand() % (length arr)];

		if ((Pos(destination, "@") <= 0) && (session.sip.msg) && (session.sip.msg.RemoteAddress)) {
			this.ivr.stack.ParseFullDestination(session.sip.msg.RemoteAddress, null, var use_server, var use_port);
			if ((!use_port) || (use_port == 5060))
				use_port = "";
			else
				use_port = ":$use_port";

			if (use_server)
				destination = destination + "@" + use_server + use_port;
		}
		session.Expires = 1800;
		session.sip.setExpires(1800);
		session.sip.ResetBuffers();
		session.StartRecording(session.Expires);
		var refer_session = session.Refer(destination);
		if (refer_session)
			session.sip.setMaxJitter(2);
		return refer_session;
	}

	getSessions(account, identity = "") {
		var[] sess_ids;
		var sessions = this.ivr.stack.Sessions;
		for (var i = 0; i < length sessions; i ++) {
			var session = sessions[i];
			if ((session) && (session.UserData)) {
				if ((!account) || (((session.is_invite) && (session.UserData.From == account)) || ((!session.is_invite) && (session.UserData.To == account)))) {
					var duration = 0;
					var path = "";
					if (session.UserData.ClientData) {
						duration = session.UserData.ClientData.callDuration();
						path = session.UserData.ClientData.ivr_path;
					}
					sess_ids[session.CallID] = ["account" => account ?? identity, "isInvite" => session.is_invite, "from" => session.UserData.From, "to" => session.UserData.To, "callDuration" => duration, "path" => path];
				}
			}
		}
		return sess_ids;
	}

	Start(loop_callback = null) {
		this.LoopCallback = loop_callback;
		this.ivr.stack.OnAnswered = this.ivr.OnAnswered;
		ivr.Start();
	}
}
