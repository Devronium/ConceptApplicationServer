import standard.lang.cli
import standard.lang.serialize
import standard.C.time
import standard.C.io
import standard.lib.cripto
include Loop.con
include Worker.con

class __asynctimer {
	protected var timeout;
	protected var _delegate;
	public var onexception;

	__asynctimer(delegate, timeout) {
		this._delegate = delegate;
		this.timeout = microseconds() + timeout * 1000;
		Loop::add(this.iterate);
	}

	public cancel() {
		_delegate = null;
		timeout = 0;
	}

	protected iterate() {
		if (microseconds() >= timeout) {
			try {
				if (_delegate)
					_delegate();
			} catch (var exc) {
				if (onexception)
					onexception(exc);
			}
			return true;
		}
		return false;
	}
}

class async extends Loop {
	static timeout(delegate, timeout) {
		return new __asynctimer(delegate, timeout);
	}
}

class fs {
	readFile(path, callback) {
		if (callback)
			callback(_errno(), ReadFile(path));
		return true;
	}

	writeFile(path, var data = "", callback = null) {
		var written = WriteFile(data, path);
		if (callback)
			callback(_errno());
		if (written)
			return true;
		return false;
	}
}

class session {
	var sessionid = "";
	var sessionpath;
	var setheader;
	var[] data;

	session() {
		this.sessionpath = _getenv("sessionpath");
		if (!this.sessionpath)
			this.sessionpath = _getenv("tmp");
		if (!this.sessionpath)
			this.sessionpath = _getenv("temp");
		if (!this.sessionpath)
			this.sessionpath = "/tmp";
	}

	operator[](key) {
		if ((data) && (IsSet(data, key)))
			return data[key];
		return null;
	}

	sessionfilename(session_id) {
		return sessionpath + "/" + sessionid + ".ess";
	}

	writesession(sessiondata, session_id) {
		return WriteFile(BinarizeObject(sessiondata), this.sessionfilename(session_id));
	}

	readsession(session_id) {
		var data = ReadFile(this.sessionfilename(session_id));
		if (data)
			return UnBinarizeObject(data);
		return null;
	}

	removesession(session_id) {
		_unlink(this.sessionfilename(session_id));
	}

	syncsession(array sessiondata) {
		if (sessionid) {
			try {
				if (typeof sessiondata == "array") {
					var info = sessiondata["session"];
					if (typeof info == "array") {
						var id = info["id"];	
						if (id == sessionid) {
							if (this.writesession(sessiondata, sessionid))
								return;
						}
					}
				}
			} catch (var exc) {
				echo exc;
			}
			this.removesession(sessionid);
		}
	}

	usesession(expires = 2592000, path = "/", domain = "", secure = false, httponly = true) {
		var sessiondata;
		if (sessionid)
			sessiondata = this.readsession(sessionid);
		if (sessiondata) {
			var info = sessiondata["session"];
			if (info) {
				var is_expired = info["expires"];
				if (time() > is_expired) {
					sessiondata = null;
					this.removesession(sessionid);
				}
			}
		}
		if (!sessiondata) {
			sessionid = sha256(CryptoRandom(80));
			var expires_when = time() + expires;
			sessiondata = ["session" => ["id" => sessionid, "expires" => expires_when, "created" => time()]];
			var cookie = "_ess=${sessionid}; Max-Age=" + expires;
			if (path)
				cookie += "; Path=$path";
			if (domain)
				cookie += "; Domain=$domain";
			if (secure)
				cookie += "; Secure";
			if (httponly)
				cookie += "; HttpOnly";
			if (this.setheader)
				this.setheader("Set-Cookie", cookie);
			this.writesession(sessiondata, sessionid);
		}

		data = sessiondata;
		return sessiondata;
	}
}

class Main {
	static Main() {
		GLOBALS()["context.async"] = true;
		var obj = CreateObject2("app", CLArg());
		if (obj)
			MainLoop();
		else
			echo "Cannot start: no app class defined";
	}
}

class _webrequest {
	var id;
	var env;
	var headers;
	var cookie;
	var GET;
	var POST;
	var owner;
	var timestamp;
	var session;

	_webrequest(owner, id, data, timestamp) {
		this.owner = owner;
		this.timestamp = (timestamp ?? microseconds())/1000;
		owner.requests++;
		this.id = id;
		this.env = data["env"];
		this.headers = data["headers"];
		this.cookie = data["cookies"];
		this.GET = data["GET"];
		this.POST = data["POST"];
	}

	usesession(expires = 2592000, path = "/", domain = "", secure = false, httponly = true) {
		this.session = new session();
		if (this.cookie) {
			var ess = this.cookie["_ess"];
			if (ess)
				this.session.sessionid = ess;
		}
		this.session.usesession(expires, path, domain, secure, httponly);
	}

	header(key, val) {
		Worker::Result(BinarizeObject(["q" => id, "do" => "header", "data" => ["key" => key, "value" => val]]));
	}

	done() {
		Worker::Result(BinarizeObject(["q" => id, "do" => "done"]));
	}

	print(data) {
		Worker::Result(BinarizeObject(["q" => id, "do" => "print", "data" => data]));
	}

	operator << (data) {
		this.print(data);
		return this;
	}

	sync() {
		if (this.session)
			this.session.syncsession(this.session.data);
	}

	finalize() {
		this.sync();
		owner.requests--;
		done();
		echo "Request fulfilled in ${microseconds()/1000 - this.timestamp}ms\n";
	}
}

class web {
	var[] cache;
	var requests;
	var drop;
	var db;
	var userdata;

	dispatch(data) {
		switch (data["do"]) {
			case "new":
				CreateObject2("app", new _webrequest(this, data["q"], data["data"], data["_"]));
				break;
			case "post":
				break;
			case "data":
				break;
			case "drop":
				drop = true;
				QuitLoop();
				return true;
			case "done":
			case "timedout":
			default:
				break;
		}
		return false;
	}

	iterate() {
		var timeout = 0;
		if (drop)
			return true;

		if (!requests)
			timeout = 1000;

		if (Worker::PendingAll(var data_arr, timeout, 1000)) {
			if (data_arr) {
				for (var i = 0; i < length data_arr; i++) {
					var data = UnBinarizeObject(data_arr[i]);

					if ((!data) || (dispatch(data)))
						return false;
				}
			} else
				return false;

			if (!requests)
				timeout = 1000;
		}
		return false;
	}

	static exit() {
		Worker::Result(BinarizeObject(["do" => "drop"]));
		QuitLoop();
	}

	web(data = "") {
		Loop::add(iterate);
		GLOBALS()["context.async"] = true;
		MainLoop();
		this.exit();
	}
}
