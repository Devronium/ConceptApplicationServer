import standard.lang.cli
import standard.lang.serialize
import standard.C.time
import standard.C.io
import standard.lib.cripto
import standard.lib.mustache
include async.tin.con
include Loop.con
include Worker.con

class __asynctimer {
	protected var timeout;
	protected var _delegate;
	public var onexception;

	__asynctimer(delegate, timeout) {
		this._delegate = delegate;
		this.timeout = microseconds() + timeout * 1000;
		Loop::add(this.iterate);
	}

	public cancel() {
		_delegate = null;
		timeout = 0;
	}

	protected iterate() {
		if (microseconds() >= timeout) {
			try {
				if (_delegate)
					_delegate();
			} catch (var exc) {
				if (onexception)
					onexception(exc);
			}
			return true;
		}
		return false;
	}
}

class async extends Loop {
	static timeout(delegate, timeout) {
		return new __asynctimer(delegate, timeout);
	}
}

class fs {
	protected var root_path = "";

	safepath(path) {
		if (root_path) {
			if ((path[0] != "/") && (path[0] != "\\") && (path[1] != ":"))
				path = root_path + path;
		}
		return path;
	}

	fs(basepath = "") {
		root_path = basepath;
	}

	readFile(path, callback) {
		if (callback) {
			var data = ReadFile(this.safepath(path));
			callback(_errno(), data);
		}
		return true;
	}

	writeFile(path, var data = "", callback = null) {
		var written = WriteFile(data, this.safepath(path));
		if (callback)
			callback(_errno());
		if (written)
			return true;
		return false;
	}
}

class session {
	var sessionid = "";
	var sessionpath;
	var setheader;
	var[] data;

	session() {
		this.sessionpath = _getenv("sessionpath");
		if (!this.sessionpath)
			this.sessionpath = _getenv("tmp");
		if (!this.sessionpath)
			this.sessionpath = _getenv("temp");
		if (!this.sessionpath)
			this.sessionpath = "/tmp";
	}

	operator[](key) {
		if ((data) && (IsSet(data, key)))
			return data[key];
		return null;
	}

	sessionfilename(session_id) {
		return sessionpath + "/" + sessionid + ".ess";
	}

	writesession(sessiondata, session_id) {
		return WriteFile(BinarizeObject(sessiondata), this.sessionfilename(session_id));
	}

	readsession(session_id) {
		var data = ReadFile(this.sessionfilename(session_id));
		if (data)
			return UnBinarizeObject(data);
		return null;
	}

	removesession(session_id) {
		_unlink(this.sessionfilename(session_id));
	}

	syncsession(array sessiondata) {
		if (sessionid) {
			try {
				if (typeof sessiondata == "array") {
					var info = sessiondata["session"];
					if (typeof info == "array") {
						var id = info["id"];	
						if (id == sessionid) {
							if (this.writesession(sessiondata, sessionid))
								return;
						}
					}
				}
			} catch (var exc) {
				echo exc;
			}
			this.removesession(sessionid);
		}
	}

	usesession(expires = 2592000, path = "/", domain = "", secure = false, httponly = true) {
		var sessiondata;
		if (sessionid)
			sessiondata = this.readsession(sessionid);
		if (sessiondata) {
			var info = sessiondata["session"];
			if (info) {
				var is_expired = info["expires"];
				if (time() > is_expired) {
					sessiondata = null;
					this.removesession(sessionid);
				}
			}
		}
		if (!sessiondata) {
			sessionid = sha256(CryptoRandom(80));
			var expires_when = time() + expires;
			sessiondata = ["session" => ["id" => sessionid, "expires" => expires_when, "created" => time()]];
			var cookie = "_ess=${sessionid}; Max-Age=" + expires;
			if (path)
				cookie += "; Path=$path";
			if (domain)
				cookie += "; Domain=$domain";
			if (secure)
				cookie += "; Secure";
			if (httponly)
				cookie += "; HttpOnly";
			if (this.setheader)
				this.setheader("Set-Cookie", cookie);
			this.writesession(sessiondata, sessionid);
		}

		data = sessiondata;
		return sessiondata;
	}
}

class Main {
	static Main() {
		GLOBALS()["context.async"] = true;
		var obj = CreateObject2("app", CLArg());
		if (obj)
			MainLoop();
		else
			echo "Cannot start: no app class defined";
	}
}

class _webrequest {
	var id;
	var env;
	var headers;
	var cookie;
	var GET;
	var POST;
	var web;
	var timestamp;
	var session;
	var template = "";

	protected var _onpost;
	protected var _ondata;
	protected var _ontimedout;
	protected var _ondone;
	protected var _registered;

	property onpost { get _onpost, set setonpost }
	property ondata { get _ondata, set setondata }
	property ontimedout { get _ontimedout, set setontimedout }
	property ondone { get _ondone, set setondone }

	_webrequest(owner, id, data, timestamp) {
		this.web = owner;
		this.timestamp = (timestamp ?? microseconds())/1000;
		web.requests++;
		this.id = id;
		this.env = data["env"];
		this.headers = data["headers"];
		this.cookie = data["cookies"];
		this.GET = data["GET"];
		this.POST = data["POST"];
	}

	usesession(expires = 2592000, path = "/", domain = "", secure = false, httponly = true) {
		this.session = new session();
		this.session.setheader = this.header;
		if (this.cookie) {
			var ess = this.cookie["_ess"];
			if (ess)
				this.session.sessionid = ess;
		}
		this.session.usesession(expires, path, domain, secure, httponly);
		this.session.setheader = null;
	}

	header(key, val) {
		this.web.__buffer(["q" => id, "do" => "header", "data" => ["key" => key, "value" => val]]);
	}

	done() {
		delete this._onpost;
		delete this._ondata;
		delete this._ontimedout;
		delete this._ondone;
		this._registered = null;
		this.web.done(id);
		this.web.__buffer(["q" => id, "do" => "done"]);
	}

	print(data) {
		this.web.__buffer(["q" => id, "do" => "print", "data" => data]);
	}

	operator << (data) {
		this.print(data);
		return this;
	}

	put(array data) {
		if (template) {
			var fullpath;
			if (template[0] != "/")
				fullpath = this.web.fs.safepath(this.web.path) + template;
			else
				fullpath = template;
			var tpl = ReadFile(fullpath);
			if (tpl) {
				var str = mustache(tpl, data, var err);
				if (err) {
					switch (err) {
						case MUSTACH_ERROR_SYSTEM:
							this.print("MUSTACH_ERROR_SYSTEM in template");
							break;
						case MUSTACH_ERROR_UNEXPECTED_END:
							this.print("MUSTACH_ERROR_UNEXPECTED_END in template");
							break;
						case MUSTACH_ERROR_EMPTY_TAG:
							this.print("MUSTACH_ERROR_EMPTY_TAG in template");
							break;
						case MUSTACH_ERROR_TAG_TOO_LONG:
							this.print("MUSTACH_ERROR_TAG_TOO_LONG in template");
							break;
						case MUSTACH_ERROR_BAD_SEPARATORS:
							this.print("MUSTACH_ERROR_BAD_SEPARATORS in template");
							break;
						case MUSTACH_ERROR_TOO_DEPTH:
							this.print("MUSTACH_ERROR_TOO_DEPTH in template");
							break;
						case MUSTACH_ERROR_CLOSING:
							this.print("MUSTACH_ERROR_CLOSING in template");
							break;
						case MUSTACH_ERROR_BAD_UNESCAPE_TAG:
							this.print("MUSTACH_ERROR_BAD_UNESCAPE_TAG in template");
							break;
						case MUSTACH_ERROR_UNDEFINED:
							this.print("MUSTACH_ERROR_UNDEFINED in template");
							break;
						default:
							this.print("UNKNOWN ERROR #$err in template");
					}
					return null;
				}
				data = str;
			}
		}
		this.print(data);
		return this;
	}

	sync() {
		if (this.session)
			this.session.syncsession(this.session.data);
	}

	register() {
		if (!_registered) {
			this.web.register(id, this);
			_registered = true;
		}
	}

	unregister() {
		if (_registered) {
			this.web.done(id);
			_registered = false;
		}
	}

	setonpost(deleg) {
		this.register();
		this._onpost = deleg;
		return deleg;
	}

	setondata(deleg) {
		this.register();
		this._ondata = deleg;
		return deleg;
	}

	setontimedout(deleg) {
		this.register();
		this._ontimedout = deleg;
		return deleg;
	}

	setondone(deleg) {
		this.register();
		this._ondone = deleg;
		return deleg;
	}

	finalize() {
		this.sync();
		web.requests--;
		done();
		echo "Request fulfilled in ${microseconds()/1000 - this.timestamp}ms\n";
	}
}

class web {
	var[] cache;
	var[] requestdata;
	var requests;
	var drop;
	var db;
	var userdata;
	var path;
	var[] buffercache;
	var idle;
	var timeout = 3600;
	var fs;
	protected var lazy_call;

	withdb(delegate, string username = "sysdbadministrator", string password = "sysdbadministrator", string db = "appdb", string host = "localhost", number port = 2668) {
		if (this.db) {
			if (this.db.ifauth()) {
				delegate();
				return true;
			}
			return false;
		}
		this.lazy_call = delegate;
		this.db = new tinasync(db, host, port);
		this.db.auth(username, password).then({
			this.db.keepopen();
			if (this.lazy_call) {
				this.lazy_call();
				delete this.lazy_call;
			}
		});
		return true;
	}

	done(id) {
		if ((id) && (IsSet(requestdata, id))) {
			requestdata[id] = null;
			if ((length requestdata - requests) > 100) {
				var new_requests = new [];
				var keys = GetKeys(requestdata);
				for (var i = 0; i < length keys; i++) {
					var k = keys[i];
					if (k) {
						var e = this.requests[k];
						if (e)
							new_requests[k] = e;
					}
				}
				this.requests = new_requests;
			}
		}
	}

	register(id, obj) {
		if ((id) && (obj))
			requestdata[id] = obj;
	}

	dispatch(data) {
		var obj;
		var id = data["q"];
		switch (data["do"]) {
			case "new":
				CreateObject2("app", new _webrequest(this, id, data["data"], data["_"]));
				break;
			case "post":
				if ((id) && (IsSet(requestdata, id))) {
					obj = requestdata[id];
					if ((obj) && (obj.onpost))
						obj.onpost(data["data"]);
				}
				break;
			case "data":
				if ((id) && (IsSet(requestdata, id))) {
					obj = requestdata[id];
					if ((obj) && (obj.ondata))
						obj.ondata(data["data"]);
				}
				break;
			case "drop":
				requestdata = new [];
				drop = true;
				QuitLoop();
				return true;
			case "timedout":
				if ((id) && (IsSet(requestdata, id))) {
					obj = requestdata[id];
					if ((obj) && (obj.ontimedout))
						obj.ontimedout();
				}
				break;
			case "done":
				if ((id) && (IsSet(requestdata, id))) {
					obj = requestdata[id];
					if ((obj) && (obj.ondone))
						obj.ondone();
				}
				this.done(id);
				break;
			default:
				this.done(id);
				break;
		}
		return false;
	}

	flush() {
		if (buffercache) {
			Worker::Result(BinarizeObject(buffercache));
			buffercache = new [];
		}
	}

	__buffer(data) {
		buffercache[length buffercache] = data;
		if (length buffercache > 100)
			this.flush();
	}

	iterate() {
		var timeout = 0;
		if (drop)
			return true;

		if (requests) {
			idle = 0;
		} else {
			timeout = 1000;
			idle++;
		}
		this.flush();
		if (Worker::Pending(var data_arr, timeout)) {
			idle = 0;
			if (data_arr) {
				data_arr = UnBinarizeObject(data_arr);
				for (var i = 0; i < length data_arr; i++) {
					var data = data_arr[i];

					if ((!data) || (dispatch(data)))
						return false;
				}
			} else
				return false;

			if (!requests)
				timeout = 1000;
		}
		if ((timeout) && (idle >= timeout)) {
			this.drop = true;
			web::exit();
			return true;
		}
		return false;
	}

	static exit() {
		echo "Worker closed\n";
		Worker::Result(BinarizeObject([["do" => "drop"]]));
		QuitLoop();
	}

	web(data = "") {
		this.path = data;
		this.fs = new fs(data);
		Loop::add(iterate);
		GLOBALS()["context.async"] = true;
		if (this.path)
			GLOBALS()["context.root"] = this.path;
		MainLoop();
		this.exit();
	}
}
