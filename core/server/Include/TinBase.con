include BinFile.con
include TinDBOid.con

class TinBase {
	protected var DB = "";
	protected var[] tables;
	public property Use { get DB, set SetDB }
	public var NoIndexCached = false;
	public var Mode = "r+b";
	public var DebugPath;

	TinBase(dbname = "default") {
		Use = dbname;
	}

	Flush(flush_index = true) {
		for (var i = 0; i < length tables; i++) {
			var t = tables[i];
			if (t) {
				t.FlushDB(flush_index);
				t.ResetCache();
			}
		}
	}

	static Lock(hFile, write = false, start = 0, len = 0) {
		if (hFile) {
			if (write)
				return LockFileBytes(hFile, F_SETLKW, start, len);
			return LockFileBytes(hFile, F_SETLKW, start, len, SEEK_SET, F_RDLCK);
		}
		return false;
	}


	static Unlock(hFile, write = false, start = 0, len = 0) {
		if (hFile) {
			if (write)
				return LockFileBytes(hFile, F_UNLCK, start, len);
			return LockFileBytes(hFile, F_UNLCK, start, len, SEEK_SET, F_RDLCK);
		}
		return false;
	}

	static Generator(db, name, increment = 1) {
		if ((Pos(name, "..") > 0) || (Pos(name, "/") > 0) || (Pos(name, "\\") > 0) || (!name) || (name == ".") || (Pos(name, " ") > 0) || (Pos(name, "\t") > 0))
			throw "Invalid generator name $name\n";

		var gen_name = "$db/$name.gen";

		var hFile = fopen(gen_name, "r+");
		if (!hFile) {
			WriteFile("1", gen_name);
			hFile = fopen(gen_name, "r+");
		}
		if (!hFile)
			throw "Error creating or opening data for generator '$name'";

		var err = false;
		var gen_value;
		TinBase::Lock(hFile, true);
		fread(var fdata, 1, 0xFF, hFile);
		if (fdata) {
			var data = value fdata;
			if (!data)
				data = 1;
			gen_value = data;
			data += increment;
			fseek(hFile, 0, SEEK_SET);
			ftruncate(hFile, 0);
			fdata = "" + data;
			if (fwrite(fdata, 1, length fdata, hFile) != length fdata)
				err = true;
		} else
			err = true;
		TinBase::Unlock(hFile);
		fclose(hFile);

		if (err)
			throw "I/O error for generator '$name'";

		return gen_value;
	}

	SetDB(string db) {
		if (!db)
			throw "Invalid database selected\n";
		_mkdir(db);
		this.DB = db;
	}

	Collection(string name, index_only = false) {
		if (!DB)
			throw "No database selected";
		var key = "${DB}/$name";
		if (NoIndexCached) { 
			var t = new BinFile(key, this.Mode);
			if (DebugPath) {
				var path = "$key.debug";
				_mkdir(path);
				t.DebugPath = path;
			}
			if ((!index_only) && (this.Mode != "r") && (this.Mode != "rb")) {
				if (!t.Open())
					throw "Cannot open $key\n";
			}
		} else {
			t = tables[key];
			if ((!t) || (!t.Handle)) {
				t = new BinFile(key, this.Mode);
				if (DebugPath) {
					path = "$key.debug";
					_mkdir(path);
					t.DebugPath = path;
				}
				if ((!index_only) && (this.Mode != "r") && (this.Mode != "rb")) {
					if (!t.Open())
						throw "Cannot open $key\n";
				}
				tables[key] = t;
			}
		}
		return t;
	}

	StoreHandler(string code) {
		return WriteFile(code, "${DB}/handler.con");
	}

	ReadHandler() {
		return ReadFile("${DB}/handler.con");
	}

	StoreTriggers(array _triggers) {
		return WriteFile(BinarizeObject(_triggers), "${DB}/triggers.bin");
	}

	ReadTriggers() {
		var data = ReadFile("${DB}/triggers.bin");
		if (data)
			return UnBinarizeObject(data);
		return null;
	}

	operator[](string name) {
		return Collection(name);
	}

	Reset() {
		this.Flush();
		for (var i = 0; i < length tables; i++) {
			var t = tables[i];
			if (t)
				t.Reset();
		}
		tables = new [];
	}
}
