import standard.lib.samplerate
import standard.lib.json

include IVR.con
include STT.con
include MSSpeech.con
include WhisperSpeech.con
include Worker.con
include URL.con
include DUKJS.con
include OpenAI.con
include MP3.con
include ElevenLabs.con
include RWKV.con

define SETTINTS_MAX_TIMEOUTS	4
define SETTINGS_ENSURE_WORDS	false
define SETTINGS_MAX_DEQUEUE	4096

define STT_RESET	0
define STT_ADDBUFFER	1
define STT_TEXT		2
define STT_SCORER	3
define STT_TIMEDOUT	4

class IVRClientData {
	var count;
	var ivr_branch;
	var prev_branch;
	var ivr_tree;
	var hash;
	var ivr_path = "";
	var last_text = "";
	var debug_text = "";
	var api;
	var UserData;
	var redirect = "";
	var redirect_timestamp;
	var finish_api = "";
	var answered = false;
	var timestamp;
	var expectedWords;
	var worker;
	var worker_key;
	var default_language;
	var timeouts;
	var remotehost;
	var empty_buffer = true;
	var forward = false;
	var diverted;
	var is_queue;
	var referTryCount;
	var referAddress;
	var dtmf_timestamp;
	var ai_wait;
	var js_called;

	IVRClientData(ivr, ivr_tree, session, notify_event = true, is_queue = false) {
		this.ivr_branch = ivr_tree;
		this.ivr_tree = ivr_tree;
		this.hash = Murmur(session.sip.CallID);
		this.timestamp = microseconds();
		this.is_queue = is_queue;
		if (!session.sip.is_invite)
			this.diverted = ivr.diversion(session.sip.msg);

		if (((ivr.OnAPI) || (ivr.OnEvent)) && (typeof ivr_tree == "array")) {
			if (ivr.OnAPI) {
				var k = GetKeys(ivr_tree)[0];
				if (k) {
					if (Pos(k, "\$api") == 1) {
						this.finish_api = trim(SubStr(k, 4));
						if (notify_event)
							ivr.OnAPI(session, session.ClientData.ivr_path, this.finish_api, "open");
					}
				}
			}
			if ((ivr.OnEvent) && (notify_event))
				ivr.OnEvent(session, session.ClientData.ivr_path, "open");
		}
		if (ivr_tree) {
			var key = GetKeys(ivr_tree)[0];
			if ((key) && (Pos(k, "\$redirect") == 1)) {
				this.redirect = key;
				this.ivr_branch = null;
			}
		}
		session.sip.setMaxJitter(4);
		// session.sip.NATMode = true;

		// if (session.sip.is_invite)
		// 	session.sip.Record = true;
	}

	callDuration() {
		return floor((microseconds() - this.timestamp) / 1000);
	}

	waitingMusic(ivr, session, type = 8) {
		var codec = "";
		if (type == 8)
			codec = "alaw";
		else
			codec = "ulaw";

		if (!session.sip.Record) {
			session.ClientData.count = 0;
			session.EndOnIVRFinished = false;
			session.ClientData.redirect = "";
			session.Expires = 1800;
			session.sip.setExpires(1800);
			session.sip.ResetBuffers();
			session.sip.Record = true;
			session.StartRecording(session.Expires);
		}
		session.sip.setMaxJitter(2);
		if (empty_buffer) {
			var music = ivr.music[codec];
			if (!music) {
				music = ReadFile("repository/music.$codec");
				if (music)
					ivr.music[codec] = music;
			}
			if (music)
				session.sip.LoadVoice(music);

			empty_buffer = false;
		}
	}

	loadMusic(ivr, session, type = 8) {
		var codec = "";
		if (type == 8)
			codec = "alaw";
		else
			codec = "ulaw";

		var music = ivr.music[codec];
		if (!music) {
			music = ReadFile("repository/music.$codec");
			if (music)
				ivr.music[codec] = music;
		}
		if (music)
			session.sip.AppendVoice(music);

		empty_buffer = false;
	}

	forwardUDP(ivr, session, var buf, type, var forward_socket) {
		if ((!remotehost) || (!buf) || (!session) || (!forward))
			return;

		if (!forward_socket) {
			try {
				forward_socket = new UDPSocket();
				forward_socket.Bind(4844);
			} catch (var exc) {
				console.error(LOG_THIS, exc);
			}
		}

		if (buf) {
			try {
				var codec = "";
				if (type == 8)
					codec = "alaw";
				else
					codec = "ulaw";

				var identity;
				if (session.sip.is_invite)
					identity = session.From;
				else
					identity = session.To;
				var ip = remotehost[0];
				var port = remotehost[1];
				if ((!ip) || (!port))
					return;
				forward_socket.Write("identity: $identity\r\ncallid: ${session.sip.CallID}\r\ncodec: $codec\r\n\r\n" + buf, ip, port);
			} catch (var exc2) {
				console.warn(LOG_THIS, exc2);
			}
		}
	}

	static checkEvent(session, to, from, ivr, ivr_tree, key) {
		if (((ivr.OnAPI) || (ivr.OnEvent)) && (typeof ivr_tree == "array")) {
			var ref_session;
			to = StrSplit(to, "@")[0];
			from = StrSplit(from, "@")[0];
			if (ivr.OnAPI) {
				var k = GetKeys(ivr_tree)[0];
				if (k) {
					if (Pos(k, "\$api") == 1) {
						ref_session = new DATASession(null, session, from, to);
						ivr.OnAPI(ref_session, "", trim(SubStr(k, 4)), key);
					}
				}
			}
			if (ivr.OnEvent) {
				if (!ref_session)
					ref_session = new DATASession(null, session, from, to);
				ivr.OnEvent(ref_session, "", key);
			}
		}

	}
}

class STTWorkerData {
	var id;
	var type;
	var buffer;
	var codec;

	STTWorkerData(id, op_type, var buffer = "", codec = 8) {
		this.id = id;
		this.type = op_type;
		this.buffer = buffer;
		this.codec = codec;
	}
}

class STTWorkerObject {
	var id;
	var stream;
	var timestamp;
	var buffer_timestamp;
	var last_str = "";
	var send_timestamp;
	var text_timestamp;
	var words;
	var silence;
	var silence_buffer = "";

	STTWorkerObject(id) {
		this.id = id;
		this.ping();
		this.reset();
		this.resetText();
	}

	ping() {
		this.timestamp = microseconds();
	}

	reset(reset_stream = true) {
		buffer_timestamp = microseconds();
		if ((stream) && (reset_stream)) {
			stream.close();
			delete stream;
		}
		last_str = "";
		silence_buffer = "";
	}

	resetText() {
		this.text_timestamp = microseconds();
	}

	textAge() {
		return (microseconds() - this.text_timestamp) / 1000;
	}

	age() {
		return (microseconds() - this.buffer_timestamp) / 1000;
	}

	expired(max_timeout_ms) {
		max_timeout_ms *= 1000;

		if ((this.timestamp) && (microseconds() - this.timestamp > max_timeout_ms)) {
			if ((this.stream) && (this.stream._handle))
				this.stream.close();
			delete this.stream;
			return true;
		}
		return false;
	}

	canSend() {
		if (!send_timestamp)
			send_timestamp = microseconds();

		if (microseconds() - send_timestamp >= 800000) {
			send_timestamp = microseconds();
			return true;
		}

		return false;
	}

	finalize() {
		delete this.stream;
	}
}

class STTWorker {
	STTWorker(model_scorer) {
		console.log(LOG_THIS, "created worker for $model_scorer");

		var arr = StrSplit(model_scorer, ":");
		var stt = new STT(arr[0]);
		var scorer = arr[1] ?? "";
		var scorer_timestamp;
		if (scorer)
			scorer = "./scorers/$scorer";		
		scorer_timestamp = _filelast_mod(scorer);
		if (FileExists(scorer)) {
			try {
				stt.externalScorer = scorer;
			} catch (var scorer_exc) {
				console.error(LOG_THIS, scorer_exc);
			}
		}
		var max_response_length = value (arr[2]) ?? 48;

		var modelSampleRate = stt.modelSampleRate;
		var[] objects;

		var clear_time_stamp = microseconds();
		while (true) {
			if (Worker::Pending(var buffer, 1000)) {
				var obj = UnBinarizeObject(buffer);
				if (!obj)
					continue;

				try {
					if (obj.type == STT_SCORER) {
						stt.externalScorer = obj.buffer ?? "";
						console.log(LOG_THIS, "new scorer loaded ${obj.buffer}");
						continue;
					}

					var worker_obj = objects[obj.id];

					if (obj.type == STT_RESET) {
						if (worker_obj) {
							/* if ((worker_obj.stream) && (worker_obj.stream._handle))
								worker_obj.stream.close();
							delete worker_obj.stream;
							worker_obj.last_str = "";  */
							worker_obj.reset();
							worker_obj.words = obj.buffer;
						}
						objects[obj.id] = null;
						continue;
					}
					if (!obj.buffer)
						continue;

					if (!worker_obj) {
						worker_obj = new STTWorkerObject(obj.id);
						objects[obj.id] = worker_obj;
					}

					if (!worker_obj.stream)
						worker_obj.stream = new STTStream(stt);

					var pcm_buf;
					if (obj.codec == 0)
						pcm_buf = ulaw2pcm(obj.buffer);
					else
						pcm_buf = alaw2pcm(obj.buffer);

					var buf2 = resample(pcm_buf, 8000, modelSampleRate, SRC_SINC_FASTEST);
					var level_val = level(buf2);
					if (level_val < 0.0028)
						worker_obj.silence ++;
					else
						worker_obj.silence = 0;

					var force_send = false;
					if (worker_obj.silence >= 50) {
						worker_obj.silence = 0;
						force_send = true;
					}

					if (worker_obj.silence <= 8) {
						if (worker_obj.silence_buffer) {
							worker_obj.stream.feed(worker_obj.silence_buffer);
							worker_obj.silence_buffer = "";
						}
						worker_obj.stream.feed(buf2);
					} else {
						worker_obj.silence_buffer = buf2;
					}

					if ((worker_obj.textAge() >= 8000) || (force_send)) {
						var str = worker_obj.stream.decode();
						if ((str) && (worker_obj.canSend())) {
							// if (worker_obj.last_str != str) {
							// 	worker_obj.last_str = str;
							// } else {
								Worker::Result(BinarizeObject(new STTWorkerData(obj.id, STT_TEXT, str, -1)));
								if (length str > max_response_length) {
									console.trace(LOG_THIS, "resetting buffer for ${obj.id}");
									worker_obj.reset();
								}
							// }
						}
						worker_obj.resetText();
					}
					// if ((worker_obj.silence >= 16) && (worker_obj.silence % 16 == 0))
					//  	worker_obj.reset();

					if (worker_obj.age() >= 14000) {						
						console.trace(LOG_THIS, "resetting buffer for ${obj.id}");
						worker_obj.reset();
						Worker::Result(BinarizeObject(new STTWorkerData(obj.id, STT_TIMEDOUT, "")));
					}
					worker_obj.ping();
				} catch (var exc) {
					console.warn(LOG_THIS, exc);
				}
			}

			if (microseconds() - clear_time_stamp >= 3000000) {
				var new_obj = new [];
				var cleared = 0;
				for (var i = 0; i < length objects; i ++) {
					var ref_obj = objects[i];
					if ((ref_obj) && (!ref_obj.expired(3000)))
						new_obj[ref_obj.id] = ref_obj;
					else
						cleared ++;
				}
				objects = new_obj;
				clear_time_stamp = microseconds();
				if (cleared)
					console.log(LOG_THIS, "cleared $cleared session(s)");

				if (_filelast_mod(scorer) != scorer_timestamp) {
					try {
						scorer_timestamp = _filelast_mod(scorer);
						stt.externalScorer = scorer;
						console.log(LOG_THIS, "reloaded scorer (changed)");
					} catch (scorer_exc) {
						console.error(LOG_THIS, scorer_exc);
					}
				}
			}
		}
	}
}

class MSSWorker {
	parse(str) {
		str = StrReplace(str, ".", " ");
		str = StrReplace(str, ",", " ");
		str = StrReplace(str, "?", " ");
		str = StrReplace(str, "!", " ");
		str = StrReplace(str, "  ", " ");

		return UTF8ToLower(trim(str));
	}

	MSSWorker(data) {
		data = UnBinarizeObject(data);

		console.log(LOG_THIS, "created MSS worker for ${data["language"]}");

		var clear_time_stamp = microseconds();
		var stt = new MSSpeech(data["language"], data["key"], data["region"]);
		var[] objects;

		while (true) {
			if (Worker::Pending(var buffer, 1000)) {
				var obj = UnBinarizeObject(buffer);
				if (!obj)
					continue;

				try {
					if (obj.type == STT_SCORER) {
						console.log(LOG_THIS, "ignored scorer");
						continue;
					}

					var worker_obj = objects[obj.id];

					if (obj.type == STT_RESET) {
						if (worker_obj) {
							/* if ((worker_obj.stream) && (worker_obj.stream._handle))
								worker_obj.stream.close();
							delete worker_obj.stream;
							worker_obj.last_str = ""; */
							worker_obj.reset();
							worker_obj.words = obj.buffer;
						}
						objects[obj.id] = null;
						continue;
					}
					if (!obj.buffer)
						continue;

					if (!worker_obj) {
						worker_obj = new STTWorkerObject(obj.id);
						objects[obj.id] = worker_obj;
					}

					if (!worker_obj.stream) {
						if (obj.codec == 0)
							worker_obj.stream = new MSSpeechStream(stt, 8);
						else
							worker_obj.stream = new MSSpeechStream(stt, 4);
					}


					// worker_obj.silence_buffer += obj.buffer;
					// if (length worker_obj.silence_buffer >= 8000) {
						if (worker_obj.age() < 12000)
							worker_obj.stream.feed(obj.buffer);
					//	worker_obj.silence_buffer = "";
					//}
					var str = worker_obj.stream.decode();
					if ((str) && (worker_obj.canSend())) {
						Worker::Result(BinarizeObject(new STTWorkerData(obj.id, STT_TIMEDOUT, this.parse(str))));
						worker_obj.resetText();
						// soft reset buffer
						// worker_obj.stream.close();
						// delete worker_obj.stream;
						worker_obj.reset();
					}

					if (worker_obj.age() >= 14000) {
						console.trace(LOG_THIS, "resetting buffer for ${obj.id}");
						worker_obj.reset();
						Worker::Result(BinarizeObject(new STTWorkerData(obj.id, STT_TIMEDOUT, "")));
					}
					worker_obj.ping();
				} catch (var exc) {
					console.warn(LOG_THIS, exc);
				}
			}

			if (microseconds() - clear_time_stamp >= 3000000) {
				var new_obj = new [];
				var cleared = 0;
				for (var i = 0; i < length objects; i ++) {
					var ref_obj = objects[i];
					if ((ref_obj) && (!ref_obj.expired(3000)))
						new_obj[ref_obj.id] = ref_obj;
					else
						cleared ++;
				}
				objects = new_obj;
				clear_time_stamp = microseconds();
				if (cleared)
					console.log(LOG_THIS, "cleared $cleared session(s)");
			}
		}
	}
}


class WhisperSpeechWorker {
	parse(str) {
		str = StrReplace(str, ".", " ");
		str = StrReplace(str, ",", " ");
		str = StrReplace(str, "?", " ");
		str = StrReplace(str, "!", " ");
		str = StrReplace(str, "  ", " ");

		return UTF8ToLower(trim(str));
	}

	WhisperSpeechWorker(data) {
		data = UnBinarizeObject(data);

		console.log(LOG_THIS, "created WS worker for ${data["language"]}");

		var clear_time_stamp = microseconds();
		var stt = new WhisperSpeech(data["language"], data["model"], data["threads"] ?? 8, data["whisper"]);
		var[] objects;

		var modelSampleRate = stt.modelSampleRate;

		while (true) {
			if (Worker::Pending(var buffer, 1000)) {
				var obj = UnBinarizeObject(buffer);
				if (!obj)
					continue;

				try {
					if (obj.type == STT_SCORER) {
						console.log(LOG_THIS, "ignored scorer");
						continue;
					}

					var worker_obj = objects[obj.id];

					if (obj.type == STT_RESET) {
						if (worker_obj) {
							if (worker_obj.stream)
								worker_obj.stream.reset();
							worker_obj.reset();
							worker_obj.words = obj.buffer;
						}
						objects[obj.id] = null;
						continue;
					}
					if (!obj.buffer)
						continue;

					if (!worker_obj) {
						worker_obj = new STTWorkerObject(obj.id);
						objects[obj.id] = worker_obj;
					}

					if (!worker_obj.stream) {
						worker_obj.stream = new WhisperSpeechStream(stt);
						worker_obj.stream.BufferTimeout = 8000;
						worker_obj.stream.MinBufferSize = 32000 * 2;
					}

					if (worker_obj.age() < 12000) {
						var pcm_buf;
						if (obj.codec == 0)
							pcm_buf = ulaw2pcm(obj.buffer);
						else
							pcm_buf = alaw2pcm(obj.buffer);

						worker_obj.stream.feed(resample(pcm_buf, 8000, modelSampleRate, SRC_SINC_MEDIUM_QUALITY));
					}

					var str = worker_obj.stream.decode();
					if ((str) && (worker_obj.canSend())) {
						Worker::Result(BinarizeObject(new STTWorkerData(obj.id, STT_TEXT, this.parse(str))));
						worker_obj.resetText();
						worker_obj.stream.finish();
					}

					var age = worker_obj.age();
					if ((age >= 24000) || ((!str) && (!worker_obj.stream.Pending) && (age >= 14000))) {
						worker_obj.reset(false);
						Worker::Result(BinarizeObject(new STTWorkerData(obj.id, STT_TIMEDOUT, "")));
						worker_obj.stream.reset();
					}
					worker_obj.ping();
				} catch (var exc) {
					console.warn(LOG_THIS, exc);
				}
			}

			if (microseconds() - clear_time_stamp >= 3000000) {
				var new_obj = new [];
				var cleared = 0;
				for (var i = 0; i < length objects; i ++) {
					var ref_obj = objects[i];
					if ((ref_obj) && (!ref_obj.expired(3000)))
						new_obj[ref_obj.id] = ref_obj;
					else
						cleared ++;
				}
				objects = new_obj;
				clear_time_stamp = microseconds();
				if (cleared)
					console.log(LOG_THIS, "cleared $cleared session(s)");
			}
		}
	}
}

class VoiceWorkerData {
	var text;
	var codec;
	var opaque;

	VoiceWorkerData(text, opaque = null, codec = "alaw") {
		this.text = text;
		this.opaque = opaque;
		this.codec = codec;
	}
}

class ro_numbers {
	static division(div, unitati, superunitati=null) {
		var UNITATI2		= ["zero", "unu", "doi", "trei", "patru", "cinci", "È™ai", "È™apte", "opt", "nouÄƒ"];
		var ZECI		= ["zece", "zeci"];
		var SUTE		= ["o sutÄƒ","sute"];
		var UNITATI_FEM	 	= ["zero", "o", "douÄƒ", "trei", "patru", "cinci", "È™ase", "È™apte", "opt", "nouÄƒ"];
		var UNITATI_FEM2	= ["zero", "o", "douÄƒ", "trei", "patru", "cinci", "È™ai", "È™apte", "opt", "nouÄƒ"];
		var result = "";
		if (div) {
			if (div == 1) {
				if (superunitati)
					result += superunitati[0];
				else
					result += unitati[1];
			} else {
				if (div >= 100) {
					if (div < 200)
						result += SUTE[0];
					else {
						result += UNITATI_FEM[floor(div / 100)];
						result += " " + SUTE[1];
					}
				}
				div %= 100;

				var has_zeci = false;
				if (div >= 10) {
					
					if (result)
						result += " ";
					if ((div > 10) && (div < 20)) {
						result += UNITATI2[floor(div % 10)];
						result += "spre";
						result += ZECI[0];
						div=0;
					} else
					if (div == 10) {
						result += ZECI[0];
					} else {
						result += UNITATI_FEM2[floor(div / 10)];
						result += ZECI[1];
						has_zeci = true;
					}
				}
				div %= 10;

				if (div) {
					if (has_zeci)
						result += " È™i ";
					else
					if (result)
						result += " ";
					result += unitati[div];
				}
				if ((result) && (superunitati))
					result += " " + superunitati[1];
			}
		}
		return result;
	}

	static toWord(val) {
		var UNITATI		= ["zero", "unu", "doi", "trei", "patru", "cinci", "È™ase", "È™apte", "opt", "nouÄƒ"];
		var UNITATI_FEM	 	= ["zero", "o", "douÄƒ", "trei", "patru", "cinci", "È™ase", "È™apte", "opt", "nouÄƒ"];
		var MII			= ["o mie", "mii"];
		var MILIOANE		= ["un milion", "milioane"];
		var MILIARDE		= ["un miliard", "miliarde"];

		var result = "";
		val = value number_format(value (""+val),2,".","");

		var zecimale = (val - floor(val))*100;

		val = floor(val);

		var rem = val % 1000000000;
		var div = floor(val/1000000000);
		result  +=  ro_numbers::division(div, UNITATI_FEM, MILIARDE);

		val = rem;
		rem = val % 1000000;
		div = floor(val / 1000000);
		var temp = ro_numbers::division(div, UNITATI_FEM, MILIOANE);
		if (result && temp)
			result += " ";
		result += temp;

		val = rem;
		rem = val % 1000;
		div = floor(val / 1000);
		temp = ro_numbers::division(div, UNITATI_FEM, MII);
		if (result && temp)
			result += " ";
		result += temp;

		val = rem;
		div = floor(val);
		temp = ro_numbers::division(div, UNITATI);
		if (result && temp)
			result += " ";
		result += temp;
		if (zecimale) {
			result += " virgulÄƒ ";
			result += ro_numbers::toWord(zecimale);
		}

		return result;
	}

	static text(text) {
		var new_text = "";
		var number = "";
		for (var i = 0; i < length text; i ++) {
			var char = text[i];
			if (((char >= '0') && (char <= '9')) || ((number) && ((char == ',') || (char == '.')))) {
				if (char == ",")
					char = ".";
				if (char == ".")
					continue;
				number += char;
			} else {
				if (number) {
					new_text += ro_numbers::toWord(number);
					if (number[length number - 1] == ',')
						new_text += ",";
					number = "";
				}
				new_text += char;
			}
		}
		if (number) {
			new_text += ro_numbers::toWord(number);
			if (number[length number - 1] == ',')
				new_text += ",";
		}
		new_text = StrReplace(new_text, "+", " adunat cu ");
		new_text = StrReplace(new_text, "=", " este egal cu ");
		new_text = StrReplace(new_text, "*", " Ã®nmulÈ›it cu ");
		new_text = StrReplace(new_text, "/", " Ã®mpÄƒrÈ›it la ");
		return new_text;
	}
}

class VoiceWorker {
	static alaw(wav_data) {
		var header = unpack("s4u32s4s4u32u16u16u32u32u16u16", wav_data);
		if ((header[0] != "RIFF") || (header[2] != "WAVE"))
			return "";

		var data_offset = header[4] + 20;
		var format = header[5];
		var channels = header[6];
		var samplerate = header[7];
		var bits = header[10];
		do {
			var header2 = unpack("s4u32", wav_data, data_offset);
			if (header2[0] == "data") {
				data_offset += 8;
				break;
			}

			data_offset += header2[1] + 8;
		} while (data_offset < length wav_data);

		if (data_offset >= length wav_data)
			return "";

		wav_data = SubStr(wav_data, data_offset);

		// already alaw format
		if ((bits == 8) && (format == 6) && (samplerate == 8000))
			return wav_data;

		if (bits == 8) {
			bits = 16;
			wav_data = to16bits(wav_data);
		}

		if ((bits == 16) && (samplerate == 8000))
			return pcm2alaw(wav_data);

		if (channels == 2) {
			var channel_data = "";
			for (var i = 0; i < length wav_data; i += 4)
				channel_data += wav_data[i] + wav_data[i + 1];
			wav_data = channel_data;
		}
		return pcm2alaw(resample(wav_data, samplerate, 8000, SRC_SINC_BEST_QUALITY));
	}

	static ulaw(wav_data) {
		var header = unpack("s4u32s4s4u32u16u16u32u32u16u16", wav_data);
		if ((header[0] != "RIFF") || (header[2] != "WAVE"))
			return "";

		var data_offset = header[4] + 20;
		var format = header[5];
		var channels = header[6];
		var samplerate = header[7];
		var bits = header[10];
		do {
			var header2 = unpack("s4u32", wav_data, data_offset);
			if (header2[0] == "data") {
				data_offset += 8;
				break;
			}

			data_offset += header2[1] + 8;
		} while (data_offset < length wav_data);

		if (data_offset >= length wav_data)
			return "";

		wav_data = SubStr(wav_data, data_offset);

		// already ulaw format
		if ((bits == 8) && (format == 7) && (samplerate == 8000))
			return wav_data;

		if (bits == 8) {
			bits = 16;
			wav_data = to16bits(wav_data);
		}

		if ((bits == 16) && (samplerate == 8000))
			return pcm2ulaw(wav_data);

		if (channels == 2) {
			var channel_data = "";
			for (var i = 0; i < length wav_data; i += 4)
				channel_data += wav_data[i] + wav_data[i + 1];
			wav_data = channel_data;
		}
		return pcm2ulaw(resample(wav_data, samplerate, 8000, SRC_SINC_BEST_QUALITY));
	}

	static tts(text, voice, output) {
		try {
			if (Pos(voice, "microsoft/") > 0) {
				var arr = StrSplit(voice, "/");
				if (length arr == 4) {
					var key_arr = StrSplit(arr[3], "@");
					console.log(LOG_THIS, "using MSTTS for [$text]");
					var ms_data = MsSpeech_TTS(arr[1], arr[2], key_arr[0], key_arr[1], text, (text[0] == "<"));
					if (ms_data) {
						WriteFile(ms_data, output);
						return 0;
					}
				}
			} else
			if (Pos(voice, "elevenlabs/") > 0) {
				arr = StrSplit(voice, "/");
				if (length arr == 4) {
					console.log(LOG_THIS, "using ElevenLabs for [$text]");
					var tts = new ElevenLabs(arr[3]);
					var eleven_data = tts.sync(text, arr[2], "pcm_16000");
					if ((eleven_data) && (length eleven_data >= 1024)) {
						var wav_data = pack("s4u32s4s4u32u16u16u32u32u16u16s4u32", "RIFF", length eleven_data + 28, "WAVE", "fmt ", 16, 1, 1, 16000, 32000, 2, 16, "data", length eleven_data);
						if (wav_data) {
							WriteFile(wav_data + eleven_data, output);
							return 0;
						}
					}
				}
			}


			if (Pos(voice, "/ro/") > 0)
				text = ro_numbers::text(text);
			if (!text)
				return 0;

			var data = ["text" => text, "model" => voice, "output" => output];
			var socket = new UDPSocket();

			socket.Write(JSONSerialize(data, true), "127.0.0.1", 20048);

			// 10ms per character
			var max_timeout = 2000 + (length text) * 10;
			if (!socket.GetHasData(max_timeout)) {
				if (FileExists(output))
					return 0;
				console.warn(LOG_THIS, "tts service timed out in ${max_timeout}ms");
				return TTSHelper::tts(text, voice, output);
			}

			var buffer = socket.Read(var ip);
			if ((!buffer) || (ip != "127.0.0.1"))
				return TTSHelper::tts(text, voice, output);

			var json = JSONDeserialize(buffer);
			if ((!json) || (json["error"]))
				return TTSHelper::tts(text, voice, output);
		} catch (var exc) {
			console.warn(LOG_THIS, exc);
			return TTSHelper::tts(text, voice, output);
		}
		return 0;
	}

	static adjustVoice(var text, voice, tts_keys) {
		var text_ref = trim(text);
		var pos2 = Pos(text_ref, "]");
		if ((text_ref) && (text_ref[0] == "[") && (pos2 > 1)) {
			var voice_id = ToLower(SubStr(text_ref, 1, pos2 - 2));
			text = trim(SubStr(text_ref, pos2));
			if (IsSet(tts_keys, voice_id))
				return tts_keys[voice_id] ?? voice;
		}
		return voice;
	}

	static key(text, voice) {
		return sha1("" + voice + "/" + text);
	}

	static exists(text, voice, format = "alaw") {
		var fname = VoiceWorker::key(text, voice);
		return FileExists("./repository/$format/$fname.$format");
	}

	static ensureAudio(text, voice, tts_keys = null, format = "alaw") {
		var fname = VoiceWorker::key(text, voice);
		if (!voice)
			return fname;

		if (tts_keys)
			voice = VoiceWorker::adjustVoice(text, voice, tts_keys);

		console.log(LOG_THIS, "preparing $voice/[$text]");
		if (!FileExists("./repository/$format/$fname.$format")) {
			VoiceWorker::tts(text, voice, "./repository/$fname.wav");
			if (format == "ulaw") {
				var ulaw_data = VoiceWorker::ulaw(ReadFile("./repository/$fname.wav"));
				if (ulaw_data)
					WriteFile(ulaw_data, "./repository/ulaw/$fname.ulaw");
			} else {
				var alaw_data = VoiceWorker::alaw(ReadFile("./repository/$fname.wav"));
				if (alaw_data)
					WriteFile(alaw_data, "./repository/alaw/$fname.alaw");
			}

			_unlink("./repository/$fname.wav");
		}
		return fname;
	}

	VoiceWorker(data) {
		data = UnBinarizeObject(data);
		var voice = data[0];
		var tts_keys = data[1];
		console.info(LOG_THIS, "created worker for $voice");
		while (true) {
			if (Worker::Pending(var buffer, 1000)) {
				var obj = UnBinarizeObject(buffer);
				if (!obj)
					continue;

				if (obj.text) {
					if (!obj.codec)
						obj.codec = "alaw";

					for (var i = 0; i < length obj.text; i ++) {
						var text = obj.text[i];
						if ((text) && (text[0] != "\$") && (!VoiceWorker::exists(text, voice, obj.codec)))
							this.ensureAudio(text, voice, tts_keys, obj.codec);
					}
				}
				
				Worker::Result(buffer);
			}
		}
	}
}

class WorkerWithData extends Worker {
	var UserData;

	WorkerWithData(classname, string parameter = "", data = null) {
		super(classname, parameter);
		this.UserData = data;
	}
}

class BromblerJS {
	var duk;

	var print_buffer = "";
	var error_buffer = "";

	BromblerJS(js_timeout_ms = 2480) {
		duk = new JS(this.error_handler);
		duk.wrap(this.getURL, "GET");
		duk.wrap(this.postURL, "POST");
		duk.wrap(this.print, "print");
		duk.wrap(this.error, "error");
		duk.timeout(js_timeout_ms);
	}

	error_handler(err) {
		this.error(err);
	}

	safeURL(url_str) {
		var url = trim(ToLower(url_str));
		if (Pos(url, "file:") == 1)
			return false;
		return true;
	}

	getURL(url_str, headers = null) {
		if (!this.safeURL(url_str))
			return "";
		var url = new URL();
		url.Get(url_str, null, true, "Brombler", true, headers, [[CURLOPT_TIMEOUT, 2]]);
		return url.Data;
	}

	postURL(url_str, post_array, headers = null) {
		if (!this.safeURL(url_str))
			return "";
		var url = new URL();
		url.Get(url_str, post_array, true, "Brombler", false, headers, [[CURLOPT_TIMEOUT, 2]]);
		return url.Data;
	}

	string_buf(var data) {
		var buffer = "";
		if (data) {
			switch (typeof data) {
				case "string":
					buffer += SubStr(data, 0, 1024);
					break;
				case "numeric":
					buffer += data;
					break;
				default:
					buffer += typeof data;
			}
			buffer += "\n";
		}
		return buffer;
	}

	print(data) {
		if (length print_buffer < 0x10000)
			print_buffer += this.string_buf(data);
		console.log(LOG_THIS, data);
	}

	error(data) {
		if (length error_buffer < 0x10000)
			error_buffer += this.string_buf(data);
		console.error(LOG_THIS, data);
	}

	load(var code) {
		try {
			return duk.script(code);
		} catch (var exc) {
			return exc;
		}
	}

	call(function_name, parameters = null) {
		try {
			return duk.call(function_name, parameters);
		} catch (var exc) {
			return exc;
		}
	}

	done() {
		// avoid circular reference 
		delete duk;
	}
}

class JSWorker {
	JSWorker(data) {
		console.info(LOG_THIS, "created JS worker");
		while (true) {
			if (Worker::Pending(var buffer, 1000)) {
				var obj = UnBinarizeObject(buffer);
				if ((!obj) || (!obj["identity"]))
					continue;

				var identity = obj["identity"];
				var code = ReadFile("./trunks/${identity}.js");
				if (code) {
					var js = new BromblerJS();
					js.load(code);
					obj["data"] = js.load(obj["apiCall"]);
					obj["print"] = js.print_buffer;
					obj["error"] = js.error_buffer;
					// avoid circular reference
					js.done();
				}
				Worker::Result(BinarizeObject(obj));
			}
		}
	}
}

class AIWorker {
	var rwkv;

	AIWorker(data) {
		console.info(LOG_THIS, "created AI worker");
		rwkv = new RWKV("ai_models/RWKV4_Q.bin", 8);
		rwkv.maxTokens = 80;
		rwkv.stopAt = ".";
		while (true) {
			if (Worker::Pending(var buffer, 1000)) {
				var obj = UnBinarizeObject(buffer);
				if (!obj)
					continue;

				var text = trim(obj["text"] ?? "");
				
				obj["step1"] = Date.now() - obj["start"];
				if (text) {
					var user_instructions = obj["instructions"] ?? "";
					if (user_instructions)
						user_instructions = "Input: $user_instructions\n\n";

					var prompt = "${user_instructions}Instruction: $text\n\nResponse:";
					obj["text"] = trim(rwkv.run(prompt));
					obj["step2"] = Date.now() - obj["start"];
				} else
					obj["text"] = "error";

				Worker::Result(BinarizeObject(obj));
			}
		}
	}
}

class OpenAIWorker {
	var default_data;
	var key;
	var instructions = "";
	var use_davinci = false;

	OpenAIWorker(data) {
		var arr = UnBinarizeObject(data);
		key = arr[0];
		instructions = arr[1];
		if (instructions)
			instructions += "\n";

		console.info(LOG_THIS, "created openAI worker");
		if (use_davinci) {
			this.default_data = [
				"model": "text-davinci-003",
				"prompt": "",
				"temperature": 0.4,
				"max_tokens": 160,
				"top_p": 1,
				// "stop": ".",
				"frequency_penalty": 0.5,
				"presence_penalty": 0.0
			];
		} else {
			this.default_data = [
			 	"model": "gpt-3.5-turbo",
				"messages": [["role": "system", "content": ""], ["role": "user", "content": ""]]
			];
		}

		Loop::add(this);
		Loop::main();
	}

	sendResponse(url, obj) {
		var text = OpenAI::simple(url);
		if ((text[0] == '?') || (text[0] == '!'))
			text = trim(SubStr(text, 1));

		obj["step2"] = Date.now() - obj["start"];
		console.log(LOG_THIS, "got ChatGPT message [$text] in ${obj["step2"]}ms");
		obj["text"] = text;
		Worker::Result(BinarizeObject(obj));
	}

	sendError(err, obj) {
		obj["text"] = "error";
		Worker::Result(BinarizeObject(obj));
	}

	prefix(text) {
		var date = StrSplit((new Date()).toISOString(), "T")[0];
		return "Answer as concisely as possible. Knowledge cutoff: 2021-09-01 Current date: $date.\n" + instructions + text;
	}

	iterate() {
		try {
			if (Worker::PendingAll(var arr, 100)) {
				for (var i = 0; i < length arr; i ++) {
					var obj = UnBinarizeObject(arr[i]);
					if (obj) {
						var ai = new OpenAI(key);
						try {
							var text = obj["text"];
							if (length StrSplit(text, " ") < 2) {
								obj["text"] = "";
								Worker::Result(BinarizeObject(obj));
								continue;
							}
							var user_instructions = obj["instructions"] ?? "";
							if (user_instructions)
								user_instructions += "\n";

							if (use_davinci) {
								default_data["prompt"] = user_instructions + text;//this.prefix(text) + text;
								var p = ai.run(default_data);
							} else {
								default_data["messages"][0]["content"] = this.prefix("") + user_instructions;
								default_data["messages"][1]["content"] = text;
								p = ai.runChat(default_data);
							}

							p.parameters = obj;
							p.onFulfilled = sendResponse;
							p.onRejected = sendError;
							obj["step1"] = Date.now() - obj["start"];
						} catch (var exc) {
							console.warn(LOG_THIS, exc);
						}
					}
				}
			}
		} catch (var exc2) {
			console.warn(LOG_THIS, exc2);
		}
	}
}

class RecordingWorker {
	mp3(buffers) {
		var encoder = new MP3Encoder(["channels" => 1, "bitrate" => 16, "samplerate" => 8000]);
		for (var i = 0; i < length buffers; i ++)
			buffers[i] = alaw2pcm(buffers[i]);
		encoder.encode(Mix(buffers));
		encoder.close();

		return encoder.Data;
	}

	emptyData(len) {
		var data = "";
		while (length data < len)
			data += "\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5\x55\xD5";
		return data;
	}

	RecordingWorker(not_used) {
		console.log(LOG_THIS, "created MP3 worker");
		while (true) {
			if (Worker::Pending(var buffer, 10000)) {
				var obj = UnBinarizeObject(buffer);
				if (!obj)
					continue;

				var buffers = obj["buffers"];
				var max_len = obj["max"];
				if (max_len) {
					for (var i = 0; i < length buffers; i ++) {
						var delta_len = max_len - length buffers[i];
						if (delta_len > 160)
							buffers[i] = emptyData(delta_len) + buffers[i];
					}
				}
				var start = microseconds();
				WriteFile(mp3(buffers), obj["output"]);
				var delta = floor((microseconds() - start) / 1000);
				console.log(LOG_THIS, "written ${obj["output"]} in ${delta}ms");
			}
		}
	}
}

class TimeParser {
	static checkTime(now, str) {
		var arr = StrSplit(str, "-");
		if (length arr != 2)
			return false;

		var start = StrNumberSplit(arr[0], ":");

		var now_h = now["tm_hour"];
		var now_min = now["tm_min"];

		var start_h = start[0];
		var start_min = start[1];

		if (now_h < start_h)
			return false;

		if ((now_h == start_h) && (now_min < start_min))
			return false;

		var end = StrNumberSplit(arr[1], ":");

		var end_h = end[0];
		var end_min = end[1];

		if (now_h > end_h)
			return false;

		if ((now_h == end_h) && (now_min >= end_min))
			return false;

		return true;
	}

	static checkDay(now, str) {
		var day = now["tm_wday"];
		if (day == 0)
			day = 7;
		var arr = StrSplit(str, ",");
		for (var i = 0; i < length arr; i ++) {
			var e = trim(arr[i]);
			if (e) {
				var arr2 = StrNumberSplit(e, "-");
				switch (length arr2) {
					case 1:
						e = e;
						if (day == e)
							return true;
						break;
					case 2:
						var start = arr2[0];
						var end = arr2[1];
						if ((day >= start) && (day <= end))
							return true;
						break;
				}
			}
		}
		return false;
	}

	static checkPrefix(str, now) {
		var arr = StrSplit(str, ",");
		for (var i = 0; i < length arr; i ++) {
			var e = arr[i];
			var arr2 = StrSplit(e, "@");
			switch (length arr2) {
				case 1:
					if (TimeParser.checkTime(now, e))
						return true;
					break;
				case 2:
					if ((TimeParser.checkDay(now, arr2[0])) && (TimeParser.checkTime(now, arr2[1])))
						return true;
					break;
			}
		}
		return false;
	}

	static checkText(str, now = null) {
		str = trim(str);
		while ((str) && ((str[0] == "!") || (str[0] == "~")))
			str = SubStr(str, 1);

		if (str[0] != "[")
			return str;

		var end = Pos(str, "]");
		if (end <= 0)
			return str;

		var prefix = SubStr(str, 1, end - 2);
		if (prefix) {
			if (!now)
				now = localtime(time());

			if (!TimeParser.checkPrefix(prefix, now))
				return "";
		}

		return trim(SubStr(str, end));
	}

	static stripText(str) {
		str = trim(str);
		while ((str) && ((str[0] == "!") || (str[0] == "~")))
			str = SubStr(str, 1);

		if (str[0] != "[")
			return str;

		var end = Pos(str, "]");
		if (end <= 0)
			return str;

		return trim(SubStr(str, end));
	}
}

class ConversationalIVR {
	var ivr;
	var[] stt_workers;
	var[] cheap_workers;
	var[] voice_workers;
	var[] js_workers;
	var[] ai_workers;

	var trunk_dir = "./trunks/";
	var[] ivr_voice;
	var[] ivr_trees;
	var[] ivr_kb;
	var[] ivr_checksums;
	var[] ivr_timestamps;
	var[] ivr_kb_timestamps;
	var[] ivr_model_keys;
	var[] ivr_timeout;
	var[] ivr_api_trees;
	var[] ivr_limits;
	var[] ivr_queues;
	var[] ivr_blacklist;
	var[] ivr_disabled;
	var[] ivr_quota_limit;
	var[] ivr_quota;

	var ivr_api_trees_dirty;

	var OnFinish;
	var OnBranch;
	var OnAPI;
	var OnEvent;

	var OnFirewall;

	var LoopCallback;
	var OnReloadConfig;

	var OnWriteRecording;
	var OnRegistered;

	var OnAlert;

	var OnCheckDestination;

	var defaultVoice = "tts_models/en/vctk/vits";
	var[] sipUsers;

	var every_second;
	var reload_config_second;

	var[] mss_keys;
	var[] tts_keys;
	var whisper;
	var whisper_model = "";

	var openAIKey = "";
	var openAIInstructions = "";
	var openAIWorker;

	var recordingWorker;

	var forwardUDP;
	var[] music;
	
	protected var dummySession;

	protected var _sip_username = "";
	OnRegister(msg, auth, extra_headers) {
		this._sip_username = "";
		console.trace(LOG_THIS, "REGISTER ${msg.ip}:${msg.port}");
		if (auth) {
			var code = ivr.stack.CheckAuth(auth, function(username) {
				if (IsSet(this.sipUsers, username)) {
					_sip_username = username;
					return this.sipUsers[username];
				}
				return "";
			});
			if ((code != 200) && (this.OnFirewall))
				this.OnFirewall(msg);

			if ((code == 200) && (this._sip_username) && (this.OnRegistered)) {
				var msg_server = msg.ip;
				if (msg.port != 5060)
					msg_server += ":" + msg.port;

				this.OnRegistered(_sip_username, msg_server);
			}
			return code;
		}
		return 401;
	}

	static sessionTo(session) {
		if (session.sip.is_invite)
			return session.From;
		return session.To;
	}

	static sessionRemoteParty(session) {
		if (session.sip.is_invite)
			return session.To;
		return session.From;
	}

	dequeueCallbackTree(from, to, reset = true) {
		var ivr_tree;

		if (!IsSet(ivr_queues, to))
			return ivr_tree;

		var queue = ivr_queues[to];
		if (queue) {
			var na = queue["not_answered"];
			if ((na) && (IsSet(na, from))) {
				ivr_tree = na[from];
				if (reset) {
					deleteArrayElement(na, from);
					// queue["placeholders"] ++;
					// na[from] = null;
				}
			}
		}

		return ivr_tree;
	}

	sessionTree(session, var is_queue = null) {
		is_queue = false;
		var callid = session.sip.CallID;
		var ivr_tree;
		if (IsSet(ivr_api_trees, callid))
			ivr_tree = ivr_api_trees[callid];
		if (!ivr_tree) {
			var to = sessionTo(session);
			var from = sessionRemoteParty(session);
			var queue_tree = dequeueCallbackTree(from, to);
			if (queue_tree) {
				ivr_tree = queue_tree;
				is_queue = true;
			} else
				ivr_tree = ivr_trees[to];
		}
		return ivr_tree;
	}

	DoTTS(text, voice = "", session = null, append = false, level = 0) {
		var text_arr = StrSplit(text, "|");
		if (length text_arr > 0) {
			if (level >= length text_arr)
				level = (length text_arr) - 1;
			text = trim(text_arr[level]) ?? text;
		}

		var fname = VoiceWorker::key(text, voice);
		if (session) {
			if (!session.ClientData)
				session.ClientData = new IVRClientData(this, sessionTree(session, var is_queue), session, true, is_queue);
			else
				session.ClientData.count = 0;

			if (session.ClientData.debug_text)
				session.ClientData.debug_text += ";";

			session.ClientData.debug_text += "[$text]";

			if (append)
				session.Append(fname);
			else
				session.Load(fname);
		}

		return fname;
	}

	DoTTSAsync(text, voice = "", session = null, append = false, level = 1) {
		if (!voice) {
			console.warn(LOG_THIS, "using default voice");
			voice = this.defaultVoice;
		}

		var worker = this.voiceWorker(voice);
		if (!worker)
			return "";

		var text_arr = StrSplit(text, "|");
		if (length text_arr > 1)
			text = trim(text_arr[level]) ?? trim(text_arr[length text_arr - 1]);

		if (session) {
			var fname = VoiceWorker::key(text, voice);
			if (VoiceWorker::exists(text, voice))
				return DoTTS(text, voice, session, append, level);

			if (session.ClientData.debug_text)
				session.ClientData.debug_text += ";";

			session.ClientData.debug_text += "[$text]";

			worker.AddData(BinarizeObject(new VoiceWorkerData([text], [2, session.sip.CallID, fname, append])));
			return fname;
		}
		
		return "";
	}

	adjustVoice(use_voice) {
		if ((use_voice) && (tts_keys) && ((Pos(use_voice, "microsoft/") > 0) || (Pos(use_voice, "elevenlabs/") > 0))) {
			var lang_id = StrSplit(use_voice, "/")[1];
			if ((lang_id) && (IsSet(tts_keys, lang_id)))
				return tts_keys[lang_id] ?? use_voice;
		}
		return use_voice;
	}

	voice(to) {
		if (typeof to != "string") {
			if (to.sip.is_invite)
				to = to.From;
			else
				to = to.To;
		}
		if (IsSet(ivr_voice, to))
			return ivr_voice[to];
		return "";
	}

        langId(language) {
                if (!language)
                        return "";
                return StrSplit(language, "/")[1] ?? "";
        }

	ensureWords(to, voice, words) {
		if ((!to) || (!words) || (!SETTINGS_ENSURE_WORDS))
			return;

		var word_str = "\n";
		var word;
		for (var i = 0; i < length words; i ++) {
			word = words[i];
			if ((word[0] != "\$") && (word[0] != '_'))
				word_str += word + ".\n";
		}

		if (word_str) {
			var data = StrReplace(ReadFile("./scorers/$to"), "\r", "");
			if (data) {
				data = "\n" + trim(data) + "\n";
				var arr = StrSplit(data, "\n");
				for (i = 0; i < length arr; i ++) {
					word = trim(arr[i]);
					if (word)
						word_str = StrReplace(word_str, "\n" + word + "\n", "\n");
				}
				word_str = trim(word_str);
				data = trim(data);
				if ((word_str) && (data))
					word_str += "\n" + data;

				if (word_str) {
					data = "\n${trim(word_str)}\n";
					WriteFile(data, "./scorers/$to");
					var lang = langId(voice);
					AppendFile(to + ":" + lang + "\n", "./scorers/_build");
				}
			}
		}
	}

	treeExists(to) {
		return FileExists(trunk_dir + to + ".json");
	}

	loadDefaultTree(to) {
		var ivr_data;
		var ivr_tree;

		var trunk_path = trunk_dir + to + ".json";
		if (!FileExists(trunk_path)) {
			console.warn(LOG_THIS, "invalid trunk $to ($trunk_path)");
			return null;
		}

		ivr_tree = ivr_trees[to];
		var used_words;
		var try_reload_kb = false;
		if ((ivr_tree) && (time() - ivr_timestamps[to] >= 8)) {
			ivr_data = ReadFile(trunk_path);
			if (sha256(ivr_data) != ivr_checksums[to]) {
				ivr_tree = this.loadTree(to, this.fromJSON(ivr_data), null, null, true, used_words);
				ivr_checksums[to] = sha256(ivr_data);
				ivr_timestamps[to] = time();
				ivr_trees[to] = ivr_tree;
				console.info(LOG_THIS, "trunk $to reloaded");
			}
			try_reload_kb = true;
		}

		if (!ivr_tree) {
			ivr_data = ReadFile(trunk_path);
			ivr_tree = this.fromJSON(ivr_data);
			if (ivr_tree) {
				ivr_tree = this.loadTree(to, ivr_tree, null, null, true, used_words);
				if (ivr_tree) {
					ivr_checksums[to] = sha256(ivr_data);
					ivr_timestamps[to] = time();
					ivr_trees[to] = ivr_tree;
				}
				try_reload_kb = true;
			}
		}

		if (used_words)
			this.ensureWords(to, this.voice(to), used_words);

		if (try_reload_kb) {
			var trunk_kb_path = trunk_dir + to + ".kb";
			var kb_timestamp = _filelast_mod(trunk_kb_path);
			if (ivr_kb_timestamps[to] != kb_timestamp) {
				var data = ReadFile(trunk_kb_path);
				var kb = null;
				if (data) {
					kb = JSONDeserialize(data);
					if (typeof kb == "array")
						console.info(LOG_THIS, "knowledge base for $to reloaded");
					else
						kb = null;
				}
				if (kb)
					ivr_kb[to] = KeySorted(kb);
				else
					ivr_kb[to] = null;
				ivr_kb_timestamps[to] = kb_timestamp;
			}
		}

		return ivr_tree;
	}

	loadConfig(to) {
		var trunk_path = trunk_dir + to + ".json";
		if (!FileExists(trunk_path)) {
			console.warn(LOG_THIS, "invalid trunk $to ($trunk_path)");
			return;
		}

		var ivr_data = JSONDeserialize(ReadFile(trunk_path));
		if ((ivr_data) && (ivr_data["config"])) {
			var config = ivr_data["config"];
			var workers = value config["workers"];
			if (config["limit"]) {
				var limit = value config["limit"];
				ivr_limits[to] = limit;

				var workers_limit = floor(limit / 4);
				if (workers_limit > workers)
					workers = workers_limit;
			}

			if (config["model"]) {
				this.addWorker(to, config["model"], config["scorer"], workers);
				var voice = config["voice"];
				if (voice)
					ivr_voice[to] = voice;
			} else
				console.error(LOG_THIS, "\"model\" field missing");

			ivr_disabled[to] = value config["disabled"];
			ivr_quota_limit[to] = ["in" => (value config["incoming"]) * 60, "out" => (value config["outgoing"]) * 60, "sms" => value config["SMS"]];

			var ivr_timeout_message = config["timeout"];
			if ((ivr_timeout_message) && (typeof ivr_timeout_message == "string"))
				ivr_timeout[to] = ivr_timeout_message;
		}
	}

	updateQuota(to, event_type, quantity) {
		if ((!event_type) || (!quantity))
			return;
		var arr = ivr_quota[to];
		if (!arr) {
			arr = new [];
			ivr_quota[to] = arr;
		}
		arr[event_type] = quantity;
	}

	quotaExeeded(to, event_type, var resources = null) {
		resources = null;
		var limits = ivr_quota_limit[to];
		var arr = ivr_quota[to];
		if ((!arr) || (!limits))
			return false;

		var limit = limits[event_type];
		if (!limit)
			return false;

		resources = arr;
		if (arr[event_type] < limit)
			return false;

		return true;
	}

	diversion(msg) {
		if (msg) {
			var diversion = msg.Headers["diversion"];
			if (diversion) {
				diversion = this.ivr.ParseFrom2(diversion);
				if (diversion) {
					console.info(LOG_THIS, "call is diverted from $diversion");
					return "*" + diversion;
				}
			}
		}
		return null;
	}

	OnGreeting(from, to, callid, sip_message = null) {
		console.info(LOG_THIS, "call from $from to $to");
		if (("" + from) == "Anonymous")
			return null;

		var ivr_tree;

		// var divert_from = diversion(sip_message);
		// if ((divert_from) && (((IsSet(ivr_trees, divert_from)) && (ivr_trees[divert_from])) || (treeExists(divert_from))))
		// 	to = divert_from;

		var limit = ivr_limits[to];
		if ((limit) && (length this.getSessions(to) > limit)) {
			console.warn(LOG_THIS, "call limit exceeded for $to (more than $limit calls)");
			return null;
		}

		if ((ivr_blacklist) && (IsSet(ivr_blacklist, to))) {
			var to_blacklist = ivr_blacklist[to];
			if ((to_blacklist) && (IsSet(to_blacklist, from)) && ((time() - to_blacklist[from]) < 24 * 3600)) {
				console.warn(LOG_THIS, "call from $from is blacklisted");
				return null;
			}
		}

		var event_type;

		if (IsSet(ivr_api_trees, callid)) {
			ivr_tree = ivr_api_trees[callid] ?? ivr_tree;
			event_type = "out";
		} else {
			ivr_tree = this.dequeueCallbackTree(from, to, false) ?? this.loadDefaultTree(to);
			event_type = "in";
		}

		if (ivr_disabled[to]) {
			console.warn(LOG_THIS, "account $to is disabled");
			return null;
		}
		if (quotaExeeded(to, event_type)) {
			console.warn(LOG_THIS, "account $to quota exeeded");
			return null;
		}

		if (!ivr_tree) {
			console.warn(LOG_THIS, "invalid trunk $to");
			return null;
		}

		var ivr_msg = trim(ivr_tree[0]);
		if ((ivr_msg) && (ivr_msg[0] == "\$")) {
			if (Pos(ivr_msg, "\$js") == 1) {
				// to do
				return [""];
			}
		}
		var msg = trim(StrSplit(ivr_msg, "|")[0]);
		var use_voice = this.voice(to);
		if (!VoiceWorker::exists(msg, use_voice))
			return null;

		return [this.DoTTS(msg, use_voice)];
	}

	OnAnswerGreeting(from, to, callid) {
		return this.OnGreeting(to, from, callid);
	}

	OnRedirectAnswered(session, msg) {
		var sess = session.Parent;
		if ((!sess) || (!sess.UserData) || (!sess.UserData.ClientData))
			return;

		console.log(LOG_THIS, "redirect answered");
		if (!sess.UserData.ClientData.redirect_timestamp)
			sess.UserData.ClientData.redirect_timestamp = time();
	}

	OnBegin(session) {
		if (!session.ClientData)
			session.ClientData = new IVRClientData(this, sessionTree(session, var is_queue), session, true, is_queue);
		session.ClientData.answered = true;
	}

	protected _languageFromKey(key) {
		var offset = Pos(key, ".tflite");
		if (offset > 2)
			return ToLower(key[offset - 3] + key[offset - 2]);
		return "";
	}

	protected chooseWorker(session, hash) {
		if (!session)
			return null;

		if (session.ClientData.worker)
			return session.ClientData.worker;

		var to = session.To;
		if (session.sip.is_invite)
			to = session.From;

		var key;
		if (session.ClientData.worker_key) {
			key = "models/${session.ClientData.worker_key}.tflite:default/${session.ClientData.worker_key}.scorer";
			if (!IsSet(stt_workers, key))
				this.addWorker(to, "models/${session.ClientData.worker_key}.tflite", "default/${session.ClientData.worker_key}.scorer", 2, 4, false);
			if (!IsSet(stt_workers, key)) {
				console.warn(LOG_THIS, "invalid language key [$key]");
				key = null;
			} else
				console.log(LOG_THIS, "switching to [$key]");
		}
		if (!key) {
			if (!IsSet(this.ivr_model_keys, to))
				return null;

			key = this.ivr_model_keys[to];
		}
		if (!key)
			return null;

		if (!session.ClientData.default_language)
			session.ClientData.default_language = this._languageFromKey(key);

		var len;
		var workers;

		if ((cheap_workers) && (session.ClientData.ivr_branch) && (typeof session.ClientData.ivr_branch == "array")) {
			if (IsSet(cheap_workers, key))
				workers = cheap_workers[key];
			if (workers) {
				len = length workers;
				if (len) {
					var keys = GetKeys(session.ClientData.ivr_branch);
					var worker = workers[hash % len];
					if ((worker) && (keys) && (worker.UserData)) {
						var key_count = 0;
						for (var i = 0; i < length keys; i ++) {
							var k = keys[i];
							if ((k) && (k[0] != "\$") && (k != "_") && (k != "*")) {
								key_count ++;
								if ((!IsSet(worker.UserData, k)) || (!worker.UserData[k])) {
									worker = null;
									break;
								}
							}						
						}
						if ((worker) && (key_count)) {
							console.info(LOG_THIS, "enabling cheap worker");
							session.ClientData.worker = worker;
							return worker;
						}
					}
				}
			}
		}

		workers = stt_workers[key];
		if (!workers)
			return null;

		len = length workers;
		if (!len)
			return null;
		
		session.ClientData.worker = workers[hash % len];
		return session.ClientData.worker;
	}

	protected chooseJSWorker(hash, default_workers = 2) {
		var len = length js_workers;
		if (!len) {
			len = default_workers;
			for (var i = 0; i < len; i ++)
				js_workers[i] = new Worker("JSWorker", "");
		}

		return js_workers[hash % len];
	}

	protected chooseAIWorker(hash, default_workers = 1) {
		var len = length ai_workers;
		if (!len) {
			len = default_workers;
			for (var i = 0; i < len; i ++)
				ai_workers[i] = new Worker("AIWorker", "");
		}

		return ai_workers[hash % len];
	}

	loopForward() {
		if (!forwardUDP)
			return;

		try {
			var iterations;
			while (forwardUDP.HasData) {
				var buf = forwardUDP.Read(var ip, var port);
				if (buf) {
					var buf_index = Pos(buf, "\r\n\r\n") - 1;
					if (buf_index > 0) {
						var header_arr = StrSplit(SubStr(buf, 0, buf_index), "\r\n");
						var headers = new [];
						for (var i = 0; i < length header_arr; i ++){
							var e = header_arr[i];
							var pos2 = Pos(e, ":");
							if (pos2 > 0)
								headers[ToLower(trim(SubStr(e, 0, pos2 - 1)))] = trim(SubStr(e, pos2));
						}
						var id = headers["callid"];
						if (id) {
							var session = this.ivr.GetSessionById(id);
							if ((session) && (session.ClientData) && (session.ClientData.remotehost) && (session.ClientData.remotehost[0] == ip)) {
								session.ClientData.remotehost[1] = port;
								if (session.ClientData.forward) {
									var buf2 = SubStr(buf, buf_index + 4);
									if (length buf2 >= 4) {
										if (session.ClientData.forward == 1)
											session.sip.ResetBuffers();
								 		session.sip.Write(buf2, 4);
										session.ClientData.forward = 2;
									}
								}
							}
						}
					}
				}
				iterations ++;
				if (iterations >= 48)
					break;
			}
		} catch (var exc) {
			console.warn(LOG_THIS, exc);
		}
	}

	OnAudioFrame(session, var buffer, type) {
		if (!session.ClientData)
			session.ClientData = new IVRClientData(this, sessionTree(session, var is_queue), session, true, is_queue);

		// count == 2 means DTMF only
		if (session.ClientData.count == 1) {
			var stt_worker = this.chooseWorker(session, session.ClientData.hash);
			if (stt_worker)
				stt_worker.AddData(BinarizeObject(new STTWorkerData(session.sip.CallID, STT_ADDBUFFER, buffer, type)));
			else
				console.error(LOG_THIS, "no workers for ${session.To}, callid ${session.sip.CallID}");
		} else
		if (session.ClientData.forward)
			session.ClientData.forwardUDP(this, session, buffer, type, forwardUDP);
	}

	setWords(session, var is_dtmf = null) {
		var[] arr;
		var[] set_words;

		if ((!session.ClientData.ivr_branch) || ((typeof session.ClientData.ivr_branch) != "array"))
			return null;
		var keys = GetKeys(session.ClientData.ivr_branch);
		is_dtmf = true;
		var at_least_one_dtmf = false;
		for (var i = 0; i < length keys; i ++) {
			var k2 = keys[i];
			if ((!k2) || (k2[0] == "\$"))
				continue;
			if ((k2[0] == "/") && (k2[length k2 - 1] == "/")) {
				return null;
			} else {
				k2 = StrReplace(k2, ",", "|");
				k2 = StrReplace(k2, ".", "|");
				k2 = StrReplace(k2, ";", "|");
				k2 = StrReplace(k2, ":", "|");
				var subkeys = StrSplit(k2, "|");
				for (var jj = 0; jj < length subkeys; jj ++) {
					var k = trim(subkeys[jj]);
					if ((k) && (!set_words[k])) {
						arr[length arr] = k;
						switch (k) {
							case "0":
							case "1":
							case "2":
							case "3":
							case "4":
							case "5":
							case "6":
							case "7":
							case "8":
							case "9":
							// case "*":
							case "#":
								at_least_one_dtmf = true;
								break;
							default:
								is_dtmf = false;
						}
						set_words[k] = true;
					}
				}
			}

		}
		session.sip.IgnoreDTMF = !at_least_one_dtmf;
		if (arr)
			return arr;
		return null;
	}

	IVRFinished(session) {
		if ((!session) || (session.EndOnIVRFinished))
			return;

		if (!session.ClientData)
			session.ClientData = new IVRClientData(this, sessionTree(session), session, true);

		if (session.ClientData.ai_wait) {
			// please wait message, ignore event
			return;
		}

		if (session.ClientData.redirect) {
			this.Raspuns(session.sip.CallID, session.ClientData.redirect);
			return;
		}

		var branch = session.ClientData.ivr_branch;
		if ((!session.ClientData.ivr_path) && (typeof branch == "array") && (branch == session.ClientData.ivr_tree) && (!session.ClientData.js_called)) {
			var default_api = branch[0];
			if ((default_api) && (typeof default_api == "string")) {
				default_api = trim(default_api);
				if (Pos(default_api, "\$js") == 1) {
					this.Raspuns(session.sip.CallID, default_api);
					return;
				}
			}
		}

		if ((!branch) || (typeof branch == "string") || (length branch == 1)) {
			session.Close();
			return;
		}

		var session_words = this.setWords(session, var dtmf);

		if (dtmf) {
			console.info(LOG_THIS, "DTMF-only for ${session.sip.CallID}");
			session.ClientData.count = 2;
		} else {
			console.info(LOG_THIS, "start STT for ${session.sip.CallID}");
			session.ClientData.count = 1;
		}

		var stt_worker = this.chooseWorker(session, session.ClientData.hash);
		if (stt_worker)
			stt_worker.AddData(BinarizeObject(new STTWorkerData(session.sip.CallID, STT_RESET, session_words)));
		else
			console.error(LOG_THIS, "no workers for ${session.To}, callid ${session.sip.CallID}");
	}

	protected writeRecording(session) {
		if (!session.sip.RecordBuffers)
			return;
		var keys = GetKeys(session.sip.RecordBuffers);
		if (keys) {
			var folder = sessionTo(session);
			if (session.sip.is_invite)
				folder = session.From;
			_mkdir("rec/$folder");
			var[] buffers;
			var max_len = 0;
			for (var i = 0; i < length keys; i++) {
				var k = keys[i];
				if (k) {
					var buf = session.sip.RecordBuffers[k];
					if (buf) {
						buffers[length buffers] = buf;
						if (length buf > max_len)
							max_len = length buf;
					}
				}
			}
			var output_file = "rec/$folder/" + time() + "-" + session.From + "-" + session.To + ".mp3";
			if (buffers) {
				if (!recordingWorker)
					recordingWorker = new Worker("RecordingWorker", "");
				
				recordingWorker.AddData(BinarizeObject(["buffers" => buffers, "max" => max_len, "output" => output_file]));
			}
			session.StopRecording();
			session.sip.RecordBuffers = null;
			if (this.OnWriteRecording)
				this.OnWriteRecording(session, output_file);
		}
	}

	OnEnd(session, callid, code) {
		if ((session) && ((!session.UserData) || (!session.UserData.ClientData)))
			this.notifyCode(session, code);

		if ((callid) && (IsSet(ivr_api_trees, callid))) {
			deleteArrayElement(ivr_api_trees, callid);
			/* ivr_api_trees[callid] = null;
			ivr_api_trees_dirty ++;
			if (ivr_api_trees_dirty >= 8) {
				var keys = GetKeys(ivr_api_trees);
				var arr = new [];
				for (var i = 0; i < length keys; i ++) {
					var k = keys[i];
					if (k) {
						var tree = ivr_api_trees[k];
						if (tree)
							arr[k] = tree;
					}
				}
				ivr_api_trees = arr;
				console.log("cleared ${ivr_api_trees_dirty} placeholders");
				ivr_api_trees_dirty = 0;
			} */
		}
		console.log(LOG_THIS, "call id ${callid} ended with code $code");
		if ((session) && (session.UserData) && (session.UserData.ClientData) && (this.OnAPI)) {
			if ((session.UserData.ClientData.ivr_branch) && ((typeof session.UserData.ClientData.ivr_branch) == "array") && (IsSet(session.UserData.ClientData.ivr_branch, "*"))) {
				var default_api = session.UserData.ClientData.ivr_branch["*"];
				if ((default_api) && ((typeof default_api) == "array"))
					default_api = default_api[0];
				if (typeof default_api != "string")
					default_api = "";
				if (default_api) {
					if (Pos(default_api, "\$api") == 1) {
						if (session.UserData.ClientData.ivr_path)
							session.UserData.ClientData.ivr_path += "/";
						session.UserData.ClientData.ivr_path += "*[default]";
						ivr.OnAPI(session.UserData, session.UserData.ClientData.ivr_path, trim(SubStr(default_api, 4)), "tree");
						session.UserData.ClientData.ivr_branch = "";
					} else
					if (Pos(default_api, "\$js") == 1) {
						if (session.UserData.ClientData.ivr_path)
							session.UserData.ClientData.ivr_path += "/";
						session.UserData.ClientData.ivr_path += "*[default]";
						this.js(session.UserData, trim(SubStr(default_api, 3)));
						if (this.OnEvent)
							this.OnEvent(session.UserData, session.UserData.ClientData.ivr_path, "js");
						session.UserData.ClientData.ivr_branch = "";
					}
				}
			}
			if (session.UserData.ClientData.finish_api) {
				this.OnAPI(session.UserData, session.UserData.ClientData.ivr_path, session.UserData.ClientData.finish_api, "close");
				session.UserData.ClientData.finish_api = "";
			}
		}
		if ((session) && (session.UserData) && (session.UserData.ClientData) && (this.OnEvent))
			this.OnEvent(session.UserData, session.UserData.ClientData.ivr_path, "close");
		if ((session) && (session.UserData))
			this.writeRecording(session.UserData);

		this._dequeueSession(session);
	}

	static getId(session) {
		if (!session)
			return 0;
		return session.sip.CallID;
	}

	sessionById(id) {
		return this.ivr.GetSessionById(id);
	}

	api(id_session, message, tree = null) {
		if (typeof id_session == "string")
			id_session = this.ivr.GetSessionById(id_session);
		if (!id_session) {
			console.warn("session does not exists anymore");
			return false;
		}

		if ((!id_session.ClientData) || (!id_session.ClientData.api)) {
			console.warn("session is not in async api state");
			return false;
		}

		if ((id_session.ClientData.api == 2) && (!tree)) {
			id_session.EndOnIVRFinished = true;
			if (!message)
				id_session.Close();
		}

		id_session.ClientData.api = false;

		if (message)
			this.checkMessage(id_session.sip.CallID, message);

		if (tree)
			id_session.ClientData.ivr_branch = tree;

		return true;
	}

	blacklist(session) {
		var account = session.To;
		var blacklist_number = session.From;
		if (session.sip.is_invite) {
			account = session.From;
			blacklist_number = session.To;
		}

		var to_blacklist = ivr_blacklist[account];
		if (!to_blacklist) {
			to_blacklist = new [];
			ivr_blacklist[account] = to_blacklist;
		}
		to_blacklist[blacklist_number] = time();
	}

	Raspuns(id, text, append = false) {
		console.log(LOG_THIS, "[$text]");
		var session = this.ivr.GetSessionById(id);
		if (!session) {
			console.warn(LOG_THIS, "session $id does not exists");
			return;
		}

		if (text[0] == "[") {
			var pos2 = Pos(text, "]");
			if (pos2 > 1) {
				var lang_id = StrSplit(ToLower(SubStr(text, 1, pos2 - 2)), "-")[0];
				if (lang_id) {
					var current_language = session.ClientData.worker_key ?? session.ClientData.default_language;
					if ((!current_language) || (current_language != lang_id)) {
						session.ClientData.worker = null;
						session.ClientData.worker_key = lang_id;
						console.log(LOG_THIS, "session $id switching language to [$lang_id]");
					}
				}
			}		
		}

		var stt_worker = this.chooseWorker(session, session.ClientData.hash);
		if (text[0] == "\$") {
			if ((this.OnAPI) && (Pos(text, "\$api") == 1)) {
				session.ClientData.api = true;
				var action = trim(SubStr(text, 4));
				var message = this.OnAPI(session, session.ClientData.ivr_path, action, "tree");
				session.ClientData.count = 0;
				if (message) {
					this.checkMessage(id, message);
					session.ClientData.api = false;
				} else {
					// async call
					var action_lo = ToLower(action);
					if ((Pos(action_lo, "mailto:") == 1) || (Pos(action_lo, "sms:") == 1) || (Pos(action_lo, "http:") == 1) || (Pos(action_lo, "https:") == 1) || (Pos(action_lo, "set:") == 1)) {
						session.EndOnIVRFinished = true;
						session.Close();
					} else {
						session.EndOnIVRFinished = false;
					}
				}
				return;
			} else
			if (Pos(text, "\$redirect") == 1) {
				this.refer(session, trim(SubStr(text, 9)));
				session.ClientData.count = 0;
				session.EndOnIVRFinished = false;
				session.ClientData.redirect = "";
				if (this.OnEvent)
					this.OnEvent(session, session.ClientData.ivr_path, "redirect");

				if (stt_worker)
					stt_worker.AddData(BinarizeObject(new STTWorkerData(id, STT_RESET, [ ])));
				return;
			} else
			if (Pos(text, "\$js") == 1) {
				this.js(session, trim(SubStr(text, 3)));
				session.ClientData.count = 0;
				session.EndOnIVRFinished = false;
				session.ClientData.redirect = "";
				session.ClientData.js_called = true;
				if (this.OnEvent)
					this.OnEvent(session, session.ClientData.ivr_path, "js");

				if (stt_worker)
					stt_worker.AddData(BinarizeObject(new STTWorkerData(id, STT_RESET, [ ])));
				return;
			} else
			if (Pos(text, "\$reset") == 1) {
				session.EndOnIVRFinished = false;
				// reset
				session.ClientData.ivr_branch = session.ClientData.ivr_tree;
				session.ClientData.redirect = "";

				if (stt_worker)
					stt_worker.AddData(BinarizeObject(new STTWorkerData(id, STT_RESET, this.setWords(session, var dtmf))));

				if ((dtmf) || (!stt_worker))
					session.ClientData.count = 2;
				else
					session.ClientData.count = 1;

				if (this.OnEvent)
					this.OnEvent(session, session.ClientData.ivr_path, "reset");

				/* if (session.ClientData.ivr_branch) {
					text = session.ClientData.ivr_branch[0];
					if (typeof text == "string") {
						text = trim(text);
						if (text[0] != '$')
							Raspuns(id, text, append);
					}
				} */
				return;
			} else
			if (Pos(text, "\$blacklist") == 1) {
				session.ClientData.count = 0;
				session.EndOnIVRFinished = true;
				session.ClientData.redirect = "";
				blacklist(session);
				if (stt_worker)
					stt_worker.AddData(BinarizeObject(new STTWorkerData(id, STT_RESET, [ ])));
				session.Close();
				return;
			} else
			if ((Pos(text, "\$chatgpt") == 1) && (openAIWorker)) {
				if (session.ClientData.prev_branch) {
					session.ClientData.ivr_branch = session.ClientData.prev_branch;
					session.ClientData.api = 2;
				}
				session.ClientData.count = 0;
				var instructions = trim(SubStr(text, 8));
				var language_hint = "";
				if (instructions[0] == "[") {
					var pos = Pos(instructions, "]");
					if (pos > 0) {
						language_hint = SubStr(instructions, 0, pos);
						instructions = SubStr(instructions, pos);
						pos = Pos(language_hint, ",");
						if (pos > 0) {
							var please_wait_text = trim(SubStr(language_hint, pos));
							if (please_wait_text)
								please_wait_text = trim(SubStr(please_wait_text, 0, length please_wait_text - 1));
							language_hint = SubStr(language_hint, 0, pos - 1) + "]";
							if (please_wait_text)
								this.Raspuns(session.sip.CallID, language_hint + please_wait_text);
						}
					}
				}
				console.log(LOG_THIS, "chatgpt text [${session.ClientData.last_text}]");
				if (stt_worker)
					stt_worker.AddData(BinarizeObject(new STTWorkerData(id, STT_RESET, [ ])));
				if (session.ClientData.last_text) {
					openAIWorker.AddData(BinarizeObject(["id" => id, "text" => session.ClientData.last_text, "instructions" => instructions, "language_hint" => language_hint, "start" => Date.now()]));
					session.ClientData.ai_wait = true;
				} else
					session.ClientData.ai_wait = false;
				return;
			} else
			if (Pos(text, "\$ai") == 1) {
				var aiWorker = this.chooseAIWorker(session.ClientData.hash);

				if (session.ClientData.prev_branch) {
					session.ClientData.ivr_branch = session.ClientData.prev_branch;
					session.ClientData.api = 2;
				}
				session.ClientData.count = 0;
				instructions = trim(SubStr(text, 3));
				language_hint = "";
				if (instructions[0] == "[") {
					pos = Pos(instructions, "]");
					if (pos > 0) {
						language_hint = SubStr(instructions, 0, pos);
						instructions = SubStr(instructions, pos);

						pos = Pos(language_hint, ",");
						if (pos > 0) {
							please_wait_text = trim(SubStr(language_hint, pos));
							if (please_wait_text)
								please_wait_text = trim(SubStr(please_wait_text, 0, length please_wait_text - 1));
							language_hint = SubStr(language_hint, 0, pos - 1) + "]";
							if (please_wait_text)
								this.Raspuns(session.sip.CallID, language_hint + please_wait_text);
						}
					}
				}
				console.log(LOG_THIS, "ai text [${session.ClientData.last_text}]");
				if (stt_worker)
					stt_worker.AddData(BinarizeObject(new STTWorkerData(id, STT_RESET, [ ])));
				if (session.ClientData.last_text) {
					aiWorker.AddData(BinarizeObject(["id" => id, "text" => session.ClientData.last_text, "instructions" => instructions, "language_hint" => language_hint, "start" => Date.now()]));
					session.ClientData.ai_wait = true;
				} else
					session.ClientData.ai_wait = false;
				return;
			} else
			if (Pos(text, "\$close") == 1) {
				session.ClientData.count = 0;
				session.EndOnIVRFinished = true;
				session.ClientData.ivr_branch = null;
				text = trim(SubStr(text, 8));
				if (stt_worker)
					stt_worker.AddData(BinarizeObject(new STTWorkerData(id, STT_RESET, [ ])));
				if (!text) {
					session.Close();
					return;
				}
			}
		}


		session.ClientData.count = 0;

		DoTTSAsync(text, this.voice(session), session, append);
		if (stt_worker)
			stt_worker.AddData(BinarizeObject(new STTWorkerData(id, STT_RESET, this.setWords(session))));
		else
			console.error(LOG_THIS, "no workers for ${session.To}, callid ${session.sip.CallID}");
	}

	OnIdle() {
		try {
			for (var i = 0; i < length stt_workers; i ++) {
				var arr = stt_workers[i];
				for (var j = 0; j < length arr; j ++)
					this.OnIdle_worker(arr[j]);
			}
			for (i = 0; i < length cheap_workers; i ++) {
				arr = cheap_workers[i];
				for (j = 0; j < length arr; j ++)
					this.OnIdle_worker(arr[j]);
			}
			for (i = 0; i < length voice_workers; i ++)
				this.OnIdle_voiceWorker(voice_workers[i]);

			for (i = 0; i < length js_workers; i ++)
				this.OnIdle_jsWorker(js_workers[i]);

			if (this.openAIWorker)
				this.OnIdle_openAIWorker(this.openAIWorker);

			for (i = 0; i < length ai_workers; i ++)
				this.OnIdle_openAIWorker(ai_workers[i]);

			if (microseconds() - every_second >= 1000000) {
				this.ivr.stack.Reregister();
				this.every_second = microseconds();
			}
			if (this.OnReloadConfig) {
				if (time() - reload_config_second >= 48) {
					this.OnReloadConfig(this);
					this.reload_config_second = time();
				}
			}
			if (this.LoopCallback)
				this.LoopCallback();
		} catch (var exc) {
			console.error(LOG_THIS, exc);
		}
	}

	checkMessage(id, message, var append = false) {
		if (message) {
			if (typeof message == "array") {
				for (var i = 0; i < length message; i ++)
					Raspuns(id, message[i], append);
			} else
				Raspuns(id, message, append);
			append = true;
		}
	}

	tokens(text, ignore_diacritics = false) {
		var[] arr;
		text = StrReplace(text, ".", " ");
		text = StrReplace(text, ",", " ");
		text = StrReplace(text, "!", " ");
		text = StrReplace(text, "?", " ");
		text = StrReplace(text, ";", " ");
		text = StrReplace(text, "\r", " ");
		text = StrReplace(text, "\n", " ");

		var arr_text = StrSplit(text, " ");
		for (var i = 0; i < length arr_text; i ++) {
			var word = arr_text[i];
			if ((ignore_diacritics) && (word))
				word = UTF8Map(word, UTF8PROC_DECOMPOSE | UTF8PROC_STRIPMARK);
			if (word)
				arr[word] = word;
		}
		return arr;
	}

	compile(key, ignore_diacritics = false) {
		if (ignore_diacritics)
			key = UTF8Map(key, UTF8PROC_DECOMPOSE | UTF8PROC_STRIPMARK);
		if ((Pos(key, "+") > 0) || (Pos(key, "-") > 0)) {
			var[] keys;
			var last_key = "";
			for (var i = 0; i < length key; i ++) {
				var char = key[i];	
				switch (char) {
					case " ":
						if ((last_key) && (last_key != "+") && (last_key != "-")) {
							keys[length keys] = last_key;
							last_key = "";
						}
						break;
					case "+":
					case "-":
					default:
						last_key += char;
						break;
				}
			}
			if (last_key)
				keys[length keys] = last_key;
			return keys;
		}
		return [key];
	}

	match(text, text_arr, k, ignore_diacritics = false) {
		var message_understood = false;
		var key_array = compile(k, ignore_diacritics);
		for (var kk = 0; kk < length key_array; kk ++) {
			var k_text = UTF8ToLower(trim(key_array[kk]));
			if (!k_text)
				continue;

			var operator_mode = 1;
			switch (k_text[0]) {
				case "+":
					operator_mode = 1;
					k_text = SubStr(k_text, 1);
					break;
				case "-":
					operator_mode = 2;
					k_text = SubStr(k_text, 1);
					break;
			}
			if (IsSet(text_arr, k_text)) {
				if (operator_mode == 1) {
					message_understood = true;
				} else {
					message_understood = false;
					break;
				}
			} else
			if ((Pos(k_text, " ") > 0) && (Pos(text, k_text) > 0)) {
				var words = tokens(k_text);
				message_understood = true;
				for (var i = 0; i < length words; i ++) {
					var k_word = trim(words[i]);
					if (IsSet(text_arr, k_word)) {
						// to do
					} else {
						message_understood = false;
						break;
					}
				}
				if (!message_understood)
					break;
			} else {
				if (operator_mode == 1) {
					message_understood = false;
					break;
				} else
					message_understood = true;
			}
		}
		return message_understood;
	}

	TextEvent_kb(session, arr_text, text, ignore_diacritics = false) {
		var kb_data = ivr_kb[sessionTo(session)];
		if (!kb_data)
			return false;

		var keys = GetKeys(kb_data);
		if (!keys)
			return false;

		var message_understood = false;
		var k4 = "";
		var has_default = false;

		for (var j = 0; j < length keys; j ++) {
			var k2 = keys[j];
			if (!k2)
				continue;

			var k_orig = k2;

			k2 = TimeParser::checkText(k2);
			if (!k2)
				continue;
			// while ((k2) && ((k2[0] == "!") || (k2[0] == "~")))
			// 	k2 = SubStr(k2, 1);

			if ((k2[0] == "/") && (k2[length k2 - 1] == "/")) {
				var regexp_str = SubStr(k2, 1, length k2 - 2);
				var regexp = new RegExp(regexp_str);
				if (regexp.test(text)) {
					k4 = regexp_str;
					message_understood = true;
				}
			} else {
				k2 = StrReplace(k2, ",", "|");
				k2 = StrReplace(k2, ".", "|");
				k2 = StrReplace(k2, ";", "|");
				k2 = StrReplace(k2, ":", "|");

				if (ignore_diacritics)
					k2 = UTF8Map(k2, UTF8PROC_DECOMPOSE | UTF8PROC_STRIPMARK);

				var arr = StrSplit(k2, "|");

				for (var jj = 0; jj < length arr; jj ++) {
					var k = trim(arr[jj]);
					if (k) {
						if (k == "*") {
							if (ignore_diacritics)
								has_default = k_orig;
							continue;
						}
						if (match(text, arr_text, k, ignore_diacritics)) {
							message_understood = true;
							k4 = k;
						}

						if (message_understood)
							break;
					}
				}
			}
			if ((has_default) && (!message_understood) && (j == ((length keys) - 1))) {
				k4 = "*";
				message_understood = true;
				k_orig = has_default;
			}
			if (message_understood) {
				this.Raspuns(session.sip.CallID, kb_data[k_orig]);
				var current_text = "";
				if (typeof session.ClientData.ivr_branch == "array")
					current_text = session.ClientData.ivr_branch[0];
				if ((current_text) && (typeof current_text == "string")) {
					current_text = trim(current_text);
					if ((current_text) && (current_text[0] != '$'))
						this.Raspuns(session.sip.CallID, current_text, true);
				}
				return true;
			}
		}
		return false;
	}

	TextEvent(session, text, id, ignore_debug_text = false, ignore_diacritics = false, force_dtmf = false) {
		console.log(LOG_THIS, "text (id: ${id}): " + text);
		session.ClientData.worker = null;
		if ((!session.ClientData.count) && (!force_dtmf)) {
			console.warn(LOG_THIS, "dropping text [$text]");
			return;
		}

		if (!session.ClientData.ivr_branch) {
			console.warn(LOG_THIS, "no branch");
			session.ClientData.count = 0;
			session.Close();
			return;
		}
		if ((session.ClientData.last_text != text) && (text)) {
			if (session.ClientData.debug_text)
				session.ClientData.debug_text += "; ";
			if (ignore_debug_text)
				session.ClientData.debug_text += "/$text/";
			else
				session.ClientData.debug_text += text;
		}
		session.ClientData.last_text = text ?? "";

		var keys = GetKeys(KeySorted(session.ClientData.ivr_branch));
		if (!keys) {
			console.warn(LOG_THIS, "no keys");
			return;
		}
				
		var message_understood = false;
		var append = false;
		var k4 = "";
		var has_default = false;
		// var check_kb = true;

		var arr_text = tokens(text, ignore_diacritics);

		if (TextEvent_kb(session, arr_text, text, ignore_diacritics))
			return true;

		for (var j = 0; j < length keys; j ++) {
			var k2 = keys[j];
			if (!k2)
				continue;

			var k_orig = k2;

			k2 = TimeParser::checkText(k2);
			// while ((k2) && ((k2[0] == "!") || (k2[0] == "~")))
			// 	k2 = SubStr(k2, 1);

			if (!k2)
				continue;

			if ((k2[0] == "/") && (k2[length k2 - 1] == "/")) {
				var regexp_str = SubStr(k2, 1, length k2 - 2);
				var regexp = new RegExp(regexp_str);
				if (regexp.test(text)) {
					k4 = regexp_str;
					message_understood = true;
				}
			} else {
				k2 = StrReplace(k2, ",", "|");
				k2 = StrReplace(k2, ".", "|");
				k2 = StrReplace(k2, ";", "|");
				k2 = StrReplace(k2, ":", "|");
				var arr = StrSplit(k2, "|");

				for (var jj = 0; jj < length arr; jj ++) {
					var k = trim(arr[jj]);
					if (k) {
						if (k == "*") {
							if (ignore_diacritics)
								has_default = k_orig;
							continue;
						}
						if (match(text, arr_text, k, ignore_diacritics)) {
							message_understood = true;
							k4 = k;
						}

						if (message_understood)
							break;
					}
				}
			}
			if ((has_default) && (!message_understood) && (j == ((length keys) - 1))) {
				// check_kb = false;
				k4 = "*";
				message_understood = true;
				k_orig = has_default;
			}
			if (message_understood) {
				session.ClientData.ivr_path += "/" + k4;
				session.ClientData.prev_branch = session.ClientData.ivr_branch;
				session.ClientData.ivr_branch = session.ClientData.ivr_branch[k_orig];

				try {
					if (this.OnBranch)
						this.checkMessage(id, this.OnBranch(session, session.ClientData.ivr_path), append);
				} catch (var exc) {
					console.error(LOG_THIS, exc);
				}

				if (session.ClientData.ivr_branch) {
					if (typeof session.ClientData.ivr_branch == "string") {
						try {
							if ((this.OnAPI) && (session.ClientData.finish_api)) {
								this.OnAPI(session, session.ClientData.ivr_path, session.ClientData.finish_api, "close");
								session.ClientData.finish_api = "";
							}
							if (this.OnFinish)
								this.checkMessage(id, this.OnFinish(session, session.ClientData.ivr_path), append);
						} catch (exc) {
							console.error(LOG_THIS, exc);
						}
						Raspuns(id, session.ClientData.ivr_branch, append);
						session.ClientData.ivr_branch = null;
						if (session.ClientData.api)
							session.ClientData.api = 2;
						else
							session.EndOnIVRFinished = true;
					} else
					if (session.ClientData.ivr_branch[0]) {
						Raspuns(id, session.ClientData.ivr_branch[0], append);
						var key = GetKeys(session.ClientData.ivr_branch)[0];
						if (key)
							key = trim(key);
						if (length session.ClientData.ivr_branch == 1) {
							try {
								if ((this.OnAPI) && (session.ClientData.finish_api)) {
									this.OnAPI(session, session.ClientData.ivr_path, session.ClientData.finish_api, "close");
									session.ClientData.finish_api = "";
								}

								if ((this.OnFinish) && (!session.ClientData.api))
									this.checkMessage(id, this.OnFinish(session, session.ClientData.ivr_path), append);
							} catch (exc) {
								console.error(LOG_THIS, exc);
							}
							if ((key) && (key[0] == "\$"))
								session.ClientData.redirect = key;
							session.ClientData.ivr_branch = null;
							if (session.ClientData.api)
								session.ClientData.api = 2;
							else
							if (!session.ClientData.redirect)
								session.EndOnIVRFinished = true;
						} else
						if (this.OnAPI) {
							if ((key) && (Pos(key, "\$api") == 1))
								this.OnAPI(session, session.ClientData.ivr_path, trim(SubStr(key, 4)), "tree");
						}
					} else {
						try {
							if ((this.OnAPI) && (session.ClientData.finish_api)) {
								this.OnAPI(session, session.ClientData.ivr_path, session.ClientData.finish_api, "close");
								session.ClientData.finish_api = "";
							}

							if (this.OnFinish)
								this.checkMessage(id, this.OnFinish(session, session.ClientData.ivr_path), append);
						} catch (exc) {
							console.error(LOG_THIS, exc);
						}
						session.Close();
					}
				} else {
					try {
						if ((this.OnAPI) && (session.ClientData.finish_api)) {
							this.OnAPI(session, session.ClientData.ivr_path, session.ClientData.finish_api, "close");
							session.ClientData.finish_api = "";
						}

						if (this.OnFinish)
							this.checkMessage(id, this.OnFinish(session, session.ClientData.ivr_path), append);
					} catch (exc) {
						console.error(LOG_THIS, exc);
					}
					session.Close();
				}
				return true;
			}
		}
		// if (check_kb)
		// 	return TextEvent_kb(session, arr_text, text);
		if (!ignore_diacritics)
			return TextEvent(session, text, id, ignore_debug_text, true);
		return false;
	}

	timeoutMessage(session, timeout_msg, var max_timeouts) {
		if (typeof timeout_msg != "string")
			return "";
		var timeout_arr = StrSplit(timeout_msg, "|");
		if (length timeout_arr > 1) {
			max_timeouts = length timeout_arr;
			var index = session.ClientData.timeouts - 1;
			if ((index < 0) || (index >= length timeout_arr))
				index = 0;
			timeout_msg = timeout_arr[index];
			
		}
		return timeout_msg;
	}

	OnIdle_worker(stt_worker) {
		stt_worker.GetAll(var data, 0, 100);
		if (data) {
			var[] ids;
			for (var i = length data - 1; i >= 0; i --) {
				var obj = UnBinarizeObject(data[i]);
				if ((!obj) || (ids[obj.id]))
					continue;

				ids[obj.id] = true;

				var session = ivr.GetSessionById(obj.id);
				if (!session) {
					console.warn(LOG_THIS, "invalid session id ${obj.id}");
					continue;
				}

				var text = obj.buffer;

				if ((text) && (this.TextEvent(session, text, obj.id, (obj.codec == -1)))) {
					session.ClientData.timeouts = 0;
					continue;
				}

				if (obj.type == STT_TIMEDOUT) {
					session.ClientData.worker = null;
					session.ClientData.timeouts ++;
					console.log(LOG_THIS, "session ${obj.id} stt timed out");
					var max_timeouts = SETTINTS_MAX_TIMEOUTS;
					if ((typeof session.ClientData.ivr_branch == "array") && (IsSet(session.ClientData.ivr_branch, "\$timeout"))) {
						session.ClientData.prev_branch = session.ClientData.ivr_branch;
						this.TextEvent(session, this.timeoutMessage(session, session.ClientData.ivr_branch["\$timeout"], max_timeouts), obj.id);
					} else {
						var session_to = sessionTo(session);
						if (IsSet(ivr_timeout, session_to))
							Raspuns(obj.id, this.timeoutMessage(session, ivr_timeout[session_to], max_timeouts));
					}
					if (session.ClientData.timeouts >= max_timeouts) {
						session.EndOnIVRFinished = true;
						session.ClientData.count = 0;
						session.ClientData.redirect = "";
					}
				}
			}

		}
	}

	protected voiceWorker(use_voice) {
		if (!use_voice) {
			console.warn(LOG_THIS, "using default voice");
			use_voice = this.defaultVoice;
		}

		if (!use_voice)
			return null;

		var worker = voice_workers[use_voice];
		if (worker)
			return worker;

		worker = new Worker("VoiceWorker", BinarizeObject([use_voice, tts_keys]));
		voice_workers[use_voice] = worker;

		return worker;
	}

	protected fromTree(json) {
		var json_str = StrReplace(JSONSerialize(json, true), "{\"\":\"\$up\"}", "\"\$up\"");
		json_str = StrReplace(json_str, "{\"\":\"\$up1\"}", "\"\$up1\"");
		json_str = StrReplace(json_str, "{\"\":\"\$up2\"}", "\"\$up2\"");
		return JSONDeserialize(json_str);
	}

	protected fromJSON(json_str) {
		return this.fromTree(JSONDeserialize(json_str));
	}

	protected loadTree(to, ivr_tree, prev = null, var texts = null, read_config = true, var used_words = null) {
		var voice = "";
		if ((!prev) && (ivr_tree) && (read_config)) {
			var config = ivr_tree["config"];
			if (!config) {
				console.error(LOG_THIS, "\"config\" field missing");
				return null;
			}
			ivr_tree = ivr_tree["tree"];
			if (ivr_tree) {
				var workers = value config["workers"];
				if (config["limit"]) {
					var limit = value config["limit"];
					ivr_limits[to] = limit;

					var workers_limit = floor(limit / 4);
					if (workers_limit > workers)
						workers = workers_limit;
				}
				this.addWorker(to, config["model"], config["scorer"], workers);
				voice = config["voice"];
				if (voice) {
					voice = adjustVoice(voice);
					ivr_voice[to] = voice;
				}
				ivr_disabled[to] = value config["disabled"];
				ivr_quota_limit[to] = ["in" => (value config["incoming"]) * 60, "out" => (value config["outgoing"]) * 60, "sms" => value config["SMS"]];
			} else
				console.error(LOG_THIS, "\"tree\" field missing");
			var ivr_timeout_message = config["timeout"];
			if ((ivr_timeout_message) && (typeof ivr_timeout_message == "string"))
				ivr_timeout[to] = ivr_timeout_message;

			if (config["limit"])
				ivr_limits[to] = value config["limit"];
		}

		if (!ivr_tree)
			return ivr_tree;

		if (!prev)
			prev = new [];

		var first_call = false;
		if (!texts) {
			texts = new [];
			first_call = true;
		}

		if (!IsSet(ivr_voice, to))
			this.loadConfig(to);

		var use_voice = this.voice(to);
		var keys = GetKeys(ivr_tree);
		for (var i = 0; i < length ivr_tree; i ++) {
			var branch = ivr_tree[i];
			var key = keys[i];
			if (key)
				key = TimeParser::stripText(key);
			if ((key) && (key[0] != "\$") && (key != "_")) {
				var k2 = StrReplace(key, ",", "|");
				k2 = StrReplace(k2, ".", "|");
				k2 = StrReplace(k2, ";", "|");
				k2 = StrReplace(k2, ":", "|");

				var key_arr = StrSplit(k2, "|");
				if (!used_words)
					used_words = new [];
				for (var j = 0; j < length key_arr; j ++) {
					k2 = trim(key_arr[j]);
					if ((k2) && (k2 != "_") && (k2[0] != "\$") && (k2[0] != "/")) {
						switch (k2) {
							case "0":
							case "1":
							case "2":
							case "3":
							case "4":
							case "5":
							case "6":
							case "7":
							case "8":
							case "9":
							case "*":
							case "#":
								break;
							default:
								used_words[length used_words] = k2;
								break;
						}
					}
				}
			}
			switch (typeof branch) {
				case "array":
					if (prev)
						loadTree(to, branch, [ivr_tree] + prev, texts, true, used_words);
					else
						loadTree(to, branch, [ivr_tree], texts, true, used_words);
					break;
				case "string":
					if (branch[0] == "\$") {
						var arr = StrSplit(StrReplace(branch, "\t", " "), " ");
						switch (branch) {
							case "\$up":
							case "\$up1":
								if ((prev) && (prev[0]) && (keys[i]))
									ivr_tree[keys[i]] = prev[0];
								else
									console.warn(LOG_THIS, "invalid branch to go up");
								break;
							case "\$up2":
								if ((prev) && (length prev > 1) && (keys[i]))
									ivr_tree[keys[i]] = prev[1];
								else
									console.warn(LOG_THIS, "invalid branch to go up");
								break;
							case "\$include":
								if (arr[1]) {
									var trunk_path = trunk_dir + to + "." + arr[1] + ".json";
									ivr_tree[keys[i]] = this.loadTree(to, this.fromJSON(ReadFile(trunk_path)), ivr_tree, texts, true, used_words);
								} else
									console.warn(LOG_THIS, "include parameter missing");
								break;
							case "\$repeat":
								if ((prev) && (length prev > 0)) {
									var prev_tree = prev[length prev - 1];
									if (typeof prev_tree == "array") {
										var prev_keys = GetKeys(prev_tree);
										for (var j2 = 0; j2 < length prev_keys; j2 ++)
											ivr_tree[prev_keys[j2]] = prev_tree[j2];
										i = length ivr_tree;
									}
								} else
									console.warn(LOG_THIS, "invalid branch to repeat");
								break;
						}
					} else
					if (branch) {
						var branch_arr = StrSplit(branch, "|");
						for (var branch_i = 0; branch_i < length branch_arr; branch_i ++) {
							var branch_e = trim(branch_arr[branch_i]);
							if ((branch_e) && (!VoiceWorker::exists(branch_e, use_voice)))
								texts[length texts] = branch_e;
						}
					}
					break;
			}
		}

		if ((first_call) && (texts) && (length texts)) {
			var worker = this.voiceWorker(voice ?? use_voice);
			if (worker)
				worker.AddData(BinarizeObject(new VoiceWorkerData(texts)));
		}
		return ivr_tree;
	}

	OnClientRegister(registration) {
		console.log(LOG_THIS, "${registration.username}@${registration.server} registered");
	}

	OnResponseMessage(msg) {
		console.log(LOG_THIS, "${msg.ServerCode} for ${msg.Headers["call-id"]} (${msg.Headers["cseq"]}) received ");
	}

	OnDTMF(session, key) {
		if ((!session) || (!session.ClientData))
			return;

		// text event not started yet
		if (!session.ClientData.count)
			return;

		this.TextEvent(session, key, session.sip.CallID);
	}

	OnDTMFRelay(session, key) {
		if ((!session) || (!session.UserData) || (!session.UserData.ClientData))
			return;

		var force_dtmf = false;
		// text event not started yet
		if (!session.UserData.ClientData.count) {
			if (microseconds() - session.UserData.ClientData.dtmf_timestamp < 1000000)
				return;
			if ((typeof session.UserData.ClientData.ivr_branch != "array") || ((!IsSet(session.UserData.ClientData.ivr_branch, key)) && (!IsSet(session.UserData.ClientData.ivr_branch, " " + key))))
				return;
			force_dtmf = true;
			session.UserData.ClientData.dtmf_timestamp = microseconds();
		}
		this.TextEvent(session.UserData, key, session.CallID, false, false, force_dtmf);
	}

	OnTimedout(session) {
		if (!this.OnAPI)
			return;

		var clean = false;
		var ref_session = session.UserData;
		if (!ref_session) {
			var from = ivr.ParseFrom2(session.msg.Headers["from"]);
			var to = ivr.ParseFrom2(session.msg.Headers["to"]);
			ref_session = new DATASession(null, session, from, to);
			clean = true;
		}
		if (!ref_session.ClientData)
			ref_session.ClientData = new IVRClientData(this, sessionTree(ref_session), ref_session, false);

		if (ref_session.ClientData.finish_api)
			this.OnAPI(ref_session, ref_session.ClientData.ivr_path, ref_session.ClientData.finish_api, "timeout");
	
		if (clean)
			delete ref_session.ClientData;
	}

	OnAudioTimeout(session) {
		console.warn(LOG_THIS, "audio timeout event");
		var ref_session = session.UserData;
		if (!ref_session)	
			return true;
		// if ((ref_session.ClientData) && (!ref_session.ClientData.callDuration()))
		// 	return false;

		if (this.OnAlert)
			this.OnAlert(ref_session, "qos");

		return true;
	}

	notifyCode(session, code) {
		if ((!this.OnAPI) || (code < 400))
			return;

		var clean = false;
		var ref_session = session.UserData;
		if (!ref_session) {
			var from = ivr.ParseFrom2(session.msg.Headers["from"]);
			var to = ivr.ParseFrom2(session.msg.Headers["to"]);
			ref_session = new DATASession(null, session, from, to);
			clean = true;
		}
		if (!ref_session.ClientData)
			ref_session.ClientData = new IVRClientData(this, sessionTree(ref_session), ref_session, false);

		if ((ref_session.ClientData.finish_api) && ((value session.callStatus) != 200)) {
			session.callStatus = code;
			this.OnAPI(ref_session, ref_session.ClientData.ivr_path, ref_session.ClientData.finish_api, "notify");
		}
		if (clean)
			delete ref_session.ClientData;
	}

	ConversationalIVR(sip_host, sip_port = 5060, in_band_dtmf = true, mss_keys = null, tts_keys = null, use_whisper = "") {
		ivr = new IVR(sip_host, sip_port, 40);

		ivr.GreetingTo = this.OnGreeting;
		ivr.AnswerGreeting = this.OnAnswerGreeting;
		ivr.AudioFrame = this.OnAudioFrame;
		ivr.IVRFinished = this.IVRFinished;
		ivr.SessionFinished = this.OnEnd;
		ivr.Begin = this.OnBegin;

		ivr.stack.OnRegister = this.OnRegister;
		ivr.stack.OnClientRegister = this.OnClientRegister;
		ivr.stack.NATFriendly = true;
		ivr.stack.OnResponse = this.OnResponseMessage;
		ivr.stack.CacheNames = true;

		ivr.stack.OnDTMFRelay = this.OnDTMFRelay;
		if (in_band_dtmf)
			ivr.stack.OnDTMF = this.OnDTMFRelay;

		ivr.LoopCallback = this.OnIdle;

		ivr.stack.OnTimedout = this.OnTimedout;
		ivr.stack.OnAudioTimeout = this.OnAudioTimeout;
		ivr.stack.OnReferNoAnswer = this.OnReferNoAnswer;

		this.tts_keys = tts_keys ?? [ ];

		this.mss_keys = mss_keys ?? [ ];

		if (use_whisper) {
			whisper_model = use_whisper;
			whisper = new WhisperSpeech("", use_whisper, 4);
		}
	}

	addWorker(to, model, scorer = "", count = 2, max_workers = 4, set_default = true) {
		if (!model) {
			console.error("invalid model");
			return;
		}

		var count2 = _floor(sysconf(_SC_NPROCESSORS_ONLN) / 2);
		if (count2 > max_workers)
			count2 = max_workers;

		if (count < count2)
			count = count2; 

		if (!count)
			count = 2;

		var language = "";
		var auto_scorer = StrReplace(model, ".tflite", "");
		if (length auto_scorer > 2) {
			auto_scorer = auto_scorer[length auto_scorer - 2] + auto_scorer[length auto_scorer - 1];
			language = auto_scorer;
			if (!scorer)
				scorer = "default/$auto_scorer.scorer";
		}
		var key = "$model:$scorer";
		var arr = stt_workers[key];
		if (!arr) {
			arr = new [];
			stt_workers[key] = arr;
		}

		var i;

		var mss_key = null;
		var use_cheap_workers = false;
		if (mss_keys) {
			mss_key = mss_keys[language];
			if (mss_key) {
				use_cheap_workers = mss_key["cheap"];
				mss_key = BinarizeObject(mss_key);

				var arr2 = cheap_workers[key];
				if (!arr2) {
					arr2 = new [];
					cheap_workers[key] = arr2;
				}
			}
		}

		if (!mss_key) {
			for (i = 0; i < length arr; i ++) {
				var stt_worker = arr[i];
				stt_worker.AddData(BinarizeObject(new STTWorkerData("", STT_SCORER, scorer)));
			}
		}

		var whisper_data;
		if (whisper)
			whisper_data = BinarizeObject(["language" => language, "model" => whisper_model, "whisper" => whisper._handle]);

		while (length arr < count) {
			if (mss_key) {
				arr[length arr] = new Worker("MSSWorker", mss_key);
				if (use_cheap_workers) {
					if (whisper)
						arr[length arr] = new Worker("WhisperSpeechWorker", whisper_data);
					else
						arr2[length arr2] = new WorkerWithData("STTWorker", "$model:default/$auto_scorer.scorer", use_cheap_workers);
				} else {
				}
			} else {
				if (whisper)
					arr[length arr] = new Worker("WhisperSpeechWorker", whisper_data);
				else
					arr[length arr] = new Worker("STTWorker", "$model:$scorer");
			}
		}

		if (set_default)
			this.ivr_model_keys[to] = key;
	}

	addRoute(route, host, port = 5060) {
		this.ivr.stack.AddRoute(route, host, port);
	}

	getVoices(tree, voice, var arr = null) {
		if (!arr)
			arr = new [];

		switch (typeof tree) {
			case "string":
				if ((tree) && (tree[0] != '$')) {
					var tree_arr = StrSplit(tree, "|");
					if (tree_arr) {
						for (var tree_i = 0; tree_i < length tree_arr; tree_i ++) {
							var tree_e = trim(tree_arr[tree_i]);
							if (tree_e) {
								if (!VoiceWorker::exists(tree_e, voice))
									arr[length arr] = tree_e;
							}
						}
					}
				}
				break;
			case "array":
				for (var i = 0; i < length tree; i ++)
					getVoices(tree[i], voice, arr);
				break;
		}
		return arr;
	}

	callSync(who, from, tree = null, max_duration = 1800, force_identity = "") {
		if (this.OnCheckDestination)
			who = this.OnCheckDestination(who);
		var session = this.ivr.stack.Invite(who, from, 70, null, null, force_identity);
		console.log(LOG_THIS, "call $who by $from");
		if (session) {
			session.setExpires(max_duration);
			session.setCallSetupExpires(24);
			if (tree) {
				if (typeof tree == "string") {
					if (tree == "\$default")
						tree = this.loadDefaultTree(from);
					else
						tree = [tree];
				}
				ivr_api_trees[session.CallID] = tree;
				// to do
			}
			IVRClientData::checkEvent(session, who, from, this, tree, "try");
			return session.CallID;
		}
		IVRClientData::checkEvent(session, who, from, this, tree, "fail");
		console.warn(LOG_THIS, "cannot call $who");
		return false;
	}

	callSyncAll(who, from, tree = null, max_duration = 1800, force_identity = "") {
		var gateway_arr = StrSplit(who, "@");
		var gateway = "";
		if (length gateway_arr == 2) {
			who = gateway_arr[0];
			gateway = "@" + gateway_arr[1];
		}
		var arr = StrSplit(who, ",");
		var idx = 0;
		for (var i = 0; i < length arr; i ++) {
			var phone = trim(arr[i]);
			if (phone) {
				if (this.callSync(phone + gateway, from, tree, max_duration, force_identity))
					idx ++;
			}
		}
		return idx;
	}

	OnIdle_voiceWorker(worker) {
		worker.GetAll(var data, 0, 100);
		if (data) {
			for (var i = 0; i < length data; i ++) {
				var obj = UnBinarizeObject(data[i]);
				if ((!obj) || (!obj.opaque))
					continue;

				switch (obj.opaque[0]) {
					case 1:
						this.callSyncAll(obj.opaque[1], obj.opaque[2], obj.opaque[3], obj.opaque[4], obj.opaque[5]);
						break;
					case 2:
						var session = this.ivr.GetSessionById(obj.opaque[1]);
						var fname = obj.opaque[2];
						if ((session) && (fname)) {
							if (obj.opaque[3])
								session.Append(fname);
							else
								session.Load(fname);
						}
						break;
				}
			}

		}
	}

	OnIdle_jsWorker(worker) {
		worker.GetAll(var data, 0, 100);
		if (data) {
			for (var i = 0; i < length data; i ++) {
				var obj = UnBinarizeObject(data[i]);
				if (!obj)
					continue;

				var ivr_branch = obj["data"] ?? "";
				var session = this.ivr.GetSessionById(obj["id"]);
				if (!session) {
					console.log(LOG_THIS, "session does not exists anymore, creating virtual session for JS");

					if (!dummySession) {
						dummySession = new DATASession(null, __object("SIPSession"), "", "");
						dummySession.ClientData = __object("IVRClientData");
						dummySession.ClientData.ivr_path = "";
					}
					session = dummySession;
					session.sip.CallID = obj["id"];
					session.From = obj["from"] ?? "";
					session.To = obj["to"] ?? "";
					session.sip.is_invite = obj["invite"];
					// continue;
				}

				var goto_text = "";
				if ((typeof ivr_branch == "array") && (IsSet(ivr_branch, "\$goto"))) {
					var goto = ivr_branch["\$goto"];
					if ((goto) && (typeof goto == "string")) {
						if (IsSet(session.ClientData.ivr_branch, goto)) {
							session.ClientData.ivr_branch = session.ClientData.ivr_branch[goto];
							if (typeof session.ClientData.ivr_branch == "string")
								goto_text = session.ClientData.ivr_branch;
							else
								goto_text = session.ClientData.ivr_branch[0];
							if (typeof goto_text != "string")
								goto_text = "";
						}
					}
				} else
					session.ClientData.ivr_branch = ivr_branch ?? "javascript error";

				var text = "";
				if (typeof ivr_branch == "string") {
					text = ivr_branch;
					session.EndOnIVRFinished = true;
				} else
				if (typeof ivr_branch == "array") {
					text = ivr_branch[0] ?? "";
					if (this.OnAPI) {
						var k = GetKeys(ivr_branch)[0];
						if (k[0] == "\$") {
							if (Pos(k, "\$api") == 1) {
								this.OnAPI(session, session.ClientData.ivr_path, trim(SubStr(k, 4)), "tree");
								if ((!session.ClientData.finish_api) && (!session.ClientData.ivr_path))
									session.ClientData.finish_api = trim(SubStr(k, 4));
							}
						}
					}

					if (length session.ClientData.ivr_branch > 1) {
						session.EndOnIVRFinished = false;
					} else {
						session.EndOnIVRFinished = true;
					}
				}

				if (typeof text != "string") {
					text = "javascript type error";
					session.EndOnIVRFinished = true;
				}

				this.Raspuns(session.sip.CallID, text);
				if (goto_text)
					this.Raspuns(session.sip.CallID, goto_text, true);
			}
		}
	}

	js(session, call_function) {
		if (!session)
			return null;

		var worker = this.chooseJSWorker(session.ClientData.hash);
		if (worker) {
			if (session.sip.is_invite)
				call_function = StrReplace(call_function, "self", session.To);
			else
				call_function = StrReplace(call_function, "self", session.From);

			call_function = StrReplace(call_function, "path", session.ClientData.ivr_path);
			call_function = StrReplace(call_function, "timestamp", "" + session.ClientData.timestamp);
			call_function = StrReplace(call_function, "text", session.ClientData.last_text);
			call_function = StrReplace(call_function, "debug", session.ClientData.debug_text);

			return worker.AddData(BinarizeObject(["id" => session.sip.CallID, "apiCall" => call_function, "identity" => sessionTo(session), "from" => session.From, "to" => session.To, "invite" => session.sip.is_invite]));
		}
		return null;
	}

	OnIdle_openAIWorker(worker) {
		worker.GetAll(var data, 0, 100);
		if (data) {
			for (var i = 0; i < length data; i ++) {
				var obj = UnBinarizeObject(data[i]);
				if ((!obj) || (!obj["text"]))
					continue;

				var session = this.ivr.GetSessionById(obj["id"]);
				if ((!session) || (!session.ClientData)) {
					console.log(LOG_THIS, "session does not exists anymore");
					continue;
				}
				session.ClientData.ai_wait = false;
				var total_time = Date.now() - obj["start"];
				console.log(LOG_THIS, "OpenAI/AI total time $total_time (connect ${obj["step1"]}ms, ${obj["step2"]})");
				var text = obj["text"];
				if ((!text) || (text == ".") || (text == "error")) {
					session.ClientData.worker = null;
					session.ClientData.timeouts ++;
					console.log(LOG_THIS, "session ${session.sip.CallID} stt timed out (openai)");
					var max_timeouts = SETTINTS_MAX_TIMEOUTS;
					if ((typeof session.ClientData.ivr_branch == "array") && (IsSet(session.ClientData.ivr_branch, "\$timeout"))) {
						session.ClientData.prev_branch = session.ClientData.ivr_branch;
						this.TextEvent(session, this.timeoutMessage(session, session.ClientData.ivr_branch["\$timeout"], max_timeouts), session.sip.CallID);
					} else {
						var session_to = sessionTo(session);
						if (IsSet(ivr_timeout, session_to))
							Raspuns(obj.id, this.timeoutMessage(session, ivr_timeout[session_to], max_timeouts));
					}
					if (session.ClientData.timeouts >= SETTINTS_MAX_TIMEOUTS) {
						session.EndOnIVRFinished = true;
						session.ClientData.count = 0;
						session.ClientData.redirect = "";
					}
				}

				var language_hint = obj["language_hint"];
				if ((text) && (language_hint))
					text = "" + obj["language_hint"] + " " + text;

				this.Raspuns(session.sip.CallID, text, true);
			}
		}
	}

	call(who, from, tree = null, max_duration = 1800, force_identity = "", var info_resources = null) {
		var voice = "";

		this.loadConfig(from);

		if (quotaExeeded(from, "out", info_resources)) {
			console.warn(LOG_THIS, "account $from quota exeeded");
			return null;
		}

		if (IsSet(ivr_voice, from))
			voice = adjustVoice(ivr_voice[from]);
		if (!voice) {
			console.warn(LOG_THIS, "using default voice for $from");
			voice = this.defaultVoice;
		}

		// get before parsing tree to avoid stack overflow
		var texts = this.getVoices(tree, voice);

		if (typeof tree == "array") {
			var used_words;
			tree = this.loadTree(from, this.fromTree(tree), null, null, false, used_words);
			this.ensureWords(from, voice, used_words);
		}

		if ((!texts) || (length texts == 0))
			return callSyncAll(who, from, tree, max_duration, force_identity);

		var worker = voiceWorker(voice);
		if (!worker)
			return null;

		return worker.AddData(BinarizeObject(new VoiceWorkerData(texts, [1, who, from, tree, max_duration, force_identity])));
	}

	isSuspended(identity) {
		return ivr_disabled[identity];
	}

	register(username, password, sip_server, server_port = 5060) {
		this.every_second = microseconds();
		return this.ivr.stack.Register(username, password, sip_server, server_port);
	}

	unregister(username) {
		return this.ivr.stack.Unregister(username);
	}

	resetRegistrations() {
		this.ivr.stack.Registrations = new [];
	}

	refer(session, destination) {
		if (!session) {
			console.warn(LOG_THIS, "cannot refer: invalid session");
			return null;
		}

		if (session.ClientData)
			session.ClientData.referAddress = destination;

		var arr = StrSplit(destination, "|");
		if (length arr > 1)
			destination = arr[rand() % (length arr)];

		destination = StrReplace(destination, ",", "&");
		arr = StrSplit(destination, "&");
		if (length arr > 1) {
			for (var i = 0; i < length arr; i ++) {
				var destination_address = trim(arr[i]);
				if (destination_address)
					this.refer(session, destination_address);
			}
			return;
		}

		if ((Pos(destination, "@") <= 0) && (session.sip.msg) && ((session.sip.ip) || (session.sip.msg.RemoteAddress))) {
			var use_server = session.sip.ip;
			var use_port = session.sip.port;
			if ((!use_server) && (session.sip.msg.RemoteAddress))
				this.ivr.stack.ParseFullDestination(session.sip.msg.RemoteAddress, null, use_server, use_port);

			if ((!use_port) || (use_port == 5060))
				use_port = "";
			else
				use_port = ":$use_port";

			if (use_server)
				destination = destination + "@" + use_server + use_port;
		}
		console.log(LOG_THIS, "refering $destination");

		var ref_contact = "";
		this.ivr.stack.ParseFullDestination(session.sip.msg.LocalAddress, ref_contact, null, null);

		session.Expires = 1800;
		session.sip.setExpires(1800);
		session.sip.ResetBuffers();
		session.sip.Record = true;
		session.StartRecording(session.Expires);

		if (this.OnCheckDestination)
			destination = this.OnCheckDestination(destination);

		var refer_session = session.Refer(destination, ref_contact, sessionRemoteParty(session));
		if (refer_session) {
			session.sip.setMaxJitter(2);
			if (session.ClientData) {
				session.ClientData.count = 0;
				if (!session.ClientData.referTryCount)
					session.ClientData.loadMusic(this, session);
			}
		} else
			console.warn(LOG_THIS, "error refering");

		return refer_session;
	}

	OnReferNoAnswer(session) {
		var ivr_session = session.UserData;
		if ((ivr_session) && (ivr_session.ClientData)) {
			if (ivr_session.ClientData.referTryCount <= 8) {
				ivr_session.ClientData.referTryCount ++;
				if (session.ClientData.referAddress) {
					this.refer(session.UserData, session.ClientData.referAddress);
					return false;
				}
			}
		}
		return true;
	}

	getSessions(account, identity = "", notify_forward = false, notify_remote_host = null) {
		var[] sess_ids;
		var sessions = this.ivr.stack.Sessions;
		for (var i = 0; i < length sessions; i ++) {
			var session = sessions[i];
			if ((session) && (session.UserData)) {
				if ((!account) || (((session.is_invite) && (session.UserData.From == account)) || ((!session.is_invite) && (session.UserData.To == account)))) {
					var duration = 0;
					var path = "";
					var text = "";
					if (session.UserData.ClientData) {
						duration = session.UserData.ClientData.callDuration();
						path = session.UserData.ClientData.ivr_path;
						text = session.UserData.ClientData.last_text;
						if (notify_forward) {
							if (notify_remote_host)
								session.UserData.ClientData.remotehost = notify_remote_host;
							else
								session.UserData.ClientData.remotehost = null;
						}
					}
					sess_ids[session.CallID] = ["account" => account ?? identity, "isInvite" => session.is_invite, "from" => session.UserData.From, "to" => session.UserData.To, "callDuration" => duration, "path" => path, "text" => text];
				}
			} else
			if (session) {
				var from = this.ivr.ParseFrom2(session.msg.Headers["from"]);
				var to = this.ivr.ParseFrom2(session.msg.Headers["to"]);

				if ((!account) || (((session.is_invite) && (from == account)) || ((!session.is_invite) && (to == account)))) {
					var code = session.callStatus;
					if (code)
						code = "$code - ";
					sess_ids[session.CallID] = ["account" => account ?? identity, "isInvite" => session.is_invite, "from" => from, "to" => to, "callDuration" => 0, "path" => "(${code}setting up call - not answered yet)", "text" => ""];
				}
			}
		}
		return sess_ids;
	}

	protected _updateNa(identity, to, tree) {
		var ivr_queues_not_answered = ivr_queues[identity]["not_answered"];
		if (!ivr_queues_not_answered) {
			ivr_queues_not_answered = new [];
			ivr_queues[identity]["not_answered"] = ivr_queues_not_answered;
		}
		if (length ivr_queues_not_answered < SETTINGS_MAX_DEQUEUE)
			ivr_queues_not_answered[to] = tree;
	}

	protected _clearNa(identity, to) {
		var ivr_queues_not_answered = ivr_queues[identity]["not_answered"];
		if ((!ivr_queues_not_answered) || (!IsSet(ivr_queues_not_answered, to)))
			return;

		deleteArrayElement(ivr_queues_not_answered, to);

		/*
		ivr_queues_not_answered[to] = null;
		ivr_queues[identity]["placeholders"] ++;

		if (ivr_queues[identity]["placeholders"] < SETTINGS_MAX_DEQUEUE / 10)
			return;

		var arr2 = new [];
		var keys = GetKeys(ivr_queues_not_answered);
		for (var i = 0; i < length ivr_queues_not_answered; i ++) {
			var e = ivr_queues_not_answered[i];
			if (e) {
				var k = keys[i];
				if (k)
					arr2[k] = e;
			}
		}
		ivr_queues[identity]["not_answered"] = arr2;
		ivr_queues[identity]["placeholders"] = 0;
		*/
	}

	protected _dequeueAnswer(session) {
		if ((session) && (session.ClientData)) {
			var to = sessionRemoteParty(session);
			var identity = sessionTo(session);
			if ((!to) || (!identity))
				return;
			var data = JSONDeserialize(ReadFile("./queue/$identity.json"));
			for (var i = 0; i < length data; i ++) {
				var obj = data[i];
				if ((obj) && (obj["status"]) && ("" + obj["who"] == to) && (obj["text"])) {
					obj["status"] = "answered";
					obj["duration"] = _floor(session.ClientData.callDuration() / 1000);
					obj["path"] = session.ClientData.ivr_path;
					obj["timestamp"] = (new Date()).toISOString();
					obj["conversation"] = session.ClientData.debug_text ?? session.ClientData.last_text;

					WriteFile(JSONSerialize(data, true, true), "./queue/$identity.json");
					break;
				}
			}
		}

	}

	protected _dequeue(identity, check_ivr = true, route = "", to = "", session = null, var active_calls = 0) {
		identity = "" + identity;

		if ((check_ivr) && ((!IsSet(ivr_queues, identity)) || (!ivr_queues[identity])) || (ivr_disabled[identity]) || (quotaExeeded(to, "out")))
			return null;

		var data = JSONDeserialize(ReadFile("./queue/$identity.json"));
		if ((!data) || (!(length data))) {
			if (IsSet(ivr_queues, identity))
				ivr_queues[identity] = false;
			return null;
		}

		var retry_mode = 0;
		if (check_ivr) {
			retry_mode = ivr_queues[identity]["retry"];
			if ((!retry_mode) && (ivr_queues[identity]["calls"] == 0)) {
				var min_retry = 0;
				for (var i = 0; i < length data; i ++) {
					var obj = data[i];
					if (obj) {
						var call_status = obj["status"];
						if ((call_status) && (Pos(call_status, "try ") > 0)) {
							var val = value SubStr(call_status, 4);
							if ((val < min_retry) || (!min_retry))
								min_retry = val;
						}
					}
				}
				retry_mode = min_retry;
				ivr_queues[identity]["retry"] = retry_mode;
			}
			ivr_queues[identity]["calls"] ++;
		}

		if ((to) && (session) && (session.ClientData)) {
			for (i = 0; i < length data; i ++) {
				obj = data[i];
				if ((obj) && (obj["status"]) && ("" + obj["who"] == to) && (obj["text"])) {
					if (session.ClientData.answered) {
						obj["status"] = "answered";
						this._clearNa(identity, to);
					} else {
						obj["status"] = "not answered";
					}
					obj["duration"] = _floor(session.ClientData.callDuration() / 1000);
					obj["path"] = session.ClientData.ivr_path;
					obj["timestamp"] = (new Date()).toISOString();
					obj["conversation"] = session.ClientData.debug_text ?? session.ClientData.last_text;

					WriteFile(JSONSerialize(data, true, true), "./queue/$identity.json");
					break;
				}
			}
		}
		for (i = 0; i < length data; i ++) {
			obj = data[i];
			if ((obj) && ((!obj["status"]) || ((("" + obj["status"]) == "try $retry_mode"))) && (obj["who"]) && (obj["text"])) {
				obj["status"] = "try ${retry_mode + 1}";
				obj["timestamp"] = (new Date()).toISOString();
				WriteFile(JSONSerialize(data, true, true), "./queue/$identity.json");

				var tree = trim(obj["text"]);
				if (tree[0] == "{")
					tree = JSONDeserialize(tree) ?? tree;

				if (!route)
					route = ivr_queues[identity]["route"];

				if (this.call(trim(StrSplit(obj["who"], ",")[0]) + "@" + route, identity, tree, 1800, obj["as"] ?? "")) {
					active_calls ++;
					this._updateNa(identity, obj["who"], tree);
					return true;
				}
				return false;
			}
		}
		return null;
	}

	_dequeueLimit(identity, minus_one_session = false, to = "", session = null) {
		identity = "" + identity;
		var res = false;

		var limit = 1;
		if (IsSet(ivr_queues, identity)) {
			var q = ivr_queues[identity];
			if (q)
				limit = q["maxCalls"];
		}

		var session_len = length this.getSessions(identity);
		if ((session_len) && (minus_one_session))
			session_len --;

		limit -= session_len;

		var active_calls = 0;
		for (var i = 0; i < limit; i ++) {
			if (this._dequeue(identity, true, "", to, session, active_calls))
				res = true;
			else
				break;
		}
		return res;
	}

	protected _dequeueSession(session) {
		if (!session)
			return null;

		if (!session.is_invite) {
			if ((session.UserData) && (session.UserData.ClientData) && (session.UserData.ClientData.is_queue))
				this._dequeueAnswer(session.UserData);
			return null;
		}

		var identity = this.ivr.ParseFrom(session.msg.Headers["from"]);
		var to = this.ivr.ParseFrom(session.msg.Headers["to"]);
		if (!identity)
			return null;

		return this._dequeueLimit(identity, true, to, session.UserData);
	}

	queue(identity, route, max_calls, stop = false) {
		if ((!route) || (max_calls <= 0)) {
			console.warn(LOG_THIS, "no route");
			return false;
		}

		// leave one line free
		if (max_calls > 1)
			max_calls --;

		identity = "" + identity;
		var is_set = IsSet(ivr_queues, identity);
		if (stop) {
			if (is_set) {
				ivr_queues[identity] = false;
				return true;
			}
		} else {
			if ((is_set) && (ivr_queues[identity])) {
				ivr_queues[identity]["retry"] ++;
				return this._dequeueLimit(identity, false);
			}

			ivr_queues[identity] = ["route" => route, "maxCalls" => max_calls];			
			return this._dequeueLimit(identity, false);
		}
		return false;
	}

	Start(loop_callback = null) {
		if (this.openAIKey)
			this.openAIWorker = new Worker("OpenAIWorker", BinarizeObject([this.openAIKey, this.openAIInstructions]));

		try {
			this.LoopCallback = loop_callback;
			this.ivr.stack.OnAnswered = this.ivr.OnAnswered;
			this.ivr.stack.OnRedirectAnswered = this.OnRedirectAnswered;
			ivr.Start();
		} catch (var exc) {
			console.error(LOG_THIS, exc);
		}
	}
}
