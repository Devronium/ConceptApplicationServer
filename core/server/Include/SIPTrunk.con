import standard.lib.str
import standard.C.io
import standard.math.rand
import standard.lib.cripto
import standard.lib.thread
import standard.C.casts
import standard.C.time

include DTMFDetector.con
include Serializable.con
include UDPSocket.con
include Speex.con

define SIP_CODES	["100" => "Trying", "180" => "Ringing", "181" => "Call Is Being Forwarded", "182" => "Queued", "200" => "OK", "300" => "Multiple Choices", "301" => "Moved Permanently", "302" => "Moved Temporarily", "303" => "See Other", "305" => "Use Proxy", "380" => "Alternative Service", "400" => "Bad Request", "401" => "Unauthorized", "402" => "Payment Required", "403" => "Forbidden", "404" => "Not Found", "405" => "Method Not Allowed", "406" => "Not Acceptable", "407" => "Proxy Authentication Required", "408" => "Request Timeout", "409" => "Conflict", "410" => "Gone", "411" => "Length Required", "413" => "Request Entity Too Large", "414" => "Request-URI Too Large", "415" => "Unsupported Media Type", "420" => "Bad Extension", "480" => "Temporarily not available", "481" => "Call Leg/Transaction Does Not Exist", "482" => "Loop Detected", "483" => "Too Many Hops", "484" => "Address Incomplete", "485" => "Ambiguous", "486" => "Busy Here", "500" => "Internal Server Error", "501" => "Not Implemented", "502" => "Bad Gateway", "503" => "Service Unavailable", "504" => "Gateway Time-out", "505" => "SIP Version not supported", "600" => "Busy Everywhere", "603" => "Decline", "604" => "Does not exist anywhere", "606" => "Not Acceptable"]
define SIP_ALLOW	"REGISTER,INVITE,ACK,CANCEL,BYE,REFER,NOTIFY,MESSAGE"
define SIP_SUPPORTED	"replaces, 100rel, timer, tdialog"
define RTP_START_PORT	16000
define RTP_END_PORT	32000

class SIPSession {
	public var CallID;
	public var ssrc_id;
	public var UserData;

	private var Expire = 0;
	public var msg;
	private var s;
	private var sequence_number;
	private var rtp_port;
	private var rtp;
	private var d;

	var remote_port = -1;
	var remote_host = "";
	var remote_id = 0;
	var ip;
	var port;
	var packet_time;
	var started;

	var DTMFHistory = "";

	var ivr="";
	var ivr_chunk=0;

	var buf="";
	var buf_chunk=0;
	var accept_bye = false;
	var bye_set = false;
	var chunk_size;
	var timestamp;

	var[] out_stack;

	var[] Children;
	var Parent;

	var sdp_in = "";
	var sdp_out = "";

	var OnMessage;
	var OnReferError;

	var _private_data;
	var Referred;

	var Record = false;
	var RecordBuffers;

	SIPSession(s, msg, rtp_port, ip, port, chunk_size = 20, expire = 3600) {
		packet_time = microseconds();
		timestamp = RandomInteger(140, 140000) * 100;
		rtp = new UDPSocket();
		rtp.Bind(rtp_port);
		this.rtp_port = rtp_port;
		this.chunk_size = chunk_size * 1000;

		this.s = s;
		this.msg = msg;

		this.ip = ip;
		this.port = port;
		Expire = time() + expire;
		CallID = msg.Headers["call-id"];
		ssrc_id = ClsPtr(this);
		sequence_number = RandomInteger(0, 0xFFF);

		this.UpdateMedia(msg);
	}

	UpdateMedia(msg) {
		var payload = msg.Payload;
		sdp_in = msg.PayloadBlob;
		for (var i = 0; i < length payload; i++) {
			var line = payload[i];
			switch (line[0] + line[1]) {
				case "o=":
					var arr = StrSplit(SubStr(line, 2, length line), " ");
					remote_host = arr[5];
					remote_id = value arr[1];
					break;
				case "m=":
					arr = StrSplit(SubStr(line, 2, length line), " ");
					if ((arr) && (ToLower(arr[0]) == "audio"))
						remote_port = value arr[1];
					break;
			}
		}
	}

	Accept(code=200) {
		accept_bye = true;
		bye_set = true;
		var exc;
		try {
			this.s.ResponseUDP(code, msg, msg.Headers["from"], this.GetSDP());
			return true;
		} catch (exc) {
			return false;
		}
	}

	Reject(code=486) {
		var exc;
		try {
			this.s.ResponseUDP(code, msg, msg.Headers["from"]);
			if (this.s.OnEnd)
				this.s.OnEnd(this, msg, "");
			this.s.RemoveSessionByRef(this);
			return true;
		} catch (exc) {
			return false;
		}
	}

	Bye(delete_session=false) {
		var exc;
		try {
			if (accept_bye)
				var msg2 = s.Bye(msg, ip, port);
		} catch (exc) {
			// nothing
		}
		try {
			if (rtp)
				rtp.Close();
			if (delete_session) {
				if (this.s.OnEnd)
					this.s.OnEnd(this, msg2, "");
				this.s.RemoveSessionByRef(this);
			}
		} catch (exc) {
			// nothing
		}
		rtp = null;
	}

	Cancel(delete_session=false) {
		var exc;
		try {
			if (accept_bye)
				return this.Bye(delete_session);
			var msg2 = s.Cancel(msg, ip, port);
		} catch (exc) {
			// nothing
		}
		try {
			if (rtp)
				rtp.Close();
			if (delete_session) {
				if (this.s.OnEnd)
					this.s.OnEnd(this, msg2, "");
				this.s.RemoveSessionByRef(this);
			}
		} catch (exc) {
			// nothing
		}
		rtp = null;
	}

	Expired() {
		return (time() >= Expire);
	}

	Refer(address) {
		return this.s.Refer(msg, address);
	}

	RecordID() {
		return "" + ClsPtr(this);
	}

	RecordStream(srcid, var payload, type = "", profile = 8) {
		var key = RecordID() + "-" + type + profile + "-" + srcid;
		if (!RecordBuffers)
			RecordBuffers = new [];
		if (RecordBuffers[key])
			RecordBuffers[key] += payload;
		else
			RecordBuffers[key] = payload;
	}

	DumpStreams(prefix, sync_len = true) {
		var[] files;
		if (RecordBuffers) {
			var keys = GetKeys(RecordBuffers);
			if (keys) {
				var min_len = 0;
				if (sync_len) {
					for (var i = 0; i < length RecordBuffers; i++) {
						var buf = RecordBuffers[i];
						if (buf) {
							if ((!min_len) || (min_len > length buf))
								min_len = length buf;
						}
					}
				}
				for (i = 0; i < length keys; i++) {
					var k = keys[i];
					if (k) {
						buf = RecordBuffers[k];
						if (buf) {
							var fname = prefix + k + ".raw";
							files[length files] = fname;
							if ((min_len > 0) && (length buf != min_len))
								WriteFile(SubStr(buf, length buf - min_len), fname);
							else
								WriteFile(buf, fname);
						}
					}
				}
			}
			RecordBuffers = null;
		}
		return files;
	}

	SimpleRTP(payload, profile = 8) {
		var res = chr(0x80) + chr(profile);
		res += toubin(htons(sequence_number), 16);
		timestamp += length payload;
		res += toubin(htonl(timestamp), 32);
		var ssrc_id = ClsPtr(this);
		res += toubin(htonl(ssrc_id), 32);
		res += payload;
		sequence_number++;
		if (Record)
			RecordStream(ssrc_id, payload, "out-", profile);
		return res;
	}

	ParseRTP(data, var type = null) {
		type = -1;
		if (length data > 12) {
			type = tounumber(data[1], 8) & 0x7F;
			// not used: var sequence_number = ntohs(tounumber(data[2] + data[3], 16));
			// not used: 
			var ssrc_id = (tounumber(data[8] + data[9] + data[10] + data[11], 32));
			var payload = SubStr(data, 12, length data);
			if (Record)
				RecordStream(ssrc_id, payload, "in-", type);
			return payload;
		}
		return "";
	}

	GetSDP(codec = 8, extra = "") {
		var res = "v=0\r\no=somebody ${ClsPtr(this)} ${VarPtr(this)} IN IP4 ${s.localhost}\t\ns=Concept\r\nc=IN IP4 ${s.localhost}\r\nt=0 0\r\nm=audio ${rtp_port} RTP/AVP $codec\r\na=rtpmap:$codec PCMA/8000\r\n";
		if (extra)
			res += "a=$extra\r\n";
		sdp_out = res;
		return res;
	}

	finalize() {
		if (rtp)
			rtp.Close();
		for (var i = 0; i < length Children; i++) {
			var sess = Children[i];
			if (sess) {
				sess.Parent = null;
				Children[i] = null;
				this.s.RemoveSessionByRef(sess);
			}
		}
	}

	CheckAudio(var type = null) {
		if ((rtp) && (rtp.HasData))
			return ParseRTP(rtp.Read(), type);
		return "";
	}

	LoadVoice(var voice) {
		ivr = voice;
		ivr_chunk = 0;
		packet_time = microseconds();
	}

	AppendVoice(var voice) {
		ivr += voice;
	}

	Clear() {
		buf = "";
	}

	ResetBuffers() {
		buf = "";
		ivr = "";
	}

	AddChild(session) {
		if (session) {
			Children[length Children] = session;
			session.Parent = this;
		}
	}

	Write(payload, max_frames = 0) {
		if ((remote_host) && (remote_port > 0)) {
			if (max_frames > 0) {
				var max_size = chunk_size / 1000 * 8 * max_frames;
				if (length buf > max_size) {
					// jitter
					buf = "";
				}
			}
			buf+=payload;
			return length buf;
		}
		return -1;
	}

	ResetDTMF() {
		if (d) {
			d.Reset();
			DTMFHistory = "";
		}
	}

	PushFront(msg) {
		var[] new_stack;
		if (out_stack) {
			for (var i = 0; i < length out_stack; i++)
				new_stack[i + 1] = out_stack[i];
		}
		new_stack[0] = msg;
		out_stack = new_stack;

		return length new_stack;
	}

	Push(msg) {
		out_stack[length out_stack] = msg;
		return length out_stack;
	}

	ClearStack() {
		out_stack = new [];
	}

	Pop() {
		if (out_stack) {
			var[] new_stack;
			var e = out_stack[0];
			for (var i = 1; i < length out_stack; i++)
				new_stack[i - 1] = out_stack[i];
			out_stack = new_stack;
			return e;
		}
		return null;
	}

	Head() {
		if (out_stack)
			return out_stack[0];
		return null;
	}

	Iterate() {
		var exc;
		var ops = 0;
		try {
			var data = CheckAudio(var type);
			if (data) {
				ops++;
				if (s.OnAudio)
					s.OnAudio(this, data, type);
				started = true;
				if (Children) {
					for (var i = 0; i < length Children; i++) {
						var child = Children[i];
						if (child)
							child.Write(data, 10);
					}
				} else
				if (Parent) {
					Parent.Write(data, 10);
				} else
				if (s.OnDTMF) {
					if (!d) {
						d = new DTMFDetector();
						d.Threshold = 1000;
					}
					if (type == 8)
						d.AddBuffer(alaw2pcm(data));
					else
					if (type == 0)
						d.AddBuffer(ulaw2pcm(data));

					var buttons = d.Buttons;
					if ((buttons) && (buttons != DTMFHistory)) {
						DTMFHistory = buttons;
						s.OnDTMF(this, buttons[length buttons - 1]);
					}
				}
			}

			if (started) {
				if ((remote_host) && (remote_port > 0) && (rtp)) {
					var delta = uint32((microseconds() - packet_time) / chunk_size);
					if (ivr) {
						if (delta >= ivr_chunk) {
							var f_size = chunk_size / 1000 * 8;
							var d_ivr = SubStr(ivr, ivr_chunk * /*160*/ f_size, f_size);
							ivr_chunk = delta + 1;
							if (d_ivr) {
								if (this.s.OnAudioOut)
									this.s.OnAudioOut(s, d_ivr);
								rtp.Write(SimpleRTP(d_ivr), remote_host, remote_port);
							} else {
								ivr = "";
								ivr_chunk = 0;
								packet_time = microseconds();
								if (s.OnIVRFinished)
									s.OnIVRFinished(this);
							}
							ops++;
						}
					} else {
						if (delta >= buf_chunk) {
							buf_chunk = delta + 1;
							f_size = chunk_size / 1000 * 8;
							var d_buf = SubStr(buf, 0, /*160*/f_size);
							if (d_buf) {
								buf = SubStr(buf, /*160*/f_size);
								if (this.s.OnAudioOut)
									this.s.OnAudioOut(s, d_buf);
								rtp.Write(SimpleRTP(d_buf), remote_host, remote_port);
							}
							ops++;
						}
					}
				}
			} else
			if (!started) {
				if ((packet_time >= microseconds()) && (rtp)) {
					if ((remote_host) && (remote_port > 0)) {
						var str = "";
						var blocks = chunk_size / 1000 * 8 / 10;
						for (i = 0; i < blocks; i++)
							str += '\0\0\0\0\0\0\0\0\0\0';
						buf = str;
						rtp.Write(this.SimpleRTP(str), remote_host, remote_port);
					}
					packet_time = microseconds() + 19000;
					ops++;
				}
				started = true;
			}
			if (Expired())
				throw "Session expired !\n";
		} catch (exc) {
			this.s.RemoveSessionByRef(this);
			this.Bye();
			ops++;
		}
		return ops;
	}
}

class SIPMessage {
	var FromServer = false;
	var Understood = false;
	var Protocol = "SIP/2.0";
	var ServerCode = 0;
	var ServerCodeText = "";
	var Destination = "";
	var Method = "";
	var Branch = "";
	var[] Headers;
	var[] Payload;
	var PayloadBlob = "";
	var ParentCallID = "";
	var Local = false;

	GenerateResponse(code) {
		var msg = new SIPMessage();
		msg.FromServer = true;
		msg.Understood = true;
		msg.Protocol = this.Protocol;
		msg.ServerCode = code;
		var exp = SIP_CODES["" + this.ServerCode];
		if (exp)
			msg.ServerCodeText = exp;
		msg.Destination = this.Destination;
		msg.Method = this.Method;
		msg.Branch = this.Branch;
		msg.Local = true;
		return msg;
	}

	ToString() {
		var res = "";
		if (this.FromServer) {
			if ((this.ServerCode) && (this.Protocol)) {
				var exp = SIP_CODES["" + this.ServerCode];
				if (!exp)
					exp = this.ServerCodeText;
				res += this.Protocol + " " + this.ServerCode + " " + exp + "\r\n";
			} else
				return res;
		} else
		if ((this.Method) && (this.Destination)) {
			res += this.Method + " " + this.Destination;
			if (this.Protocol)
				res += " " + this.Protocol;
			res+= "\r\n";
		} else
			return res;
		var headers = this.Headers;

		if (headers) {
			var keys = GetKeys(headers);
			var len = length keys;
			for (var i = 0; i < len; i++) {
				var key = keys[i];	
				if ((key) && (key!="user-agent") && (key!="organization")) {
					var val = headers[key];
					key[0] = ToUpper(key[0]);
					if (typeof val == "array") {
						var len2 = length val;
						for (var j = 0; j < len2; j++)
							res += key + ": " + val[j] + "\r\n";							
					} else {
						if (key == "Call-id") {
							res += "User-agent: Concept4_0SIP_API/1.0\r\n";
							res += "Organization: Devronium/Concept Application Server\r\n";
							res += "Call-ID: " + val + "\r\n";
						} else
						if (key == "Cseq") {
							res += "CSeq: " + val + "\r\n";
						} else
							res += key + ": " + val + "\r\n";
					}
				}
			}
		}

		res += "\r\n";
		if (this.PayloadBlob) {
			res += this.PayloadBlob;
		} else
		if (this.Payload) {
			var p_str = "";
			var payload = this.Payload;
			len = length payload;
			for (i=0; i < len; i++) {
				var p = payload[i];
				if (p)
					p_str += p + "\r\n";
			}
			if (p_str)
				res += p_str;
		}
		return res;
	}
}

class SIPUserInfo {
	var username;
	var expires;
	var ip;
	var port;
	var contact;
	var non_routable;

	SIPUserInfo(username) {
		this.username = username;
	}

	Update(timeout) {
		if (timeout > 0)
			this.expires = time() + timeout;
		else
			this.expires = 0;
	}

	Expired() {
		if ((expires) && (time() > expires))
			return true;
		return false;
	}
}

class SIPUtils {
	static mix(files, output_file, channels = 1, format = "alaw") {
		if ((!files) || (!output_file))
			return null;
		var params = "";
		var filter = "";
		var index = 0;
		for (var i = 0; i < length files; i++) {
			var file = files[i];
			if (file) {
				params += "-f $format -ar 8000 -ac 1 -acodec pcm_$format -i \"$file\" ";
				filter += "[$index:a]";
				index++;
			}
		}
		_unlink(output_file);
		var command = "ffmpeg -loglevel fatal $params-filter_complex \"${filter}amix\" -ac $channels -qscale:a 2 \"$output_file\"";
		return _system(command);
	}
}

class SIPStack {
	var udpclientsocket;
	var localhost;
	var local_port = 5060;
	var full_host;
	var rtp_port_index = RTP_START_PORT;
	var realm = "";
	var[] Sessions;
	var[] Routes;
	var[] Users;
	var MaxTime = 3600;
	var OnDTMF;
	var OnAudio;
	var OnAudioOut;
	var OnInvite;
	var OnEnd;
	var OnRinging;
	var OnIVRFinished;
	var OnNotify;
	var OnAfterNotify;
	var OnResponse;
	var OnNotUnderstood;
	var OnRegister;
	var OnNeedAuthorization;
	var OnTextMessage;

	var OnRecv;
	var OnSend;

	var FrameSize = 20;

	var RegisterTimeout = 600;
	var NonRoutableRegisterTimeout = 5;

	SIPStack(localhost, bind_port = 5060) {
		this.localhost = localhost;
		this.local_port = bind_port;
		this.realm = localhost;
		udpclientsocket = new UDPSocket();
		udpclientsocket.Bind(bind_port);
		this.full_host = localhost;
		if (local_port != 5060)
			this.full_host += ":" + bind_port;

		RandomSeed(unpack("u32", CryptoRandom(4))[0]);
	}

	private ParseDestination(destination) {
		var arr = StrSplit(destination, ";");
		return arr[0];
	}

	public Parse(msg) {
		if (msg) {
			var orig_msg = msg;
			msg = StrReplace(msg, "\r", "");

			var arr = StrSplit(msg, "\n", true);
			var len = length arr;

			var first_line = arr[0];
			if (first_line) {
				var first_line_arr = StrSplit(first_line, " ");
				var sipid = ToUpper(first_line_arr[0]);	
				var message = new SIPMessage();
				if (sipid[0] + sipid[1] + sipid[2] == "SIP") {
					// is server response
					message.FromServer = true;
					message.ServerCode = value first_line_arr[1];
					message.ServerCodeText = "";
					for (var i = 2; i < length first_line_arr; i++) {
						if (i > 2)
							message.ServerCodeText += " ";
						message.ServerCodeText += first_line_arr[i];
					}
					message.Protocol = sipid;
				} else {
					switch (sipid) {
						case "INVITE":
						case "ACK":
						case "BYE":
						case "CANCEL":
						case "OPTIONS":
						case "REGISTER":
						case "PRACK":
						case "NOTIFY":
						case "PUBLISH":
						case "INFO":
						case "REFER":
						case "MESSAGE":
						case "UPDATE":
							if (length first_line_arr > 1) {
								message.Understood = true;	
								message.Destination = this.ParseDestination(first_line_arr[1]);
								message.Method = sipid;
								if (first_line_arr[2])
									message.Protocol = first_line_arr[2];
							}
							break;
					}
				}
				
				var headers = new [];
				var need_payload = false;
				var has_content = false;
				for (i = 1; i < len; i++) {
					var line = arr[i];
					if (line) {
						var pos = Pos(line, ":");
						if (pos > 0) {
							var name = ToLower(SubStr(line, 0, pos - 1));
							var val = trim(SubStr(line, pos, length line));
							if (headers[name]) {
								if (typeof headers[name] == "array")
									headers[name] += val;
								else
									headers[name] = [ headers[name], val ];
							} else
								headers[name] = val;

							if (name == "content-type") {
								if ((val == "application/sdp") || (val=="sdp"))
									need_payload = true;
								has_content = true;
							}
						}
					} else {
						// switch to payload
						break;
					}
				}
				var payload = new [];
				if (need_payload) {
					message.PayloadBlob = "";
					while (i < len) {
						line = arr[i++];
						if (line) {
							payload[length payload] = line;
							message.PayloadBlob += line + "\r\n";
						}
					}
				} else
				if (has_content) {
					pos = Pos(orig_msg, "\r\n\r\n");
					if (pos > 0)
						message.PayloadBlob = SubStr(orig_msg, pos + 3);
				}
				message.Headers = headers;
				message.Payload = payload;
				message.Local = false;
			}
		}
		return message;
	}

	private RandomString(len) {
		var res="";
		var characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		var rlen = length characters - 1;
		while (length res<len) {
			var c = RandomInteger(0, rlen);
			res += characters[c];
		}
		return res;
	}

	ParseAuth(auth) {
		var len = length auth;
		var in_quotes = false;

		var name = "";
		var temp = "";
		var[] res;
		var start = 0;
		if (ToLower(SubStr(auth, 0, 7)) == "digest ")
			start = 7;

		for (var i = start; i < len; i++) {
			var c = auth[i];
			if (c == '"')
				in_quotes = !in_quotes;
			else
			if (c == '=') {
				name = ToLower(trim(temp));
				temp = "";
			} else
			if ((c == ",") && (!in_quotes)) {
				if (name) {
					temp = trim(temp);
					if ((length temp >= 2) && (temp[0] == temp[length temp - 1]) && (temp[0] == '"'))
						temp = SubStr(temp, 1, length temp - 2);
					res[name] = temp;
				}
				temp = "";
			} else
				temp += c;
		}
		if ((name) && (temp)) {
			temp = trim(temp);
			if ((length temp >= 2) && (temp[0] == temp[length temp - 1]) && (temp[0] == '"'))
				temp = SubStr(temp, 1, length temp - 2);
			res[name] = temp;
		}

		return res;
	}

	private WWWAuth(auth, username, password, method, uri, var nonce) {
		var res = ParseAuth(auth);
		nonce = res["nonce"];
		if ((res["nonce"]) && (res["realm"])) {
			var alg = res["algorithm"];
			if (!alg)	
				alg = "md5";
			else
				alg = ToLower(alg);
			switch (alg) {
				case "sha1":
					var ha1 = sha1(username + ":" + res["realm"] + ":" + password);
					var ha2 = sha1(method + ":" + uri);
					var response = sha1(ha1 +":" + res["nonce"] + ":" + ha2);
					break;
				case "sha256":
					ha1 = sha256(username + ":" + res["realm"] + ":" + password);
					ha2 = sha256(method + ":" + uri);
					response = sha256(ha1 +":" + res["nonce"] + ":" + ha2);
					break;
				default:
					ha1 = md5(username + ":" + res["realm"] + ":" + password);
					ha2 = md5(method + ":" + uri);
					response = md5(ha1 +":" + res["nonce"] + ":" + ha2);
			}
			return "Digest username=\"$username\", realm=\"${res['realm']}\", nonce=\"${res['nonce']}\", uri=\"$uri\", response=\"$response\"";
		}
		return "";
	}

	private Register(username, password, server, server_port = 5060, response = null, var nonce = null, max_forwards = 70) {
		var register = new SIPMessage();
		register.Destination = "sip:" + server;
		if (server_port != 5060)
			register.Destination += ":" + server_port;
		register.Method = "REGISTER";

		var branch;
		var callid;
		var authorization = "";
		if (response) {
			branch = response.Branch;
			callid = response.Headers["call-id"];
			if ((response.ServerCode >= 400) && (response.ServerCode < 500)) {
				if (response.ServerCode != 401)
					throw "Invalid username or password";
				var auth = response.Headers["www-authenticate"];
				if (auth)
					authorization = this.WWWAuth(auth, username, password, register.Method, server, nonce);
			}
		}
		if (!branch)
			branch = "z9hG4bK" + this.RandomString(14);
		if (!callid)
			callid = this.RandomString(32) + "@" + localhost;

		register.Headers["Via"] = "SIP/2.0/UDP " + full_host + ";rport;branch=" + branch;
		var from = username + " <sip:" + username + "@" + server + ">";
		register.Headers["From"] = from;
		register.Headers["To"] = from;
		register.Headers["Max-Forwards"] = max_forwards;

		register.Headers["Call-ID"] = callid;	
		register.Headers["Allow"] = SIP_ALLOW;
		if (response)
			register.Headers["CSeq"] = "" + (value (response.Headers["cseq"]) + 1) + " " + register.Method;
		else
			register.Headers["CSeq"] = "1 " + register.Method;
		register.Headers["Contact"] = "\"$username\" <sip:" + username + "@" + full_host + ">";
		if (authorization)
			register.Headers["Authorization"] = authorization;

		register.Headers["Content-Length"] = 0;

		return register;
	}

	private TimedOutRead(t, timeout) {
		while (!t.HasData) {
			Sleep(10);
			timeout -= 10;
			if (timeout <= 0)
				return null;
		}
		var ip;
		var port;
		return this.Parse(t.Read(ip, port));
	}

	RegisterUDP(username, password, server, server_port=5060, timeout=5000) {
		try {
			var register = this.Register(username, password, server, server_port, null, var nonce);
			var local_udpclientsocket = udpclientsocket;//new UDPSocket();
			if (local_udpclientsocket.Write(register.ToString(), server, server_port) <= 0)
				return null;

			var msg = this.TimedOutRead(local_udpclientsocket, timeout);
			if ((msg) && (msg.ServerCode == 401)) {
				register = this.Register(username, password, server, server_port, msg, nonce);
				if (local_udpclientsocket.Write(register.ToString(), server, server_port) < 0)
					return null;
				var msg2 = this.TimedOutRead(local_udpclientsocket, timeout);
				if (msg2)
					msg2.PayloadBlob = nonce;
				return msg2;
			}
		} catch (var exc) {
			// silently ignore the network error
		}
		return null;
	}

	PerformUDP(method, from, destination, payload = "", payload_type = "application/sdp", max_forwards = 70, parent_msg = null, extra_headers = null, ip = "", port = 0, cache_session = null, validation_delegate = null) {
		var msg = new SIPMessage();
		destination = ParseDestination(destination);
		msg.Destination = destination;
		if ((length destination > 2) && (destination[0] == "<") && (destination[length destination - 1] == ">"))
			msg.Destination = SubStr(destination, 1, (length destination) - 2);

		msg.Method = ToUpper(method);
		if (extra_headers)
			msg.Headers = extra_headers;

		var callid;

		if (parent_msg)
			callid = parent_msg.Headers["call-id"];
		else
			callid = this.RandomString(32) + "@" + localhost;

		var server = "";
		var server_port = 0;
		var full_server = "";
		var arr = StrSplit(destination, "@");
		if (length arr == 2) {
			this.ParseHost(arr[1], server, server_port);
			if (server_port != 5060)
				full_server = server + ":" + server_port;
			else
				full_server = server;
		}

		if (parent_msg) {
			if ((msg.Method == "ACK") || (msg.Method == "CANCEL") || (msg.Method == "BYE")) {
				if ((msg.Method == "BYE") || ((parent_msg.ServerCode >= 200) && (parent_msg.ServerCode < 300))) {
					var branch = "z9hG4bK" + this.RandomString(14);
					msg.Headers["Via"] = "SIP/2.0/UDP " + full_host + ";rport;branch=" + branch;
				} else
					msg.Headers["Via"] = parent_msg.Headers["via"];
				msg.Headers["Max-Forwards"] = max_forwards;
				msg.Headers["From"] = parent_msg.Headers["from"];
				msg.Headers["To"] = parent_msg.Headers["to"];
			} else {
				// =============== to check this ===================//
				branch = "z9hG4bK" + this.RandomString(14);
				msg.Headers["Via"] = "SIP/2.0/UDP " + full_host + ";rport;branch=" + branch;
				// =================================================//
				// msg.Headers["Via"] = parent_msg.Headers["via"];

				msg.Headers["Max-Forwards"] = max_forwards;

				msg.Headers["From"] = parent_msg.Headers["to"];
				msg.Headers["To"] = parent_msg.Headers["from"];
			}
		} else {
			branch = "z9hG4bK" + this.RandomString(14);
			msg.Headers["Via"] = "SIP/2.0/UDP " + full_server + ";rport;branch=" + branch;
			msg.Headers["Max-Forwards"] = max_forwards;
			msg.Headers["From"] = from;//username + " <sip:" + username + "@" + server + ">";
			msg.Headers["To"] = destination;
		}

		msg.Headers["Call-ID"] = callid;	
		if (parent_msg) {
			var cseq = value (parent_msg.Headers["cseq"]);
			if (msg.Method == "BYE")
				cseq++;
			msg.Headers["CSeq"] = "$cseq " + msg.Method;
		} else
			msg.Headers["CSeq"] = "1 " + msg.Method;
		if ((method != "ACK") && (method != "CANCEL")) {
			msg.Headers["Contact"] = from;//"<sip:" + username + "@" + localhost + ">";
			msg.Headers["Allow"] = SIP_ALLOW;
		}
		msg.Headers["Content-Length"] = length payload;

		if ((payload_type) && (payload)) {
			msg.Headers["Content-Type"] = payload_type;
			msg.PayloadBlob = payload;
		}

		if (cache_session) {
			if (validation_delegate)
				cache_session.Push([validation_delegate, msg]);
			else
				cache_session.Push(msg);
			return msg;
		}

		try {
			if ((ip) && (port)) {
				server = ip;
				server_port = port;
			}
			if (this.OnSend)
				this.OnSend(msg, server, server_port);

			if (udpclientsocket.Write(msg.ToString(), server, server_port) <= 0)
				return null;
			return msg;
		} catch (var exc) {
			// nothing
		}
		return null;
	}

	WriteMessage(msg, ip = "", port = 0) {
		if (msg) {
			try {
				if (!port)
					port = 5060;
				if (!ip) {
					var destination;
					if (IsSet(msg.Headers, "To"))
						destination = msg.Headers["To"];
					else
						destination = msg.Headers["to"];
					destination = ParseDestination(destination);
					var server = "";
					var server_port = 0;
					var arr = StrSplit(destination, "@");
					if (length arr == 2)
						this.ParseHost(arr[1], server, server_port);
					if (server) {
						ip = server;
						port = server_port;
					}

					if (this.OnSend)
						this.OnSend(msg, ip, port);
				}

				if (udpclientsocket.Write(msg.ToString(), ip, port) <= 0)
					return false;
				return true;
			} catch (var exc) {
				// nothing
			}
		}
		return false;
	}

	ResponseUDP(code, parent_msg, destination, payload = "", payload_type = "application/sdp", max_forwards = 70, extra_headers = null, contact = "", ip = "", port = 0) {
		var msg = parent_msg.GenerateResponse(code);

		var server = "";
		var server_port = 0;
		var full_server = "";

		var via = parent_msg.Headers["via"];
		if (via) {
			this.ParseVia(parent_msg, server, server_port);
			full_server = "$server:$server_port";
		} else
			return null;


		msg.Destination = "sip:" + server;
		if (server_port != 5060)
			msg.Destination += ":" + server_port;
		msg.Method = "";
		if (extra_headers)
			msg.Headers = extra_headers;

		var branch = "z9hG4bK" + this.RandomString(14);
		var callid;

		if (parent_msg)
			callid = parent_msg.Headers["call-id"];
		else
			callid = this.RandomString(32) + "@" + localhost;

		//msg.Headers["From"] = parent_msg.Headers["from"];
		//msg.Headers["To"] = parent_msg.Headers["to"];

		msg.Headers["From"] = parent_msg.Headers["from"];//parent_msg.Destination;//username + " <sip:" + username + "@" + localhost + ">";
		msg.Headers["To"] = parent_msg.Headers["to"];//destination;
		if (parent_msg)
			msg.Headers["Via"] = parent_msg.Headers["via"];
		else
			msg.Headers["Via"] = "SIP/2.0/UDP " + full_server + ";rport;branch=" + branch;
		msg.Headers["Max-Forwards"] = max_forwards;

		msg.Headers["Call-ID"] = callid;	
		msg.Headers["Allow"] = SIP_ALLOW;
		msg.Headers["Supported"] = SIP_SUPPORTED;
		if (parent_msg) {
			var cseq = value (parent_msg.Headers["cseq"]);
			msg.Headers["CSeq"] = "$cseq " + parent_msg.Method;
		}
		if (contact)
			msg.Headers["Contact"] = contact;
		/*else
			msg.Headers["Contact"] = parent_msg.Destination;//"<sip:" + username + "@" + localhost + ">";*/

		msg.Headers["Content-Length"] = length payload;

		if ((payload_type) && (payload)) {
			msg.Headers["Content-Type"] = payload_type;
			msg.PayloadBlob = payload;
		}

		try {
			if (this.OnSend)
				this.OnSend(msg, server, server_port);

			if (udpclientsocket.Write(msg.ToString(), server, server_port) <= 0)
				return null;
			return msg;
		} catch (var exc) {
			// nothing
		}
		return null;
	}

	private Ack(msg, ip = "", port = 0, max_forwards = 70) {
		var contact = msg.Headers["contact"];
		if (!contact)
			contact = msg.Headers["from"];

		var msg2 = null;
		if (contact)
			msg2 = PerformUDP("ACK", msg.Headers["to"], contact, "", "", max_forwards, msg, null, ip, port);
		return msg2;
	}

	public ReferSimple(msg, address, ip = "", port = 0, max_forwards = 70) {
		var contact = msg.Headers["contact"];
		if (!contact)
			contact = msg.Headers["from"];

		var msg2 = null;
		if (contact)
			msg2 = PerformUDP("REFER", msg.Headers["to"], contact, "", "", max_forwards, msg, ["Refer-To" => address, "Referred-By" => contact], ip, port);

		return msg2;
	}

	public ReferProxy(msg, address, max_forwards = 70) {
		if (!msg)
			return null;

		var contact;
		if (msg.Local) {
			contact = msg.Headers["to"];
		} else {
			contact = msg.Headers["contact"];
			if (!contact)
				contact = msg.Headers["from"];
		}

		if (contact) {
			var session = this.GetSession(msg);
			if (session) {
				var child_session = this.Invite(address, contact, max_forwards);
				if (child_session) {
					child_session._private_data = session.CallID;
					session.AddChild(child_session);
					child_session.OnMessage = function(child_session, msg, parent_session) {
						var session = this.GetSessionById(child_session._private_data);
						if (!session)
							session = parent_session;
						if (session) {
							if ((msg.ServerCode >= 200) && (msg.ServerCode < 300)) {
								session.ResetBuffers();
								child_session._private_data = null;
								child_session.ResetBuffers();
								child_session.OnMessage = null;
								session.Referred = true;
							} else
							if (msg.ServerCode >= 300) {
								// busy/redirect/etc
								child_session.Cancel(true);
								child_session.OnMessage = null;
								if (session.OnReferError) {
									if (session.OnReferError(session, msg))
										return;
								}
								session.Bye(true);
							}
						}
					};
					return true;
				}
			}
		}
		return false;
	}

	public Refer(msg, address, max_forwards = 70) {
		return this.ReferProxy(msg, address, max_forwards);
	}

	public ReferHold(msg, address, ip = "", port = 0, max_forwards = 70) {
		var contact = msg.Headers["contact"];
		if (!contact)
			contact = msg.Headers["from"];

		var msg2 = null;
		if (contact) {
			var session = this.GetSession(msg);
			this.Reinvite(msg.Headers["from"], msg.Headers["to"], msg.Headers["call-id"], "", "", "sendonly");
			msg2 = PerformUDP("REFER", msg.Headers["to"], contact, "", "", 70, msg, ["Refer-To" => address, "Referred-By" => contact], "", 0, session, function(msg, new_msg) {
				if ((msg.ServerCode >= 200) && (msg.ServerCode < 300))
					return true;
				else
				if ((msg.ServerCode < 100) && (msg.ServerCode >= 300)) {
					var session = this.GetSession(msg);
					if (session)
						session.ClearStack();
				}
				return false;
			});
		}
		return msg2;
	}

	Bye(msg, ip = "", port = 0, max_forwards = 70) {
		var contact = msg.Headers["contact"];
		if (!contact)
			contact = msg.Headers["from"];

		var msg2 = null;
		if (contact)
			msg2 = PerformUDP("BYE", msg.Headers["to"], contact, "", "", max_forwards, msg, null, ip, port);
		return msg2;
	}

	Cancel(msg, ip = "", port = 0, max_forwards = 70) {
		var msg2 = null;

		var contact = msg.Headers["contact"];
		if (!contact)
			contact = msg.Headers["from"];

		if (contact)
			msg2 = PerformUDP("CANCEL", msg.Headers["to"], contact, "", "", max_forwards, msg, null, ip, port);
		return msg2;
	}

	PeekMessage(var ip, var port, max_forwards = 70) {
		try {
			if (udpclientsocket.HasData) {
				var msg = this.Parse(udpclientsocket.Read(ip, port));
				if (msg) {
					if (this.OnRecv)
						this.OnRecv(msg, ip, port);
					if (((msg.ServerCode >= 200) || (!msg.ServerCode)) && (msg.Method == "") && (!Pos(""+msg.Headers["cseq"], " ACK")))
						this.Ack(msg, ip, port, max_forwards);
					return msg;
				}
			}
		} catch (var exc) {
			// nothing
		}
		return null;
	}

	CreateSession(msg, ip, port) {
		var id = msg.Headers["call-id"];
		if (id) {
			if (Sessions[id])
				return false;
			var session = new SIPSession(this, msg, rtp_port_index++, ip, port, this.FrameSize, MaxTime);
			if (rtp_port_index > RTP_END_PORT)
				rtp_port_index = RTP_START_PORT;
			Sessions[id] = session;
			return session;
		}
		return false;
	}

	RemoveSession(msg) {
		var id = msg.Headers["call-id"];
		if (id) {
			if (IsSet(Sessions, id)) {
				var sessions = Sessions;
				var new_sessions = new [];
				var res = sessions[id];
				for (var i = 0; i < length sessions; i++) {
					var sess = sessions[i];	
					if ((sess) && (sess.CallID != id))
						new_sessions[sess.CallID] = sess;
				}
				Sessions = new_sessions;
				this.CleanSession(res);
				return res;
			}
		}
		return null;
	}

	GetSession(msg) {
		var id = msg.Headers["call-id"];
		if (id) {
			if (IsSet(Sessions, id))
				return Sessions[id];
		}
		return null;
	}

	GetSessionById(id) {
		if (id) {
			if (IsSet(Sessions, id))
				return Sessions[id];
		}
		return null;
	}

	CleanSession(session) {
		if (session) {
			var parent = session.Parent;
			if (parent) {
				session.Parent = null;
				echo "Close parent!\n";
				if (parent._private_data)
					parent.Cancel(true);
				else
					parent.Bye(true);
			}

			for (var i = 0; i < length session.Children; i++) {
				var child = session.Children[i];
				if (child._private_data)
					child.Cancel(true);
				else
					child.Bye(true);
			}
		}
	}

	RemoveSessionByRef(session) {
		if ((session) && (IsSet(Sessions, session.CallID))) {
			var sessions = Sessions;

			var new_sessions = new [];
			var id = session.CallID;
			for (var i = 0; i < length sessions; i++) {
				var sess = sessions[i];	
				if ((sess) && (sess.CallID != id))
					new_sessions[sess.CallID] = sess;
			}
			Sessions = new_sessions;
			CleanSession(session);
			return true;
		}
		return false;
	}

	TerminateSession(msg) {
		var id = msg.Headers["call-id"];
		if (id) {
			if (IsSet(Sessions, id)) {
				var sess = Sessions[id];
				if (sess) {
					sess.Bye();
					return true;
				}
			}
		}
		return false;
	}

	ParseFullDestination(destination, var user, var server, var port) {
		var arr = StrSplit(destination, "@");
		if (length arr == 2) {
			user = arr[0];
			var pos = Pos(user, ":");
			if (pos > 0) {
				user = SubStr(user, pos, length user);
			}
			this.ParseHost(arr[1], server, port);
			return true;
		}
		return false;
	}

	TextMessage(destination, username, text, content_type = "text/plain", max_forwards = 70) {
		var msg = new SIPMessage();
		msg.Method = "MESSAGE";

		var server = "";
		var server_port = 0;
		var full_server = "";

		var destination_parsed = ParseFullDestination(destination, var target_user, server, server_port);
		if (!destination_parsed)
			target_user = destination;

		if ((target_user) && (IsSet(Users, target_user))) {
			var uinfo = Users[target_user];
			if ((uinfo) && (!uinfo.Expired())) {
				if (uinfo.non_routable) {
					if (uinfo.ip)
						server = uinfo.ip;
					if (uinfo.port)
						server_port = uinfo.port;
				}
			} else
				return false;
		}
		if ((!server) || (!server_port))
			return false;

		if (server_port != 5060)
			full_server = server + ":" + server_port;
		else
			full_server = server;

		if (Pos(username, "@") > 0) {
			var user_destination = username;
			var local_server = "";
			var local_port = 0;
			ParseFullDestination(user_destination, var username2, local_server, local_port);
			username = username2;
		}

		msg.Destination = "sip:${target_user}@${full_server}";

		var branch = "z9hG4bK" + this.RandomString(14);
		var callid = this.RandomString(32) + "@" + localhost;

		msg.Headers["via"] = "SIP/2.0/UDP " + this.full_host + ";rport;branch=" + branch;
		msg.Headers["max-forwards"] = max_forwards;

		msg.Headers["from"] = "sip:" + username + "@" + this.localhost + ";tag="+this.RandomString(20);
		msg.Headers["to"] = "sip:${target_user}@${full_server}";
		msg.Headers["contact"] = "<sip:" + username + "@" + this.full_host + ">";

		msg.Headers["call-id"] = callid;
		msg.Headers["cseq"] = "1 " + msg.Method;

		msg.Headers["content-length"] = length text;
		msg.Headers["content-type"] = content_type;
		msg.PayloadBlob = text;
		try {
			if (this.OnSend)
				this.OnSend(msg, server, server_port);

			if (udpclientsocket.Write(msg.ToString(), server, server_port) <= 0)
				return false;
		} catch (var exc) {
			// nothing
		}
		return true;
	}

	Invite(destination, username, max_forwards = 70, parent_session = null, validation_delegate = null) {
		var msg = new SIPMessage();
		msg.Method = "INVITE";

		var server = "";
		var server_port = 0;
		var full_server = "";

		var destination_parsed = ParseFullDestination(destination, var target_user, server, server_port);
		if (!destination_parsed)
			target_user = destination;

		if ((target_user) && (IsSet(Users, target_user))) {
			var uinfo = Users[target_user];
			if ((uinfo) && (!uinfo.Expired())) {
				if (uinfo.non_routable) {
					if (uinfo.ip)
						server = uinfo.ip;
					if (uinfo.port)
						server_port = uinfo.port;
				}
			} else
				return null;
		}
		if ((!server) || (!server_port))
			return null;


		if (server_port != 5060)
			full_server = server + ":" + server_port;
		else
			full_server = server;

		if (Pos(username, "@") > 0) {
			var user_destination = username;
			var local_server = "";
			var local_port = 0;
			ParseFullDestination(user_destination, var username2, local_server, local_port);
			username = username2;
		}

		//msg.Destination = destination;
		msg.Destination = "sip:${target_user}@${full_server}";

		var branch = "z9hG4bK" + this.RandomString(14);
		var callid = this.RandomString(32) + "@" + localhost;

		msg.Headers["via"] = "SIP/2.0/UDP " + this.full_host + ";rport;branch=" + branch;
		msg.Headers["max-forwards"] = max_forwards;

		msg.Headers["from"] = "sip:" + username + "@" + this.localhost + ";tag="+this.RandomString(20);
		msg.Headers["to"] = "sip:${target_user}@${full_server}";//"sip:${target_user}@${localhost}";//destination;
		msg.Headers["contact"] = "<sip:" + username + "@" + this.full_host + ">";

		msg.Headers["call-id"] = callid;
		if (parent_session)
			msg.Headers["cseq"] = "3 " + msg.Method;
		else
			msg.Headers["cseq"] = "1 " + msg.Method;
		msg.Headers["supported"] = "outbound";

		msg.Headers["allow"] = SIP_ALLOW;

		msg.Headers["supported"] = SIP_SUPPORTED;
		msg.Headers["session-expires"] = "3600;refresher=uac";

		var sess = this.CreateSession(msg, server, server_port);
		if (sess) {
			var payload = sess.GetSDP();
			var payload_type = "application/sdp";
			msg.Headers["content-length"] = length payload;
			msg.Headers["content-type"] = payload_type;
			msg.PayloadBlob = payload;

			if (parent_session) {
				msg.ParentCallID = parent_session.CallID;
				if (validation_delegate)
					parent_session.Push([validation_delegate, msg]);
				else
					parent_session.Push(msg);
				return sess;
			}
			try {
				if (this.OnSend)
					this.OnSend(msg, server, server_port);

				if (udpclientsocket.Write(msg.ToString(), server, server_port) <= 0)
					return null;
				return sess;
			} catch (var exc) {
				// nothing
			}
		}
		return null;
	}

	Reinvite(destination, from, callid, branch = "", ftag = "", extra_sdp = "", sdp_payload = "", max_forwards = 70, parent_session = null, validation_delegate = null) {
		var msg = new SIPMessage();
		msg.Method = "INVITE";

		var server = "";
		var server_port = 0;
		var full_server = "";

		var destination_parsed = ParseFullDestination(destination, var target_user, server, server_port);
		if (!destination_parsed)
			target_user = destination;

		if ((target_user) && (IsSet(Users, target_user))) {
			var uinfo = Users[target_user];
			if ((uinfo) && (!uinfo.Expired())) {
				if (uinfo.non_routable) {
					if (uinfo.ip)
						server = uinfo.ip;
					if (uinfo.port)
						server_port = uinfo.port;
				}
			} else
				return null;
		}
		if ((!server) || (!server_port))
			return null;

		if (server_port != 5060)
			full_server = server + ":" + server_port;
		else
			full_server = server;

		msg.Destination = "sip:" + target_user + "@" + full_server;

		if (!branch)
		    branch = "z9hG4bK" + this.RandomString(14);

		msg.Headers["via"] = "SIP/2.0/UDP " + this.full_host + ";rport;branch=" + branch;
		msg.Headers["max-forwards"] = max_forwards;


		msg.Headers["from"] = from;
		msg.Headers["to"] = destination;
		if (ftag)
			msg.Headers["to"] += ";tag=$ftag";
		if ((extra_sdp == "sendonly") || (extra_sdp == "recvonly"))
			msg.Headers["contact"] = from + ";+sip.rendering=\"no\"";
		else
			msg.Headers["contact"] = from;

		msg.Headers["call-id"] = callid;
		msg.Headers["cseq"] = "2 " + msg.Method;
		msg.Headers["supported"] = "outbound";

		msg.Headers["allow"] = SIP_ALLOW;

		msg.Headers["supported"] = SIP_SUPPORTED;
		msg.Headers["session-expires"] = "3600;refresher=uac";
    		
		var sess = parent_session ?? GetSession(msg);
		if (sess) {
			var payload = sdp_payload ?? sess.GetSDP(8, extra_sdp);
			var payload_type = "application/sdp";
			msg.Headers["content-length"] = length payload;
			msg.Headers["content-type"] = payload_type;
			msg.PayloadBlob = payload;

			if (parent_session) {
				if (validation_delegate)
					parent_session.Push([validation_delegate, msg]);
				else
					parent_session.Push(msg);
				return msg;
			}
			try {
				if (this.OnSend)
					this.OnSend(msg, server, server_port);

				if (udpclientsocket.Write(msg.ToString(), server, server_port) <= 0)
					return null;
				return msg;
			} catch (var exc) {
				// nothing
			}
		}
		return null;
	}


	KeepAlive(ip, port) {
		try {
			if (udpclientsocket.Write("\r\n", ip, port) <= 0)
				return false;
			return true;
		} catch (var exc) {
			// nothing
		}
	}

	ParseHost(full_host, var host, var port) {
		port = 5060;
		if (full_host) {
			var arr = StrSplit(full_host, ":");
			if (length arr == 2) {
				host = arr[0];
				port = value arr[1];
			} else
				host = full_host;
			if (host)
				host = StrSplit(host, ">")[0];
		}
	}

	ParseVia(msg, var host, var port, var protocol = null) {
		if (msg) {
			var via = msg.Headers["via"];
			if (via) {
				if (typeof via == "array")
					via = via[0];
				var arr = StrSplit(via, " ");
				if (length arr >= 2) {
					protocol = arr[0];
					ParseHost(StrSplit(arr[1], ";")[0], host, port);
				}
			}
		}
	}

	RequestAuth(msg, algorithm = "md5") {
		var nonce = md5(RandomString(32));
		var extra_headers = new [];
		extra_headers["WWW-Authenticate"] = "Digest realm=\"${this.realm}\", qop=\"auth\", nonce=\"$nonce\", algorithm=$algorithm";
		return extra_headers;
	}

	CheckAuth(auth, password, nonce = "", method = "REGISTER") {
		var res = ParseAuth(auth);
		if (!nonce)
			nonce = res["nonce"];
		var username = res["username"];
		var uri = res["uri"];

		if (typeof password == "delegate")
			password = password(username);

		if ((res["nonce"]) && (res["realm"]) && (res["response"]) && (username) && (uri)) {
			var alg = res["algorithm"];
			if (!alg) {
				switch (length res["response"]) {
					case 32:
						alg = "md5";
						break;
					case 40:
						alg = "sha1";
						break;
					case 64:
					default:
						alg = "sha256";
						break;
				}
			} else
				alg = ToLower(alg);
			var qop = ToLower("" + res["qop"]);
			switch (alg) {
				case "sha1":
					var ha1 = sha1(username + ":" + res["realm"] + ":" + password);
					var ha2 = sha1(method + ":" + uri);
					if ((qop == "auth") || (qop == "auth-int"))
						var response = sha1(ha1 +":" + nonce + ":" + res["nc"] + ":" + res["cnonce"] + ":" + qop + ":" + ha2);
					else
						response = sha1(ha1 +":" + nonce + ":" + ha2);
					break;
				case "sha256":
					ha1 = sha256(username + ":" + res["realm"] + ":" + password);
					ha2 = sha256(method + ":" + uri);
					if ((qop == "auth") || (qop == "auth-int"))
						response = sha256(ha1 +":" + nonce + ":" + res["nc"] + ":" + res["cnonce"] + ":" + qop + ":" + ha2);
					else
						response = sha256(ha1 +":" + nonce + ":" + ha2);
					break;
				default:
					ha1 = md5(username + ":" + res["realm"] + ":" + password);
					ha2 = md5(method + ":" + uri);
					if ((qop == "auth") || (qop == "auth-int"))
						response = md5(ha1 +":" + nonce + ":" + res["nc"] + ":" + res["cnonce"] + ":" + qop + ":" + ha2);
					else
						response = md5(ha1 +":" + nonce + ":" + ha2);

			}
			if (response == res["response"])
				return 200;
		}
		return 401;
	}

	BuildContact(username) {
		return "<sip:" + username + "@" + full_host + ">";
	}

	NonRoutable(ip) {
		var arr = StrSplit(ip, ".");
		if (length arr >= 4) {
			switch (trim(arr[0])) {
					case "10":
						return true;
					case "192":
						if (trim(arr[1]) == "168")
							return true;
						break;
					case "172":
						var b = value arr[1];
						if ((b >= 16) && (b <= 31))
							return true;
						break;
			}
		} else
		if (length ip > 3) {
			// ipv6 ?
			if (ip[0] == "[")
				ip++;
			ip = ToLower(trim(ip));
			if (ip[0] + ip[1] == "fd")
				return true;
		}
		return false;
	}

	ContactNonRoutable(headers) {
		if (!headers)
			return false;
		var route = "";
		if (IsSet(headers, "contact"))
			route = headers["contact"];
		if ((!route) && (IsSet(headers, "via")))
			route = headers["via"];
		if (typeof route == "array")
			route = route[0];

		if (route) {
			var arr = StrSplit(route, "@");
			var ip = arr[1];
			if (ip)
				return NonRoutable(ip);
		}
		return false;
	}

	Iterate() {
		var sessions = this.Sessions;
		var ops = 0;
		for (var i = 0; i < length sessions; i++) {
			var session = sessions[i];
			if (session)
				ops += session.Iterate();
		}
		var msg = this.PeekMessage(var ip, var port);
		if (msg) {
			var routable_ip = "";
			var routable_port = 0;
			ops++;
			if (this.OnNeedAuthorization) {
				var auth_code = this.OnNeedAuthorization(msg);
				if (auth_code) {
					this.ResponseUDP(auth_code, msg, msg.Headers["from"]);
					return;
				}
			}
			var extra_headers;
			switch (msg.Method) {
				case "INVITE":
					var sess = this.CreateSession(msg, ip, port);
					if (sess) {
						this.ResponseUDP(180, msg, msg.Headers["from"]);

						if (this.OnInvite)
							this.OnInvite(sess, msg);
					} else {
						echo "Cannot create session\n";
						this.ResponseUDP(430, msg, msg.Headers["from"]);
					}
					break;
				case "REGISTER":
					var register_response = 401;
					var auth = "";
					if (IsSet(msg.Headers, "authorization"))
						auth = msg.Headers["authorization"];
					if (!auth)
						extra_headers = RequestAuth(msg);

					if (this.OnRegister)
						register_response = this.OnRegister(msg, auth, extra_headers);
					var contact = "";
					if ((register_response == 200) && (auth)) {
						var pauth = ParseAuth(auth);
						var username = pauth["username"];
						if (username) {
							var uinfo = Users[username];
							if (!uinfo) {
								uinfo = new SIPUserInfo(username);
								Users[username] = uinfo;
							}
							var non_routable = this.ContactNonRoutable(msg.Headers);
							uinfo.non_routable = non_routable;
							if ((RegisterTimeout > 0) || (NonRoutableRegisterTimeout > 0)) {
								var timeout = RegisterTimeout;
								if (non_routable) {
									timeout = NonRoutableRegisterTimeout;
									routable_ip = ip;
									routable_port = port;
								}
								if (timeout > 0) {
									if (username)
										contact = BuildContact(username) + ";" + "expires=" + timeout;
								}
								uinfo.Update(timeout);
							}
							uinfo.ip = routable_ip;
							uinfo.port = routable_port;
							uinfo.contact = msg.Headers["contact"];
						}
					}
					this.ResponseUDP(register_response, msg, msg.Headers["from"], "", "", 70, extra_headers, contact, routable_ip, routable_port);
					break;
				case "NOTIFY":
					// message
					var code = 200;
					if (this.OnNotify)
						code = this.OnNotify(msg);
					this.ResponseUDP(code, msg, msg.Headers["from"]);
					if (this.OnAfterNotify)
						this.OnAfterNotify(msg);
					break;
				case "CANCEL":
				case "BYE":
					sess = this.RemoveSession(msg);
					if (sess) {
						this.ResponseUDP(200, msg, msg.Headers["from"]);
						if (this.OnEnd)
							this.OnEnd(sess, msg, msg.Headers["reason"]);
					} else {
						// Cannot remove non-existing session;
						this.ResponseUDP(481, msg, msg.Headers["from"]);
					}
					break;
				case "ACK":
					// ignore it
					break;
				case "MESSAGE":
					var message_response = 202;
					if (this.OnTextMessage) {
						message_response = this.OnTextMessage(msg);
						if (!message_response)
							message_response = 200;
					}
					this.ResponseUDP(message_response, msg, msg.Headers["from"], "", "", 70, extra_headers);
					break;
				default:
					var parent = null;
					if (msg.FromServer) {
						var ctype = msg.Headers["content-type"];
						sess = null;
						if ((ctype) && (ToLower(ctype) == "application/sdp") && (msg.Payload)) {
							sess = GetSession(msg);
							if (sess)
								sess.UpdateMedia(msg);
						}

						if ((msg.ServerCode >= 200) && (msg.ServerCode < 300)) {
							if (!sess)
								sess = GetSession(msg);
							if ((sess) && (!session.bye_set)) {
								sess.bye_set = true;
								sess.accept_bye = true;
							}
						}

						if (this.OnResponse)
							this.OnResponse(msg);

						if (this.OnRinging) {
							if ((msg.ServerCode == 180) || (msg.ServerCode == 183)) {
								if (!sess)
									sess = GetSession(msg);
								if (sess)
									this.OnRinging(sess, msg);
							}
						}
						if (msg.ServerCode >= 400) {
							if (!sess)
								sess = GetSession(msg);

							if (sess) {
								parent = sess.Parent;
								sess.Bye();
								this.RemoveSessionByRef(sess);
								if (this.OnEnd)
									this.OnEnd(sess, msg, msg.Headers["reason"] ?? "");
							}
						}
					} else {
						if (this.OnNotUnderstood)
							this.OnNotUnderstood(msg);
					}
					if (!sess)
						sess = GetSession(msg);

					if ((sess) && (sess.OnMessage))
						sess.OnMessage(sess, msg, parent);

					if (sess)
						var popped_msg = sess.Head();
					if (popped_msg) {
						if (typeof popped_msg == "array") {
							var start = 0;
							var validation_delegate = null;
							if (typeof popped_msg[0] == "delegate") {
								validation_delegate = popped_msg[0];
								start = 1;
							}
							for (var i2 = start; i2 < length popped_msg; i2++) {
								var popped_msg_i = popped_msg[i2];
								if (popped_msg_i) {
									if ((!validation_delegate) || (validation_delegate(msg, popped_msg_i))) {
										sess.Pop();
										WriteMessage(popped_msg_i);
									}
								}
							}
						} else {
							sess.Pop();
							WriteMessage(popped_msg);
						}
					}
					break;
			}
		}
		ops++;
	}
}
