import standard.lib.str
import standard.C.io
import standard.math.rand
import standard.lib.cripto
import standard.lib.thread
import standard.C.casts
import standard.C.time
import standard.coding.base64

include DTMFDetector.con
include Serializable.con
include UDPSocket.con
include TCPSocket.con
include TLSESocket.con
include Speex.con

define SIP_CODES	["100" => "Trying", "180" => "Ringing", "181" => "Call Is Being Forwarded", "182" => "Queued", "200" => "OK", "300" => "Multiple Choices", "301" => "Moved Permanently", "302" => "Moved Temporarily", "303" => "See Other", "305" => "Use Proxy", "380" => "Alternative Service", "400" => "Bad Request", "401" => "Unauthorized", "402" => "Payment Required", "403" => "Forbidden", "404" => "Not Found", "405" => "Method Not Allowed", "406" => "Not Acceptable", "407" => "Proxy Authentication Required", "408" => "Request Timeout", "409" => "Conflict", "410" => "Gone", "411" => "Length Required", "413" => "Request Entity Too Large", "414" => "Request-URI Too Large", "415" => "Unsupported Media Type", "420" => "Bad Extension", "480" => "Temporarily not available", "481" => "Call Leg/Transaction Does Not Exist", "482" => "Loop Detected", "483" => "Too Many Hops", "484" => "Address Incomplete", "485" => "Ambiguous", "486" => "Busy Here", "500" => "Internal Server Error", "501" => "Not Implemented", "502" => "Bad Gateway", "503" => "Service Unavailable", "504" => "Gateway Time-out", "505" => "SIP Version not supported", "600" => "Busy Everywhere", "603" => "Decline", "604" => "Does not exist anywhere", "606" => "Not Acceptable"]
define SIP_ALLOW	"REGISTER,INVITE,ACK,CANCEL,BYE,REFER,NOTIFY,MESSAGE"
define SIP_SUPPORTED	"replaces, 100rel, timer, tdialog"
define RTP_START_PORT	16000
define RTP_END_PORT	32000

define SIP_TRANSPORT_UDP	0
define SIP_TRANSPORT_TCP	1
define SIP_TRANSPORT_TLS	2

class SRTPContext {
	var srtp_in;
	var srtp_out;

	private Init(var rtp, key_data, tag_size = 32) {
		if (rtp)
			SRTPDone(rtp);
		rtp = SRTPInit(key_data, tag_size);
		return (rtp != 0);
	}

	LocalInit(key_data, tag_size = 32) {
		return Init(srtp_out, key_data);
	}

	static MasterSecret(key_data) {
		key_data = mime_encode(key_data);
		key_data = StrReplace(key_data, "\r", "");
		key_data = StrReplace(key_data, "\n", "");
		return key_data;
	}

	RandomInit(tag_size = 32) {
		var key_data = MasterSecret(CryptoRandom(30));
		LocalInit(key_data, tag_size);
		return key_data;
	}

	static HexDebug(hex) {
		hex = StringToHex(hex);
		if (hex) {
			for (var i = 0; i < length hex; i += 4)
				hex[i] = "\\x" + hex[i];
		}
		return hex;
	}

	RemoteInit(key_data, tag_size = 32) {
		return Init(srtp_in, key_data, tag_size);
	}

	Encrypt(var header, var payload) {
		if (!srtp_out)
			return payload;
		return SRTPEncrypt(srtp_out, header, payload);
	}

	Decrypt(var header, var payload) {
		if (!srtp_in)
			return payload;

		return SRTPDecrypt(srtp_in, header, payload);
	}

	Done() {
		if (srtp_in) {
			SRTPDone(srtp_in);
			srtp_in = null;
		}
		if (srtp_out) {
			SRTPDone(srtp_out);
			srtp_out = null;
		}
	}

	finalize() {
		Done();
	}
}

class SIPSession {
	public var CallID;
	public var ssrc_id;
	public var UserData;
	public var tcp_socket;

	private var Expire = 0;
	public var msg;
	public var bye_msg;
	public var is_invite;
	public var auth;
	private var s;
	private var sequence_number;
	private var rtp_port;
	private var rtp;
	private var srtp;
	private var d;

	var remote_port = -1;
	var remote_host = "";
	var remote_id = 0;
	var ip;
	var port;
	var packet_time;
	var started;

	var DTMFHistory = "";

	var ivr="";
	var ivr_chunk=0;

	var buf="";
	var buf_chunk=0;
	var accept_bye = false;
	var bye_set = false;
	var chunk_size;
	var timestamp;

	var write_timestamp;
	var write_retry = 4;
	var write_server;

	var[] out_stack;

	var[] Children;
	var Parent;

	var sdp_in = "";
	var sdp_out = "";

	var OnMessage;
	var OnReferError;
	var OnDTMF;
	var OnReferred;

	var _private_data;
	var Referred;

	var Record = false;
	var RecordBuffers;
	var last_sequence_number = -1;

	var Branch;
	var NoForward;

	var MaxJitter;

	SIPSession(s, msg, rtp_port, ip, port, chunk_size = 20, expire = 3600) {
		packet_time = microseconds();
		timestamp = RandomInteger(140, 140000) * 100;
		this.SetRTP(msg, rtp_port);
		this.rtp_port = rtp_port;
		this.chunk_size = chunk_size * 1000;
		this.s = s;
		this.tcp_socket = s.use_socket;
		this.msg = msg;
		this.MaxJitter = s.MaxJitter;

		this.ip = ip;
		this.port = port;
		Expire = time() + expire + 1;
		CallID = msg.Headers["call-id"];
		ssrc_id = ClsPtr(this);
		sequence_number = RandomInteger(0, 0xFFF);

		this.UpdateMedia(msg);
	}

	SetRTP(msg, rtp_port) {
		Branch = msg.Branch;
		rtp = new UDPSocket();
		rtp.Bind(rtp_port);
	}

	ParseA(line) {
		var arr = StrSplit(line, " ");
		if (length arr > 2) {
			var crypto = ToLower(SubStr(arr[0], 0, 6));
			if (crypto == "crypto") {
				var algorithm = ToUpper(trim(arr[1]));
				var key = StrSplit(trim(arr[2]), "|")[0];
				if (SubStr(key, 0, 7) != "inline:")
					return false;

				key = SubStr(key, 7);
				switch (algorithm) {
					case "AES_CM_128_HMAC_SHA1_80":
						if (!srtp)
							srtp = new SRTPContext();
						srtp.RemoteInit(key, 80);
						return true;
					case "AES_CM_128_HMAC_SHA1_32":
						if (!srtp)
							srtp = new SRTPContext();
						srtp.RemoteInit(key, 32);
						return true;
				}
			}
		}
	}

	UpdateMedia(msg, ip = "", port = 0) {
		var payload = msg.Payload;
		sdp_in = msg.PayloadBlob;
		for (var i = 0; i < length payload; i++) {
			var line = payload[i];
			switch (line[0] + line[1]) {
				case "o=":
					var arr = StrSplit(SubStr(line, 2, length line), " ");
					remote_host = arr[5];
					remote_id = value arr[1];
					break;
				case "m=":
					arr = StrSplit(SubStr(line, 2, length line), " ");
					if ((arr) && (ToLower(arr[0]) == "audio"))
						remote_port = value arr[1];
					break;
				case "a=":
					if (this.s.SRTP)
						this.ParseA(SubStr(line, 2));
					break;
			}
		}
		if (this.s.NonRoutable(remote_host)) {
			remote_host = ip;
			if (!remote_host)
				remote_host = this.ip;
		}
	}

	static GetTag(addr) {
		var tag = "";
		var arr = StrSplit(addr, ";tag=");
		if (length arr > 1) {
			tag = StrSplit(arr[1], ";")[0];
			if (!tag)
				tag = "";
		}
		return tag;
	}

	UpdateTags() {
		if ((bye_msg) && (msg)) {
			var from = bye_msg.Headers["from"];
			if (!from)
				from = bye_msg.Headers["From"];

			var to = bye_msg.Headers["to"];
			if (!to)
				to = bye_msg.Headers["To"];

			if ((from) && (to)) {
				var from_tag = GetTag(from);
				var to_tag = GetTag(to);
				var msg_to = msg.Headers["to"] ?? msg.Headers["To"];
				var msg_from = msg.Headers["from"] ?? msg.Headers["From"];
				// from / to reversed
				if (msg_to) {
					if (Pos(msg_to, ";tag=") > 0)
						msg_to = StrSplit(msg_to, ";tag=")[0];
					msg_to += ";tag=$to_tag";
					msg.Headers["To"] = msg_to;
					msg.Headers["to"] = msg_to;
				}
				if (msg_from) {
					if (Pos(msg_from, ";tag=") > 0)
						msg_from = StrSplit(msg_from, ";tag=")[0];

					msg_from += ";tag=$from_tag";
					msg.Headers["From"] = msg_from;
					msg.Headers["from"] = msg_from;
				}

			}
			if (is_invite) {
				msg.LocalAddress = msg.Headers["from"];
				msg.RemoteAddress = msg.Headers["to"];
			} else {
				msg.LocalAddress = msg.Headers["to"];
				msg.RemoteAddress = msg.Headers["from"];
			}
			bye_msg.LocalAddress = msg.LocalAddress;
			bye_msg.RemoteAddress = msg.RemoteAddress;
		}
	}

	static EnsureTag(var field) {
		if (!field)
			return;
		if (!SIPSession::GetTag(field))
			field += ";tag=" + SIPStack::RandomString(20);
	}

	Accept(code=200) {
		accept_bye = true;
		bye_set = true;
		var exc;
		try {
			this.s.use_socket = tcp_socket;
			this.bye_msg = this.s.ResponseUDP(code, msg, msg.Headers["from"], this.GetSDP(), "application/sdp", 70, null, "", ip, port, true);
			UpdateTags();
			return true;
		} catch (exc) {
			return false;
		}
	}

	Reject(code=486) {
		var exc;
		try {
			this.s.use_socket = tcp_socket;
			this.s.ResponseUDP(code, msg, msg.Headers["from"], "", "", 70, null, "", ip, port);
			if (this.s.OnEnd)
				this.s.OnEnd(this, msg, "");
			this.s.RemoveSessionByRef(this);
			return true;
		} catch (exc) {
			return false;
		}
	}

	Bye(delete_session=false) {
		var exc;
		try {
			this.s.use_socket = tcp_socket;
			if (accept_bye) {
				if (is_invite)
					var msg2 = s.Bye(bye_msg ?? msg, ip, port);
				else
					msg2 = s.Bye(msg, ip, port);
			}
		} catch (exc) {
			// nothing
		}
		try {
			if (rtp)
				rtp.Close();
			if (delete_session) {
				if (this.s.OnEnd)
					this.s.OnEnd(this, msg2, "");
				this.s.RemoveSessionByRef(this);
			}
		} catch (exc) {
			// nothing
		}
		rtp = null;
	}

	End(delete_session=false, msg2 = null) {
		var exc;
		try {
			this.s.use_socket = tcp_socket;
			if (rtp)
				rtp.Close();
			if (delete_session) {
				if (this.s.OnEnd)
					this.s.OnEnd(this, msg2, "");
				this.s.RemoveSessionByRef(this);
			}
		} catch (exc) {
			// nothing
		}
		rtp = null;
	}

	Cancel(delete_session=false, reject_code = 486) {
		var exc;
		try {
			this.s.use_socket = tcp_socket;
			if (accept_bye)
				return this.Bye(delete_session);
			//var msg2 = s.Cancel(msg, ip, port);
			if (is_invite)
				var msg2 = s.Cancel(bye_msg ?? msg, ip, port);
			else
				msg2 = this.Reject(reject_code);//s.Cancel(msg, ip, port);
		} catch (exc) {
			// nothing
		}
		try {
			if (rtp)
				rtp.Close();
			if (delete_session) {
				if (this.s.OnEnd)
					this.s.OnEnd(this, msg2, "");
				this.s.RemoveSessionByRef(this);
			}
		} catch (exc) {
			// nothing
		}
		rtp = null;
	}

	Expired() {
		return (time() > Expire);
	}

	setExpires(seconds) {
		Expire = time() + seconds;
	}

	RecordID() {
		return "" + ClsPtr(this);
	}

	RecordStream(srcid, var payload, type = "", profile = 8) {
		var key = RecordID() + "-" + type + profile + "-" + srcid;
		if (!RecordBuffers)
			RecordBuffers = new [];
		if (RecordBuffers[key])
			RecordBuffers[key] += payload;
		else
			RecordBuffers[key] = payload;
	}

	DumpStreams(prefix, sync_len = true) {
		var[] files;
		if (RecordBuffers) {
			var keys = GetKeys(RecordBuffers);
			if (keys) {
				var min_len = 0;
				if (sync_len) {
					for (var i = 0; i < length RecordBuffers; i++) {
						var buf = RecordBuffers[i];
						if (buf) {
							if ((!min_len) || (min_len > length buf))
								min_len = length buf;
						}
					}
				}
				for (i = 0; i < length keys; i++) {
					var k = keys[i];
					if (k) {
						buf = RecordBuffers[k];
						if (buf) {
							var fname = prefix + k + ".raw";
							files[length files] = fname;
							if ((min_len > 0) && (length buf != min_len))
								WriteFile(SubStr(buf, length buf - min_len), fname);
							else
								WriteFile(buf, fname);
						}
					}
				}
			}
			RecordBuffers = null;
		}
		return files;
	}

	SimpleRTP(payload, profile = 8) {
		var res = chr(0x80) + chr(profile);
		res += toubin(htons(sequence_number), 16);
		timestamp += length payload;
		res += toubin(htonl(timestamp), 32);
		var ssrc_id = ClsPtr(this);
		res += toubin(htonl(ssrc_id), 32);
		if (srtp)
			res += srtp.Encrypt(res, payload);
		else
			res += payload;
		sequence_number++;
		if (Record)
			RecordStream(ssrc_id, payload, "out-", profile);
		return res;
	}

	ParseRTP(data, var type = null) {
		type = -1;
		if (length data > 12) {
			type = tounumber(data[1], 8) & 0x7F;
			if ((type >= 72) && (type <= 76))
				return "";
			var sequence_number = ntohs(tounumber(data[2] + data[3], 16));
			if ((last_sequence_number) && (sequence_number <= last_sequence_number)) {
				var delta = sequence_number - last_sequence_number;
				if (delta < 0)
					delta *= -1;
				if (delta < 20)
					return "";
			}
			last_sequence_number = sequence_number;
			var ssrc_id = (tounumber(data[8] + data[9] + data[10] + data[11], 32));
			var payload = SubStr(data, 12, length data);
			if (Record)
				RecordStream(ssrc_id, payload, "in-", type);
			if (srtp)
				return srtp.Decrypt(SubStr(data, 0, 12), payload);
			return payload;
		}
		return "";
	}

	GetSDP(codec = 8, extra = "") {
		var res;
		if (this.s.SRTP) {
			if (!srtp)
				srtp = new SRTPContext();
			res = "v=0\r\no=somebody ${ClsPtr(this)} ${VarPtr(this)} IN IP4 ${s.localip}\t\ns=Concept\r\nc=IN IP4 ${s.localip}\r\nt=0 0\r\nm=audio ${rtp_port} RTP/SAVP $codec\r\na=crypto:1 AES_CM_128_HMAC_SHA1_32 inline:${srtp.RandomInit(32)}\r\n";
		} else
			res = "v=0\r\no=somebody ${ClsPtr(this)} ${VarPtr(this)} IN IP4 ${s.localip}\t\ns=Concept\r\nc=IN IP4 ${s.localip}\r\nt=0 0\r\nm=audio ${rtp_port} RTP/AVP $codec\r\na=rtpmap:$codec PCMA/8000\r\n";
		if (extra)
			res += "a=$extra\r\n";
		sdp_out = res;
		return res;
	}

	finalize() {
		if (rtp)
			rtp.Close();
		for (var i = 0; i < length Children; i++) {
			var sess = Children[i];
			if (sess) {
				sess.Parent = null;
				Children[i] = null;
				this.s.RemoveSessionByRef(sess);
			}
		}
	}

	CheckMedia(var type = null) {
		if ((rtp) && (rtp.HasData))
			return ParseRTP(rtp.Read(), type);

		return "";
	}

	LoadVoice(var voice) {
		ivr = voice;
		ivr_chunk = 0;
		packet_time = microseconds();
	}

	AppendVoice(var voice) {
		ivr += voice;
	}

	Clear() {
		buf = "";
	}

	ResetBuffers() {
		buf = "";
		ivr = "";
	}

	AddChild(session) {
		if (session) {
			Children[length Children] = session;
			session.Parent = this;
		}
	}

	RemoveChild(session) {
		var[] new_children;
		for (var i = 0; i < length Children; i++) {
			var child = Children[i];
			if (child) {
				if (child == session)
					child.Parent = null;
				else
					new_children[length new_children] = session;
			}
		}
		this.Children = new_children;
	}

	RemoveAllChildren() {
		while (this.Children) {
			var session = this.Children[0];
			if (session._private_data)
				session.Cancel(true);
			else
				session.Bye(true);
			this.RemoveChild(session);
		}
	}

	ChildIsValid(session) {
		for (var i = 0; i < length Children; i++) {
			var child = Children[i];
			if (child) {
				if (child == session)
					return true;
			}
		}
		return false;
	}

	Write(payload, max_frames = 0) {
		if ((remote_host) && (remote_port > 0)) {
			if (max_frames > 0) {
				var max_size = chunk_size / 1000 * 8 * max_frames;
				if (length buf > max_size) {
					// jitter
					buf = "";
				}
			}
			buf+=payload;
			return length buf;
		}
		return -1;
	}

	ResetDTMF() {
		if (d) {
			d.Reset();
			DTMFHistory = "";
		}
	}

	PushFront(msg) {
		var[] new_stack;
		if (out_stack) {
			for (var i = 0; i < length out_stack; i++)
				new_stack[i + 1] = out_stack[i];
		}
		new_stack[0] = msg;
		out_stack = new_stack;

		return length new_stack;
	}

	Push(msg) {
		out_stack[length out_stack] = msg;
		return length out_stack;
	}

	ClearStack() {
		out_stack = new [];
	}

	Pop() {
		if (out_stack) {
			var[] new_stack;
			var e = out_stack[0];
			for (var i = 1; i < length out_stack; i++)
				new_stack[i - 1] = out_stack[i];
			out_stack = new_stack;
			return e;
		}
		return null;
	}

	Head() {
		if (out_stack)
			return out_stack[0];
		return null;
	}

	Refer(address) {
		return this.s.Refer(msg, address);
	}

	setMaxJitter(max) {
		this.MaxJitter = max;
		if (Children) {
			for (var i = 0; i < length Children; i++) {
				var child = Children[i];
				if (child)
					child.MaxJitter = max;
			}
			if (Parent)
				Parent.MaxJitter = max;
		}
	}

	Iterate() {
		var exc;
		var ops = 0;
		try {
			// 500ms reinvite
			if ((write_timestamp) && (msg) && (write_server) && (microseconds() - write_timestamp >= 500000)) {
				if (write_retry) {
					this.write_timestamp = microseconds();
					this.s.DoWrite(this.s.use_socket ?? this.s.udpclientsocket, msg.ToString(), write_server[0], write_server[1]);
					write_retry --;
				} else {
					write_timestamp = 0;
					delete write_server;
					throw "Session invite expired !\n";
				}
			}
			var data = CheckMedia(var type);
			if (data) {
				ops++;
				if (s.OnAudio)
					s.OnAudio(this, data, type);
				started = true;
				if (Children) {
					for (var i = 0; i < length Children; i++) {
						var child = Children[i];
						if (child)
							child.Write(data, this.MaxJitter);
					}
				} else
				if (Parent) {
					Parent.Write(data, this.MaxJitter);
				} else
				if ((s.OnDTMF) || (this.OnDTMF)) {
					if (!d) {
						d = new DTMFDetector();
						d.Threshold = 1000;
					}
					if (type == 8)
						d.AddBuffer(alaw2pcm(data));
					else
					if (type == 0)
						d.AddBuffer(ulaw2pcm(data));

					var buttons = d.Buttons;
					if ((buttons) && (buttons != DTMFHistory)) {
						DTMFHistory = buttons;
						if (this.OnDTMF)
							this.OnDTMF(this, buttons[length buttons - 1]);
						else
							s.OnDTMF(this, buttons[length buttons - 1]);
					}
				}
			}

			if (started) {
				if ((remote_host) && (remote_port > 0) && (rtp)) {
					var delta = uint32((microseconds() - packet_time) / chunk_size);
					if (ivr) {
						if (delta >= ivr_chunk) {
							var f_size = chunk_size / 1000 * 8;
							var d_ivr = SubStr(ivr, ivr_chunk * /*160*/ f_size, f_size);
							ivr_chunk = delta + 1;
							if (d_ivr) {
								if (this.s.OnAudioOut)
									this.s.OnAudioOut(s, d_ivr);
								rtp.Write(SimpleRTP(d_ivr), remote_host, remote_port);
							} else {
								ivr = "";
								ivr_chunk = 0;
								packet_time = microseconds();
								if (s.OnIVRFinished)
									s.OnIVRFinished(this);
							}
							ops++;
						}
					} else {
						if (delta >= buf_chunk) {
							buf_chunk = delta + 1;
							f_size = chunk_size / 1000 * 8;
							var d_buf = SubStr(buf, 0, /*160*/f_size);
							if (d_buf) {
								buf = SubStr(buf, /*160*/f_size);
								if (this.s.OnAudioOut)
									this.s.OnAudioOut(s, d_buf);
								rtp.Write(SimpleRTP(d_buf), remote_host, remote_port);
							}
							ops++;
						}
					}
				}
			} else
			if (!started) {
				if ((packet_time >= microseconds()) && (rtp)) {
					if ((remote_host) && (remote_port > 0)) {
						var str = "";
						var blocks = chunk_size / 1000 * 8 / 10;
						for (i = 0; i < blocks; i++)
							str += '\0\0\0\0\0\0\0\0\0\0';
						buf = str;
						rtp.Write(this.SimpleRTP(str), remote_host, remote_port);
					}
					packet_time = microseconds() + 19000;
					ops++;
				}
				started = true;
			}
			if (Expired())
				throw "Session expired !\n";
		} catch (exc) {
			if (this.tcp_socket)
				this.s.RemoveTCPSocket(this.tcp_socket);
			this.s.RemoveSessionByRef(this);
			this.Bye();
			if (this.s.OnEnd)
				this.s.OnEnd(this, msg, "");
			ops++;
		}
		return ops;
	}
}

class SIPMessage {
	var FromServer = false;
	var Understood = false;
	var Protocol = "SIP/2.0";
	var ServerCode = 0;
	var ServerCodeText = "";
	var Destination = "";
	var Method = "";
	var Branch = "";
	var[] Headers;
	var[] Payload;
	var PayloadBlob = "";
	var ParentCallID = "";
	var Local = false;
	var LocalAddress = "";
	var RemoteAddress = "";

	var ip;
	var port;

	GenerateResponse(code) {
		var msg = new SIPMessage();
		msg.FromServer = true;
		msg.Understood = true;
		msg.Protocol = this.Protocol;
		msg.ServerCode = code;
		var exp = SIP_CODES["" + this.ServerCode];
		if (exp)
			msg.ServerCodeText = exp;
		msg.Destination = this.Destination;
		msg.Method = this.Method;
		msg.Branch = this.Branch;
		msg.Local = true;
		return msg;
	}

	ToString() {
		var res = "";
		if (this.FromServer) {
			if ((this.ServerCode) && (this.Protocol)) {
				var exp = SIP_CODES["" + this.ServerCode];
				if (!exp)
					exp = this.ServerCodeText;
				res += this.Protocol + " " + this.ServerCode + " " + exp + "\r\n";
			} else
				return res;
		} else
		if ((this.Method) && (this.Destination)) {
			res += this.Method + " " + this.Destination;
			if (this.Protocol)
				res += " " + this.Protocol;
			res+= "\r\n";
		} else
			return res;
		var headers = this.Headers;

		if (headers) {
			var keys = GetKeys(headers);
			var len = length keys;
			for (var i = 0; i < len; i++) {
				var key = keys[i];	
				if ((key) && (key!="user-agent") && (key!="organization")) {
					var val = headers[key];
					key[0] = ToUpper(key[0]);
					if (typeof val == "array") {
						var len2 = length val;
						for (var j = 0; j < len2; j++)
							res += key + ": " + val[j] + "\r\n";							
					} else {
						if (ToLower(key) == "call-id") {
							res += "User-agent: Concept4_0SIP_API/1.0\r\n";
							res += "Organization: Devronium/Concept Application Server\r\n";
							res += "Call-ID: " + val + "\r\n";
						} else
						if (key == "Cseq") {
							res += "CSeq: " + val + "\r\n";
						} else
							res += key + ": " + val + "\r\n";
					}
				}
			}
		}

		res += "\r\n";
		if (this.PayloadBlob) {
			res += this.PayloadBlob;
		} else
		if (this.Payload) {
			var p_str = "";
			var payload = this.Payload;
			len = length payload;
			for (i=0; i < len; i++) {
				var p = payload[i];
				if (p)
					p_str += p + "\r\n";
			}
			if (p_str)
				res += p_str;
		}
		return res;
	}
}

class SIPUserInfo {
	var username;
	var expires;
	var ip;
	var port;
	var contact;
	var non_routable;

	SIPUserInfo(username) {
		this.username = username;
	}

	Update(timeout) {
		if (timeout > 0)
			this.expires = time() + timeout;
		else
			this.expires = 0;
	}

	Expired() {
		if ((expires) && (time() > expires))
			return true;
		return false;
	}
}

class SIPUtils {
	static mix(files, output_file, channels = 1, format = "alaw") {
		if ((!files) || (!output_file))
			return null;
		var params = "";
		var filter = "";
		var index = 0;
		for (var i = 0; i < length files; i++) {
			var file = files[i];
			if (file) {
				params += "-f $format -ar 8000 -ac 1 -acodec pcm_$format -i \"$file\" ";
				filter += "[$index:a]";
				index++;
			}
		}
		_unlink(output_file);
		var command = "ffmpeg -loglevel fatal $params-filter_complex \"${filter}amix\" -ac $channels -qscale:a 2 \"$output_file\"";
		return _system(command);
	}
}

class SIPRoute {
	var rule;
	var ip;
	var host;
	var port;

	SIPRoute(rule, host, port) {
		this.rule = rule;
		this.host = host;
		this.ip = SIPStack::IPFromName(host);
		this.port = port;
	}
}

class RegistrationData {
	var username;
	var password;
	var server;
	var server_port;
	var nonce = "";
	var timestamp;
	var ip;

	RegistrationData(username, password, server, server_port) {
		this.username = username;
		this.password = password;
		this.server = server;
		this.server_port = server_port;
		this.ip = SIPStack::IPFromName(server) ?? server;
	}

	updateIp() {
		if (this.ip == this.server)
			return;

		this.ip = SIPStack::IPFromName(server) ?? server;
	}
}

class SIPStack {
	var udpclientsocket;
	var use_socket;
	var tcpsocket;
	var localhost;
	var local_port = 5060;
	var localip;
	var full_host;
	var rtp_port_index = RTP_START_PORT;
	var realm = "";
	var[] Sessions;
	var[] Routes;
	var[] Users;
	var[] Registrations;
	var MaxTime = 3600;
	var OnDTMF;
	var OnDTMFRelay;
	var OnAudio;
	var OnAudioOut;
	var OnInvite;
	var OnEnd;
	var OnRinging;
	var OnIVRFinished;
	var OnNotify;
	var OnAfterNotify;
	var OnResponse;
	var OnAnswered;
	var OnNotUnderstood;
	var OnRegister;
	var OnNeedAuthorization;
	var OnTextMessage;
	var OnFilter;
	var OnInvalidSource;
	var OnRecv;
	var OnSend;
	var OnInfo;
	var OnPublish;
	var OnAfterPublish;
	var OnClientRegister;

	var Transport = "UDP";
	var sipproto = "sip:";
	var tcp = false;
	var[] TCPSockets;
	var FrameSize = 20;
	var MaxJitter = 10;

	var RegisterTimeout = 600;
	var NonRoutableRegisterTimeout = 5;
	var AllowAllOrigins = true;

	var NATFriendly = false;
	var SRTP = false;

	SIPStack(localhost, bind_port = 5060, type = SIP_TRANSPORT_UDP, public_key = "", private_key = "", force_tls_version = 0) {
		this.localhost = localhost;
		this.local_port = bind_port;
		this.localip = this.IPFromName(localhost);
		this.realm = localhost;
		switch (type) {
			case SIP_TRANSPORT_TCP:
				tcpsocket = new TCPSocket();
				tcpsocket.Listen(bind_port, 0xFFFF);
				Transport = "TCP";
				tcp = true;
				break;
			case SIP_TRANSPORT_TLS:
				// use sip: for TLS also
				// sipproto = "sips:";
				tcpsocket = new TLSESocket();
				tcpsocket.Listen(bind_port, 0xFFFF, "", force_tls_version);
				if (!tcpsocket.LoadKeys(public_key, private_key))
					echo "Warning: Error loading TLS/SSL keys. TLS will not be supported.";
				Transport = "TLS";
				tcp = true;
				break;
		}
		udpclientsocket = new UDPSocket();
		udpclientsocket.Bind(bind_port);

		this.full_host = localhost;
		if (local_port != 5060)
			this.full_host += ":" + bind_port;

		RandomSeed(unpack("u32", CryptoRandom(4))[0]);
	}

	static IPFromName(host) {
		var arr = GetHostByName(host);
		var local_ip = "";
		if (arr) {
			local_ip = arr["h_addr_list0"];
			if (!local_ip)
				local_ip = arr[1];
			if (!local_ip)
				local_ip = arr[0];
		}
		if (!local_ip)
			return trim(host);
		return local_ip;
	}

	public AddRoute(rule, ip, port = 5060) {
		var route = new SIPRoute(rule, ip, port);
		Routes[rule] = route;
	}

	public RemoveRoute(rule) {
		var keys = GetKeys(Routes);
		var new_routes = new [];
		for (var i = 0; i < length keys; i++) {
			var k = keys[i];
			if ((k) && (k != rule))
				new_routes[k] = Routes[k];
		}
		Routes = new_routes;
	}

	public ClearRoutes() {
		Routes = new [];
	}

	private ParseDestination(destination) {
		var arr = StrSplit(destination, ";");
		return arr[0];
	}

	public ValidOrigin(ip) {
		if ((!Routes) && (!Users) && (!Registrations) && (AllowAllOrigins))
			return true;
		for (var i = 0; i < length Routes; i++) {
			var route = Routes[i];
			if ((route) && ((route.ip == ip) || (route.ip == "*")))
				return true;
		}
		for (i = 0; i < length Users; i++) {
			var user = Users[i];
			if ((user) && (user.ip == ip) && (!user.Expired()))
				return true;
		}
		for (i = 0; i < length Registrations; i++) {
			var registration = Registrations[i];
			if ((registration) && (registration.ip == ip))
				return true;
		}
		if ((localip) && (ip == localip))
			return true;
		return false;
	}

	public Parse(msg) {
		if (msg) {
			var orig_msg = msg;
			msg = StrReplace(msg, "\r", "");

			var arr = StrSplit(msg, "\n", true);
			var len = length arr;

			var first_line = arr[0];
			if (first_line) {
				var first_line_arr = StrSplit(first_line, " ");
				var sipid = ToUpper(first_line_arr[0]);	
				var message = new SIPMessage();
				if (sipid[0] + sipid[1] + sipid[2] == "SIP") {
					// is server response
					message.FromServer = true;
					message.ServerCode = value first_line_arr[1];
					message.ServerCodeText = "";
					for (var i = 2; i < length first_line_arr; i++) {
						if (i > 2)
							message.ServerCodeText += " ";
						message.ServerCodeText += first_line_arr[i];
					}
					message.Protocol = sipid;
				} else {
					switch (sipid) {
						case "INVITE":
						case "ACK":
						case "BYE":
						case "CANCEL":
						case "OPTIONS":
						case "REGISTER":
						case "PRACK":
						case "NOTIFY":
						case "PUBLISH":
						case "INFO":
						case "REFER":
						case "MESSAGE":
						case "UPDATE":
							if (length first_line_arr > 1) {
								message.Understood = true;	
								message.Destination = this.ParseDestination(first_line_arr[1]);
								message.Method = sipid;
								if (first_line_arr[2])
									message.Protocol = first_line_arr[2];
							}
							break;
					}
				}
				
				var headers = new [];
				var need_payload = false;
				var has_content = false;
				for (i = 1; i < len; i++) {
					var line = arr[i];
					if (line) {
						var pos = Pos(line, ":");
						if (pos > 0) {
							var name = ToLower(SubStr(line, 0, pos - 1));
							var val = trim(SubStr(line, pos, length line));
							if (headers[name]) {
								if (typeof headers[name] == "array")
									headers[name] += val;
								else
									headers[name] = [ headers[name], val ];
							} else
								headers[name] = val;

							if (name == "content-type") {
								if ((val == "application/sdp") || (val=="sdp"))
									need_payload = true;
								has_content = true;
							}
						}
					} else {
						// switch to payload
						break;
					}
				}
				var payload = new [];
				if (need_payload) {
					message.PayloadBlob = "";
					while (i < len) {
						line = arr[i++];
						if (line) {
							payload[length payload] = line;
							message.PayloadBlob += line + "\r\n";
						}
					}
				} else
				if (has_content) {
					pos = Pos(orig_msg, "\r\n\r\n");
					if (pos > 0)
						message.PayloadBlob = SubStr(orig_msg, pos + 3);
				}
				message.Headers = headers;
				message.Payload = payload;
				message.Local = false;
			}
		}
		return message;
	}

	ParseAuth(auth) {
		var len = length auth;
		var in_quotes = false;

		var name = "";
		var temp = "";
		var[] res;
		var start = 0;
		if (ToLower(SubStr(auth, 0, 7)) == "digest ")
			start = 7;

		for (var i = start; i < len; i++) {
			var c = auth[i];
			if (c == '"')
				in_quotes = !in_quotes;
			else
			if (c == '=') {
				name = ToLower(trim(temp));
				temp = "";
			} else
			if ((c == ",") && (!in_quotes)) {
				if (name) {
					temp = trim(temp);
					if ((length temp >= 2) && (temp[0] == temp[length temp - 1]) && (temp[0] == '"'))
						temp = SubStr(temp, 1, length temp - 2);
					res[name] = temp;
				}
				temp = "";
			} else
				temp += c;
		}
		if ((name) && (temp)) {
			temp = trim(temp);
			if ((length temp >= 2) && (temp[0] == temp[length temp - 1]) && (temp[0] == '"'))
				temp = SubStr(temp, 1, length temp - 2);
			res[name] = temp;
		}

		return res;
	}

	private WWWAuth(auth, username, password, method, uri, var nonce) {
		var res = ParseAuth(auth);
		nonce = res["nonce"];
		if ((res["nonce"]) && (res["realm"])) {
			var alg = res["algorithm"];
			if (!alg)	
				alg = "md5";
			else
				alg = ToLower(alg);
			switch (alg) {
				case "sha1":
					var ha1 = sha1(username + ":" + res["realm"] + ":" + password);
					var ha2 = sha1(method + ":" + uri);
					var response = sha1(ha1 +":" + res["nonce"] + ":" + ha2);
					break;
				case "sha256":
					ha1 = sha256(username + ":" + res["realm"] + ":" + password);
					ha2 = sha256(method + ":" + uri);
					response = sha256(ha1 +":" + res["nonce"] + ":" + ha2);
					break;
				default:
					ha1 = md5(username + ":" + res["realm"] + ":" + password);
					ha2 = md5(method + ":" + uri);
					response = md5(ha1 +":" + res["nonce"] + ":" + ha2);
			}
			return "Digest username=\"$username\", realm=\"${res['realm']}\", nonce=\"${res['nonce']}\", uri=\"$uri\", response=\"$response\"";
		}
		return "";
	}

	static RandomString(len) {
		var res="";
		var characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		var rlen = length characters - 1;
		while (length res<len) {
			var c = RandomInteger(0, rlen);
			res += characters[c];
		}
		return res;
	}

	private RegisterMessage(username, password, server, server_port = 5060, response = null, var nonce = null, max_forwards = 70) {
		var register = new SIPMessage();
		register.Destination = sipproto + server;
		if (server_port != 5060)
			register.Destination += ":" + server_port;
		register.Method = "REGISTER";

		var branch;
		var callid;
		var authorization = "";
		if (response) {
			branch = response.Branch;
			callid = response.Headers["call-id"];
			if ((response.ServerCode >= 400) && (response.ServerCode < 500)) {
				if (response.ServerCode != 401)
					throw "Invalid username or password";
				var auth = response.Headers["www-authenticate"];
				if (auth)
					authorization = this.WWWAuth(auth, username, password, register.Method, server, nonce);
			}
		}
		if (!branch)
			branch = "z9hG4bK" + this.RandomString(14);
		if (!callid)
			callid = /* this.RandomString(32) */sha256(username + "|" + server) + "@" + localhost;

		register.Headers["Via"] = "SIP/2.0/${Transport} " + full_host + ";rport;branch=" + branch;
		var from = username + " <" + sipproto + username + "@" + server + ">";
		register.Headers["From"] = from;
		register.Headers["To"] = from;
		register.Headers["Max-Forwards"] = max_forwards;

		register.Headers["Call-ID"] = callid;	
		register.Headers["Allow"] = SIP_ALLOW;
		if (response)
			register.Headers["CSeq"] = "" + (value (response.Headers["cseq"]) + 1) + " " + register.Method;
		else
			register.Headers["CSeq"] = "1 " + register.Method;
		register.Headers["Contact"] = "\"$username\" <" + sipproto + username + "@" + full_host + ">";
		if (authorization)
			register.Headers["Authorization"] = authorization;

		register.Headers["Content-Length"] = 0;

		return register;
	}

	private TimedOutRead(t, timeout) {
		while (!t.HasData) {
			Sleep(10);
			timeout -= 10;
			if (timeout <= 0)
				return null;
		}
		return this.Parse(t.Read());
	}

	DoWrite(socket, var buffer, ip, port) {
		// UDP
		var type = classof socket;
		if (type[0] == "U")
			return socket.Write(buffer, ip, port);

		return socket.Write(buffer);
	}

	Register(username, password, server, server_port=5060) {
		var register = this.RegisterMessage(username, password, server, server_port, null, var nonce);
		var local_udpclientsocket = use_socket ?? udpclientsocket;
	
		if (this.DoWrite(local_udpclientsocket, register.ToString(), server, server_port) < 0)
			return null;

		var key = register.Headers["Call-ID"];
		this.Registrations[key] = new RegistrationData(username, password, server, server_port);
	}

	Unregister(username) {
		var[] new_registrations;
		var keys = GetKeys(this.Registrations);
		var cleared = 0;
		for (var i = 0; i < length keys; i ++) {
			var k = keys[i];
			if (k) {
				var reg = this.Registrations[k];
				if ((reg) && (reg.username != username))
					new_registrations[k] = reg;
				else
					cleared ++;
			}
		}
		
		this.Registrations = new_registrations;
		return cleared;
	}

	protected Register401(msg) {
		if (msg.ServerCode != 401)
			return;

		var cseq = "" + msg.Headers["cseq"];
		if (Pos(cseq, " REGISTER") <= 0)
			return;

		var callid = msg.Headers["call-id"];
		if (IsSet(this.Registrations, callid)) {
			var registration = this.Registrations[callid];
			if (registration) {
				var local_udpclientsocket = use_socket ?? udpclientsocket;
				var register = this.RegisterMessage(registration.username, registration.password, registration.server, registration.server_port, msg, var nonce);
				if (this.DoWrite(local_udpclientsocket, register.ToString(), registration.server, registration.server_port) < 0)
					return;
				registration.nonce = nonce;
			}
		}
	}

	protected Register200(msg) {
		if (msg.ServerCode != 200)
			return;

		var cseq = "" + msg.Headers["cseq"];
		if (Pos(cseq, " REGISTER") <= 0)
			return;

		var callid = msg.Headers["call-id"];
		if (IsSet(this.Registrations, callid)) {
			var registration = this.Registrations[callid];
			if (registration) {
				registration.timestamp = time();
				if (this.OnClientRegister)
					this.OnClientRegister(registration);
			}
		}
	}

	Reregister(timeout = 8) {
		var registrations = this.Registrations;
		var local_udpclientsocket = use_socket ?? udpclientsocket;
		var count = 0;
		for (var i = 0; i < length registrations; i ++) {
			var registration = registrations[i];
			if ((registration) && (time() - registration.timestamp >= timeout)) {
				registration.updateIp();
				try {
					var register = this.RegisterMessage(registration.username, registration.password, registration.server, registration.server_port);
					if (this.DoWrite(local_udpclientsocket, register.ToString(), registration.server, registration.server_port) < 0)
						return count;
					count ++;
				} catch (var exc) {
				}
			}
		}
		return count;
	}

	RegisterUDP(username, password, server, server_port=5060, timeout=5000) {
		try {
			var register = this.RegisterMessage(username, password, server, server_port, null, var nonce);
			var local_udpclientsocket = use_socket ?? udpclientsocket;//new UDPSocket();

			if (this.DoWrite(local_udpclientsocket,  register.ToString(), server, server_port) <= 0)
				return null;

			var msg = this.TimedOutRead(local_udpclientsocket, timeout);
			if ((msg) && (msg.ServerCode == 401)) {
				register = this.RegisterMessage(username, password, server, server_port, msg, nonce);
				if (this.DoWrite(local_udpclientsocket, register.ToString(), server, server_port) < 0)
					return null;
				var msg2 = this.TimedOutRead(local_udpclientsocket, timeout);
				if (msg2)
					msg2.PayloadBlob = nonce;
				return msg2;
			}
		} catch (var exc) {
			// silently ignore the network error
		}
		return null;
	}

	Invite401(session, msg) {
		if ((msg.ServerCode != 401) || (!session.is_invite) || (!session.msg) || (session.msg.Headers["Authorization"]) || (session.auth))
			return false;

		var auth = msg.Headers["www-authenticate"];
		if (!auth)
			return false;

		if (!this.ParseFullDestination(msg.Headers["to"], null, var server, null))
			return false;

		if (!this.ParseFullDestination(msg.Headers["from"], var target_user, null, null))
			return false;

		var key = sha256(target_user + "|" + server) + "@" + localhost;
		if (!IsSet(this.Registrations, key))
			return false;

		var registration = this.Registrations[key];
		if (!registration)
			return false;

		var authorization = this.WWWAuth(auth, registration.username, registration.password, "INVITE", registration.server, var nonce);
		session.msg.Headers["Authorization"] = authorization;

		session.auth = 2;
		session.write_timestamp = microseconds();
		session.write_server = [registration.server, registration.server_port];
		if (this.DoWrite(use_socket ?? udpclientsocket, session.msg.ToString(), registration.server, registration.server_port) <= 0)
			return null;

		return true;
	}

	PerformUDP(method, from, destination, payload = "", payload_type = "application/sdp", max_forwards = 70, parent_msg = null, extra_headers = null, ip = "", port = 0, cache_session = null, validation_delegate = null) {
		var msg = new SIPMessage();
		destination = ParseDestination(destination);
		msg.Destination = destination;
		if ((length destination > 2) && (destination[0] == "<") && (destination[length destination - 1] == ">"))
			msg.Destination = SubStr(destination, 1, (length destination) - 2);
		else
		if ((destination) && (destination[0] == "<"))
			msg.Destination = SubStr(destination, 1);

		msg.Method = ToUpper(method);
		if (extra_headers)
			msg.Headers = extra_headers;

		var callid;

		if (parent_msg)
			callid = parent_msg.Headers["call-id"];
		else
			callid = this.RandomString(32) + "@" + localhost;

		var server = "";
		var server_port = 0;
		var full_server = "";
		var arr = StrSplit(destination, "@");
		if (length arr == 2) {
			this.ParseHost(arr[1], server, server_port);
			if (server_port != 5060)
				full_server = server + ":" + server_port;
			else
				full_server = server;
		}

		if (parent_msg) {
			if ((msg.Method == "ACK") || (msg.Method == "CANCEL") || (msg.Method == "BYE") || (msg.Method == "NOTIFY")) {
				if ((msg.Method == "BYE") || (msg.Method == "NOTIFY") || ((parent_msg.ServerCode >= 200) && (parent_msg.ServerCode < 300))) {
					var branch = "z9hG4bK" + this.RandomString(14);
					msg.Branch = branch;
					msg.Headers["Via"] = "SIP/2.0/${Transport} " + full_host + ";rport;branch=" + branch;
				} else
					msg.Headers["Via"] = parent_msg.Headers["via"];
				msg.Headers["Max-Forwards"] = max_forwards;
				msg.Headers["From"] = parent_msg.LocalAddress ?? parent_msg.Headers["from"];
				msg.Headers["To"] = parent_msg.RemoteAddress ?? parent_msg.Headers["to"];
			} else {
				// =============== to check this ===================//
				branch = "z9hG4bK" + this.RandomString(14);
				msg.Headers["Via"] = "SIP/2.0/${Transport} " + full_host + ";rport;branch=" + branch;
				// =================================================//
				// msg.Headers["Via"] = parent_msg.Headers["via"];

				msg.Headers["Max-Forwards"] = max_forwards;

				msg.Headers["From"] = parent_msg.Headers["to"];
				msg.Headers["To"] = parent_msg.Headers["from"];
			}
		} else {
			branch = "z9hG4bK" + this.RandomString(14);
			msg.Headers["Via"] = "SIP/2.0/${Transport} " + full_server + ";rport;branch=" + branch;
			msg.Headers["Max-Forwards"] = max_forwards;
			msg.Headers["From"] = from;//username + " <" + sipproto + username + "@" + server + ">";
			msg.Headers["To"] = destination;
		}

		msg.Headers["Call-ID"] = callid;	
		if (parent_msg) {
			var cseq = value (parent_msg.Headers["cseq"]);
			if (msg.Method == "BYE")
				cseq++;
			msg.Headers["CSeq"] = "$cseq " + msg.Method;
		} else
			msg.Headers["CSeq"] = "1 " + msg.Method;
		if ((method != "ACK") && (method != "CANCEL")) {
			msg.Headers["Contact"] = from;//"<" + sipproto + username + "@" + localhost + ">";
			msg.Headers["Allow"] = SIP_ALLOW;
		}
		msg.Headers["Content-Length"] = length payload;

		if ((payload_type) && (payload)) {
			msg.Headers["Content-Type"] = payload_type;
			msg.PayloadBlob = payload;
		}

		if (cache_session) {
			if (validation_delegate)
				cache_session.Push([validation_delegate, msg]);
			else
				cache_session.Push(msg);
			msg.ip = cache_session.ip;
			msg.port = cache_session.port;
			return msg;
		}

		try {
			if ((ip) && (port)) {
				server = ip;
				server_port = port;
			}
			if (this.OnSend)
				this.OnSend(msg, server, server_port);

			// if (udpclientsocket.Write(msg.ToString(), server, server_port) <= 0)
			if (this.DoWrite(use_socket ?? udpclientsocket, msg.ToString(), server, server_port) <= 0)
				return null;
			return msg;
		} catch (var exc) {
			// nothing
		}
		return null;
	}

	WriteMessage(msg, ip = "", port = 0) {
		if (msg) {
			try {
				if ((!ip) && (msg.ip))
					ip = msg.ip;
				if ((!port) && (msg.port))
					port = msg.port;
				if (!port)
					port = 5060;
				if (!ip) {
					var destination;
					if (IsSet(msg.Headers, "To"))
						destination = msg.Headers["To"];
					else
						destination = msg.Headers["to"];
					destination = ParseDestination(destination);
					var server = "";
					var server_port = 0;
					var arr = StrSplit(destination, "@");
					if (length arr == 2)
						this.ParseHost(arr[1], server, server_port);
					if (server) {
						ip = server;
						port = server_port;
					}

					if (this.OnSend)
						this.OnSend(msg, ip, port);
				}

				// if (udpclientsocket.Write(msg.ToString(), ip, port) <= 0)
				if (this.DoWrite(use_socket ?? udpclientsocket, msg.ToString(), ip, port) <= 0)
					return false;
				return true;
			} catch (var exc) {
				// nothing
			}
		}
		return false;
	}

	ResponseUDP(code, parent_msg, destination, payload = "", payload_type = "application/sdp", max_forwards = 70, extra_headers = null, contact = "", ip = "", port = 0, add_tag = false) {
		var msg = parent_msg.GenerateResponse(code);

		var server = "";
		var server_port = 0;
		var full_server = "";

		var via = parent_msg.Headers["via"];
		if (via) {
			this.ParseVia(parent_msg, server, server_port);
			full_server = "$server:$server_port";
		} else
			return null;


		msg.Destination = sipproto + server;
		if (server_port != 5060)
			msg.Destination += ":" + server_port;
		msg.Method = "";
		if (extra_headers)
			msg.Headers = extra_headers;

		var branch = "z9hG4bK" + this.RandomString(14);
		var callid;

		if (parent_msg)
			callid = parent_msg.Headers["call-id"];
		else
			callid = this.RandomString(32) + "@" + localhost;

		//msg.Headers["From"] = parent_msg.Headers["from"];
		//msg.Headers["To"] = parent_msg.Headers["to"];

		msg.Headers["From"] = parent_msg.Headers["from"];//parent_msg.Destination;//username + " <sip:" + username + "@" + localhost + ">";
		msg.Headers["To"] = parent_msg.Headers["to"];//destination;

		if (add_tag) {
			var from = msg.Headers["From"];
			var to = msg.Headers["To"];
			if (Pos(from, ";tag=") <= 0) {
				from += ";tag=" + this.RandomString(20);
				msg.Headers["From"] = from;
			}
			if (Pos(to, ";tag=") <= 0) {
				to += ";tag=" + this.RandomString(20);
				msg.Headers["to"] = to;
			}
		}

		if (parent_msg)
			msg.Headers["Via"] = parent_msg.Headers["via"];
		else
			msg.Headers["Via"] = "SIP/2.0/${Transport} " + full_server + ";rport;branch=" + branch;
		msg.Headers["Max-Forwards"] = max_forwards;

		msg.Headers["Call-ID"] = callid;	
		msg.Headers["Allow"] = SIP_ALLOW;
		msg.Headers["Supported"] = SIP_SUPPORTED;
		if (parent_msg) {
			var cseq = value (parent_msg.Headers["cseq"]);
			msg.Headers["CSeq"] = "$cseq " + parent_msg.Method;
		}
		if (contact)
			msg.Headers["Contact"] = contact;
		else
		if ((parent_msg) && (code >= 200) && (code <= 300)) {
			to = msg.Headers["To"];
			var username = "";
			if (to)
				this.ParseFullDestination(to, username, null, null);
			if (!username)
				username = "Anonymous";

			msg.Headers["Contact"] = "<" + sipproto + username + "@" + full_host + ">";
		}
		/*else
			msg.Headers["Contact"] = parent_msg.Destination;//"<sip:" + username + "@" + localhost + ">";*/

		msg.Headers["Content-Length"] = length payload;

		if ((payload_type) && (payload)) {
			msg.Headers["Content-Type"] = payload_type;
			msg.PayloadBlob = payload;
		}

		try {
			if (ip)
				server = ip;
			if (port)
				server_port = port;

			if (this.OnSend)
				this.OnSend(msg, server, server_port);
			// if (udpclientsocket.Write(msg.ToString(), server, server_port) <= 0)
			if (this.DoWrite(use_socket ?? udpclientsocket, msg.ToString(), server, server_port) <= 0)
				return null;
			return msg;
		} catch (var exc) {
			// nothing
		}
		return null;
	}

	private Ack(msg, ip = "", port = 0, max_forwards = 70) {
		var contact = msg.Headers["contact"];
		if (!contact)
			contact = msg.Headers["from"];

		var msg2 = null;
		if (contact)
			msg2 = PerformUDP("ACK", msg.Headers["to"], contact, "", "", max_forwards, msg, null, ip, port);
		return msg2;
	}

	public ReferSimple(msg, address, ip = "", port = 0, max_forwards = 70) {
		var contact = msg.Headers["contact"];
		if (!contact)
			contact = msg.Headers["from"];

		var msg2 = null;
		if (contact)
			msg2 = PerformUDP("REFER", msg.Headers["to"], contact, "", "", max_forwards, msg, ["Refer-To" => address, "Referred-By" => contact], ip, port);

		return msg2;
	}

	protected RejectOthers(session, ref_session) {
		var others = 0;
		for (var i = 0; i < length session.Children; i++) {
			var child = session.Children[i];
			if ((child) && (child != ref_session)) {
				others++;
				child.OnMessage = null;
				child.Parent = null;
				if (child._private_data)
					child.Cancel(true);
				else
					child.Bye(true);
				child._private_data = null;
			}
		}
		session.Children = new [];
		session.Children[0] = ref_session;
		return others;
	}

	public ReferProxy(msg, address, max_forwards = 70, contact = "") {
		if (!msg)
			return null;

		if (!contact) {
			if (msg.Local) {
				contact = msg.Headers["to"];
			} else {
				contact = msg.Headers["contact"];
				if (!contact)
					contact = msg.Headers["from"];
			}
		}

		if (contact) {
			var session = this.GetSession(msg);
			if (session) {
				var child_session = this.Invite(address, contact, max_forwards);
				if (child_session) {
					child_session._private_data = session.CallID;
					session.AddChild(child_session);
					child_session.OnMessage = function(child_session, msg, parent_session) {
						var session = this.GetSessionById(child_session._private_data);
						if (!session)
							session = parent_session;

						if (session) {
							if ((msg.ServerCode >= 200) && (msg.ServerCode < 300)) {
								// session is already removed
								if (!session.ChildIsValid(child_session))
									return true;
								session.ResetBuffers();
								child_session._private_data = null;
								child_session.ResetBuffers();
								child_session.OnMessage = null;
								if (!session.Referred)
									this.RejectOthers(session, child_session);
								session.Referred = true;
								if (!session.accept_bye)
									session.Accept(msg.ServerCode);
								if (session.OnReferred)
									session.OnReferred(child_session);
							} else
							if (msg.ServerCode >= 300) {
								// is authorization
								if ((msg.ServerCode == 401) && (this.Registrations) && (child_session.is_invite == true) && (child_session.auth == 2) && (msg.Headers["www-authenticate"]))
									return true;
								// busy/redirect/etc
								var child_len = length session.Children;
								if (msg.ServerCode >= 400)
									child_len++;

								var canceled = false;
								if ((msg.ServerCode >= 400) && (child_len <= 1)) {
									session.Cancel(true, msg.ServerCode);
									canceled = true;
								}

								if (child_len) {
									child_session.Parent = null;
									child_session._private_data = null;
								}
								child_session.End(true, msg);
								// child_session.Cancel(true);
								child_session.OnMessage = null;
								if (session.OnReferError) {
									if (session.OnReferError(session, msg))
										return;
								}
								if (!canceled) {
									if (child_len <= 1)
										session.Bye(true);
									else
										session.RemoveChild(child_session);
								}
							} else {
								this.ResponseUDP(msg.ServerCode, session.msg, session.msg.Headers["from"], "", "", 70, null, "", session.ip, session.port);
							}
						}
					};
					return true;
				}
			}
		}
		return false;
	}

	public Refer(msg, address, max_forwards = 70, contact = "") {
		return this.ReferProxy(msg, address, max_forwards, contact);
	}

	public ReferDialog(msg, address, target_dialog, ip = "", port = 0, max_forwards = 70) {
		var contact = msg.Headers["contact"];
		if (!contact)
			contact = msg.Headers["from"];

		var msg2 = null;
		if (contact) {
			var session = this.GetSession(msg);
			var extra_headers = ["Refer-To" => address, "Tartget-Dialog" => target_dialog + ";tag=" + this.RandomString(20)];
			msg2 = this.PerformUDP("REFER", msg.Headers["to"], contact, "", "", 70, msg, extra_headers, "", 0, session, function(msg, new_msg) {
				if ((msg.ServerCode >= 200) && (msg.ServerCode < 300))
					return true;
				else
				if ((msg.ServerCode < 100) && (msg.ServerCode >= 300)) {
					var session = this.GetSession(msg);
					if (session)
						session.ClearStack();
				}
				return false;
			});
		}
		return msg2;
	}

	public ReferHold(msg, address, target_dialog = "", ip = "", port = 0, max_forwards = 70) {
		var contact = msg.Headers["contact"];
		if (!contact)
			contact = msg.Headers["from"];

		var msg2 = null;
		if (contact) {
			var session = this.GetSession(msg);
			this.Reinvite(msg.Headers["from"], msg.Headers["to"], msg.Headers["call-id"], "", "", "sendonly");
			msg2 = PerformUDP("REFER", msg.Headers["to"], contact, "", "", 70, msg, ["Refer-To" => address, "Referred-By" => contact], "", 0, session, function(msg, new_msg) {
				if ((msg.ServerCode >= 200) && (msg.ServerCode < 300))
					return true;
				else
				if ((msg.ServerCode < 100) && (msg.ServerCode >= 300)) {
					var session = this.GetSession(msg);
					if (session)
						session.ClearStack();
				}
				return false;
			});
		}
		return msg2;
	}

	Bye(msg, ip = "", port = 0, max_forwards = 70) {
		var contact = msg.Headers["contact"];
		if (!contact)
			contact = msg.Headers["from"];
		var msg2 = null;
		if (contact)
			msg2 = PerformUDP("BYE", msg.Headers["to"], contact, "", "", max_forwards, msg, null, ip, port);
		return msg2;
	}

	Cancel(msg, ip = "", port = 0, max_forwards = 70) {
		var msg2 = null;

		var contact = msg.Headers["contact"];
		if (!contact)
			contact = msg.Headers["from"];

		if (contact)
			msg2 = PerformUDP("CANCEL", msg.Headers["to"], contact, "", "", max_forwards, msg, null, ip, port);
		return msg2;
	}

	DoRead(socket, var ip, var port) {
		var type = classof socket;
		if (type[0] == "U")
			return socket.Read(ip, port);
		ip = "";
		port = 0;

		var buffer = "";
		do {
			var read = socket.Read(1);
			if (!read)
				break;

			buffer += read;
		} while (Pos(buffer, "\r\n\r\n") <= 0);

		var buf_lo = ToLower(buffer);
		var pos = Pos(buf_lo, "content-length");
		if (pos > 0) {
			var len = value SubStr(buf_lo, pos + 14);
			while (len > 0) {
				var buf2 = socket.Read(len);
				if (!buf2)
					break;
				buffer += buf2;
				len -= length buf2;
			}
		}
		ip = socket.Info["address"];
		port = socket.Info["port"];
		return buffer;
	}

	Peek(msg, ip, port, max_forwards = 70) {
		if (this.OnRecv)
			this.OnRecv(msg, ip, port);
		if (((msg.ServerCode >= 200) || (!msg.ServerCode)) && (msg.Method == "") && (!Pos(""+msg.Headers["cseq"], " ACK"))) {
			if (this.ContactNonRoutable(msg.Headers))
				this.Ack(msg, ip, port, max_forwards);
			else
				this.Ack(msg, "", 0, max_forwards);
		}
	}

	PeekMessage(var ip, var port, max_forwards = 70) {
		try {
			if (udpclientsocket.HasData) {
				// var msg = this.Parse(udpclientsocket.Read(ip, port));
				var msg = this.Parse(this.DoRead(udpclientsocket, ip, port));
				if (msg) {
					this.Peek(msg, ip, port, max_forwards);
					return msg;
				}
			}
		} catch (var exc) {
			// nothing
		}
		return null;
	}

	RemoveTCPSocket(socket) {
		var[] new_sockets;
		for (var i = 0; i < length TCPSockets; i++) {
			var tcpsocket = TCPSockets[i];
			if ((tcpsocket) && (tcpsocket != socket))
				new_sockets[length new_sockets] = tcpsocket;
		}
		TCPSockets = new_sockets;
	}

	PeekMessageTCP(var ip, var port, var clientsocket, max_forwards = 70) {
		try {
			clientsocket = null;
			if (tcpsocket.HasData) {
				var socket = tcpsocket.Accept();
				if (socket) {
					socket.SetOption(IPPROTO_TCP, TCP_NODELAY, 1);
					socket.SetOption(IPPROTO_IP, IP_TOS, 0x10);
					socket.SetOption(SOL_SOCKET, SO_KEEPALIVE, 1);
					socket.SetOption(SOL_SOCKET, SO_LINGER, 0);
					TCPSockets[length TCPSockets] = socket;
				}
			}
			for (var i = 0; i < length TCPSockets; i++) {
				socket = TCPSockets[i];
				if ((socket) && (socket.HasData)) {
					try {
						var data = this.DoRead(socket, ip, port);
						if (!data)
							throw "Broken connection";
						var msg = this.Parse(data);
						if (msg) {
							this.Peek(msg, ip, port, max_forwards);
							clientsocket = socket;
							return msg;
						}
					} catch (var exc) {
						var session = this.SessionBySocket(socket);
						if (session)
							session.Cancel(true);
						RemoveTCPSocket(socket);
					}
				}
			}
		} catch (exc) {
			// nothing
		}
		return null;
	}

	CreateSession(msg, ip, port, check_branch = false) {
		var id = msg.Headers["call-id"];
		if (id) {
			var parent_session = Sessions[id];
			var branch = this.ParseBranch(msg);
			if (parent_session) {
				if ((check_branch) && (branch)) {
					if (branch != parent_session.Branch) {
						parent_session.msg = msg;
						parent_session.Branch = branch;
						parent_session.UpdateMedia(msg, ip, port);
						parent_session.NoForward = true;
						return parent_session;
					}
				}
				echo "Session $id already exists\n";
				return null;
			}

			var session = new SIPSession(this, msg, rtp_port_index++, ip, port, this.FrameSize, MaxTime);
			session.Branch = branch;
			if (rtp_port_index > RTP_END_PORT)
				rtp_port_index = RTP_START_PORT;
			Sessions[id] = session;
			return session;
		}
		return null;
	}


	RemoveSession(msg) {
		var id = msg.Headers["call-id"];
		if (id) {
			if (IsSet(Sessions, id)) {
				var sessions = Sessions;
				var res = sessions[id];
				var new_sessions = new [];
				for (var i = 0; i < length sessions; i++) {
					var sess = sessions[i];	
					if ((sess) && (sess.CallID != id))
						new_sessions[sess.CallID] = sess;
				}
				Sessions = new_sessions;
				this.CleanSession(res, msg.ServerCode);
				return res;
			}
		}
		return null;
	}

	GetSession(msg) {
		var id = msg.Headers["call-id"];
		if (id)
			return this.GetSessionById(id);
		return null;
	}

	GetSessionById(id) {
		if (id) {
			if (IsSet(Sessions, id))
				return Sessions[id];
		}
		return null;
	}

	CleanSession(session, code = 0) {
		if (session) {
			var parent = session.Parent;
			if (parent) {
				if (length parent.Children <= 1) {
					session.Parent = null;
					if (code >= 400)
						parent.End(true);
					else
					if (parent._private_data)
						parent.Cancel(true);
					else
						parent.Bye(true);
				}
				parent.RemoveChild(session);
			}

			for (var i = 0; i < length session.Children; i++) {
				var child = session.Children[i];
				if (child._private_data)
					child.Cancel(true);
				else
					child.Bye(true);
			}
		}
	}

	RemoveSessionByRef(session, code = 0) {
		if ((session) && (IsSet(Sessions, session.CallID))) {
			var sessions = Sessions;

			var new_sessions = new [];
			var id = session.CallID;
			for (var i = 0; i < length sessions; i++) {
				var sess = sessions[i];	
				if ((sess) && (sess.CallID != id))
					new_sessions[sess.CallID] = sess;
			}
			Sessions = new_sessions;
			CleanSession(session, code);
			return true;
		}
		return false;
	}

	SessionBySocket(socket) {
		if (!socket)
			return null;

		for (var i = 0; i < length Sessions; i++) {
			var session = Sessions[i];
			if ((session) && (session.tcp_socket == socket))
				return session;
		}
		return null;
	}

	TerminateSession(msg) {
		var id = msg.Headers["call-id"];
		if (id) {
			if (IsSet(Sessions, id)) {
				var sess = Sessions[id];
				if (sess) {
					sess.Bye();
					return true;
				}
			}
		}
		return false;
	}

	ParseFullDestination(destination, var user, var server, var port) {
		var arr = StrSplit(destination, "@");
		if (length arr == 2) {
			user = arr[0];
			var pos = Pos(user, ":");
			if (pos > 0) {
				user = SubStr(user, pos, length user);
			}
			this.ParseHost(arr[1], server, port);
			return true;
		} else
		if ((length arr == 1) && (destination[0] == "<")) {
			user = "Anonymous";
			this.ParseHost(SubStr(destination, 1), server, port);
		}
		return false;
	}

	TextMessage(destination, username, text, content_type = "text/plain", max_forwards = 70) {
		var msg = new SIPMessage();
		msg.Method = "MESSAGE";

		var server = "";
		var server_port = 0;
		var full_server = "";

		var destination_parsed = ParseFullDestination(destination, var target_user, server, server_port);
		if (!destination_parsed)
			target_user = destination;

		if ((target_user) && (IsSet(Users, target_user))) {
			var uinfo = Users[target_user];
			if ((uinfo) && (!uinfo.Expired())) {
				if (uinfo.non_routable) {
					if (uinfo.ip)
						server = uinfo.ip;
					if (uinfo.port)
						server_port = uinfo.port;
				}
			} else
				return false;
		}
		if ((!server) || (!server_port))
			return false;

		if (server_port != 5060)
			full_server = server + ":" + server_port;
		else
			full_server = server;

		if (Pos(username, "@") > 0) {
			var user_destination = username;
			var local_server = "";
			var local_port = 0;
			ParseFullDestination(user_destination, var username2, local_server, local_port);
			username = username2;
		}

		msg.Destination = sipproto + "${target_user}@${full_server}";

		var branch = "z9hG4bK" + this.RandomString(14);
		var callid = this.RandomString(32) + "@" + localhost;

		msg.Headers["via"] = "SIP/2.0/${Transport} " + this.full_host + ";rport;branch=" + branch;
		msg.Headers["max-forwards"] = max_forwards;

		msg.Headers["from"] = sipproto + username + "@" + this.localhost + ";tag="+this.RandomString(20);
		msg.Headers["to"] = sipproto + "${target_user}@${full_server}";
		msg.Headers["contact"] = "<" + sipproto + username + "@" + this.full_host + ">";

		msg.Headers["call-id"] = callid;
		msg.Headers["cseq"] = "1 " + msg.Method;

		msg.Headers["content-length"] = length text;
		msg.Headers["content-type"] = content_type;
		msg.PayloadBlob = text;
		try {
			if (this.OnSend)
				this.OnSend(msg, server, server_port);

			// if (udpclientsocket.Write(msg.ToString(), server, server_port) <= 0)
			if (this.DoWrite(use_socket ?? udpclientsocket, msg.ToString(), server, server_port) <= 0)
				return false;
		} catch (var exc) {
			// nothing
		}
		return true;
	}

	DecodeURL(str) {
		var str_decoded = "";
		for (var i = 0; i < length str; i++) {
			var char = str[i];
			if (char == "%") {
				i++;
				var hex = str[i] + str[i+1];
				str_decoded += HexToString(hex);
				i++;
			} else
				str_decoded += char;
		}
		return str_decoded;
	}

	ParseReferURL(url) {
		var arr = StrSplit(url, ";");
		var[] keys;
		if (arr) {
			keys["call-id"] = arr[0];
			for (var i = 1; i < length arr; i++) {
				var e = arr[i];
				if (e) {
					var arr2 = StrSplit(e, "=");
					if (length arr2 == 2) {
						var k = ToLower(trim(arr2[0]));
						if (k)
							keys[k] = trim(arr2[1]);
					}
				}
			}
		}
		return keys;
	}

	ReferSession(sess, msg, var refer) {
		var to = msg.Headers["refer-to"];
		var pos = Pos(ToLower(to), "?replaces=");
		refer = null;
		if (pos > 0) {
			pos += 9;
			var sub_str = trim(SubStr(to, pos));
			if ((sub_str) && (sub_str[length sub_str - 1] == ">"))
				sub_str = trim(SubStr(sub_str, 0, length sub_str - 1));
			var url = DecodeURL(sub_str);
			refer = ParseReferURL(url);
			return 202;
		}
		return 603;
	}

	NotifyRefer(sess, msg, refer, ip = "", port = 0) {
		var contact = msg.Headers["contact"];
		if (!contact)
			contact = msg.Headers["from"];

		if (contact) {
			var server = "";
			var server_port = 0;

			this.ParseVia(msg, server, server_port);

			if (ip)
				server = ip;
			if (port)
				server_port = port;

			var msg2 = PerformUDP("NOTIFY", msg.Headers["to"], contact, "SIP/2.0 200 OK\r\n", "message/sipfrag", 70, msg, ["Event" => "refer", "Subscription-State" => "terminated;reason=noresource"]);
			try {
				sess.Branch = msg2.Branch;
				if (this.OnSend)
					this.OnSend(msg2, server, server_port);

				// udpclientsocket.Write(msg2.ToString(), server, server_port);
				this.DoWrite(use_socket ?? udpclientsocket, msg2.ToString(), server, server_port);
			} catch (var exc) {
				// nothing
			}
		}

	}

	Invite(destination, username, max_forwards = 70, parent_session = null, validation_delegate = null) {
		var msg = new SIPMessage();
		msg.Method = "INVITE";
		var server = "";
		var server_port = 0;
		var full_server = "";

		var destination_parsed = ParseFullDestination(destination, var target_user, server, server_port);
		if (!destination_parsed)
			target_user = destination;

		if ((target_user) && (IsSet(Users, target_user))) {
			var uinfo = Users[target_user];
			if ((uinfo) && (!uinfo.Expired())) {
				if ((uinfo.non_routable) || (!server)) {
					if (uinfo.ip)
						server = uinfo.ip;
					if (uinfo.port)
						server_port = uinfo.port;
				}
			} else {
				return null;
			}
		}
		if ((!server) || (!server_port))
			return null;

		if (server_port != 5060)
			full_server = server + ":" + server_port;
		else
			full_server = server;

		if (Pos(username, "@") > 0) {
			var user_destination = username;
			var local_server = "";
			var local_port = 0;
			ParseFullDestination(user_destination, var username2, local_server, local_port);
			username = username2;
		}

		//msg.Destination = destination;
		msg.Destination = sipproto + "${target_user}@${full_server}";

		var branch = "z9hG4bK" + this.RandomString(14);
		var callid = this.RandomString(32) + "@" + localhost;

		msg.Headers["via"] = "SIP/2.0/${Transport} " + this.full_host + ";rport;branch=" + branch;
		msg.Headers["max-forwards"] = max_forwards;

		var tag = this.RandomString(20);
		msg.Headers["from"] = "<" + sipproto + username + "@" + this.localhost + ">;tag=" + tag;
		msg.Headers["to"] = "<" + sipproto + "${target_user}@${full_server}>";//"sip:${target_user}@${localhost}";//destination;
		msg.Headers["contact"] = "<" + sipproto + username + "@" + this.full_host + ">";
		msg.Headers["call-id"] = callid;
		if (parent_session)
			msg.Headers["cseq"] = "3 " + msg.Method;
		else
			msg.Headers["cseq"] = "1 " + msg.Method;
		msg.Headers["supported"] = "outbound";

		msg.Headers["allow"] = SIP_ALLOW;

		msg.Headers["supported"] = SIP_SUPPORTED;
		msg.Headers["session-expires"] = "3600;refresher=uac";

		var sess = this.CreateSession(msg, server, server_port);
		if (sess) {
			sess.is_invite = true;
			var payload = sess.GetSDP();
			var payload_type = "application/sdp";
			msg.Headers["content-length"] = length payload;
			msg.Headers["content-type"] = payload_type;
			msg.PayloadBlob = payload;

			if (parent_session) {
				msg.ParentCallID = parent_session.CallID;
				if (validation_delegate)
					parent_session.Push([validation_delegate, msg]);
				else
					parent_session.Push(msg);
				return sess;
			}
			try {
				if (this.OnSend)
					this.OnSend(msg, server, server_port);

				sess.ip = this.IPFromName(server);
				sess.port = server_port;
				sess.write_timestamp = microseconds();
				sess.write_server = [server, server_port];
				if (this.DoWrite(use_socket ?? udpclientsocket, msg.ToString(), server, server_port) <= 0)
					return null;
				return sess;
			} catch (var exc) {
				// nothing
			}
		}
		return null;
	}

	Reinvite(destination, from, callid, branch = "", ftag = "", extra_sdp = "", sdp_payload = "", max_forwards = 70, parent_session = null, validation_delegate = null) {
		var msg = new SIPMessage();
		msg.Method = "INVITE";

		var server = "";
		var server_port = 0;
		var full_server = "";

		var destination_parsed = ParseFullDestination(destination, var target_user, server, server_port);
		if (!destination_parsed)
			target_user = destination;

		if ((target_user) && (IsSet(Users, target_user))) {
			var uinfo = Users[target_user];
			if ((uinfo) && (!uinfo.Expired())) {
				if ((uinfo.non_routable) || (!server)) {
					if (uinfo.ip)
						server = uinfo.ip;
					if (uinfo.port)
						server_port = uinfo.port;
				}
			} else {
				return null;
			}
		}
		if ((!server) || (!server_port))
			return null;

		if (server_port != 5060)
			full_server = server + ":" + server_port;
		else
			full_server = server;

		msg.Destination = sipproto + target_user + "@" + full_server;

		if (!branch)
		    branch = "z9hG4bK" + this.RandomString(14);

		msg.Headers["via"] = "SIP/2.0/${Transport} " + this.full_host + ";rport;branch=" + branch;
		msg.Headers["max-forwards"] = max_forwards;


		msg.Headers["from"] = from;
		msg.Headers["to"] = destination;
		if (ftag)
			msg.Headers["to"] += ";tag=$ftag";
		if ((extra_sdp == "sendonly") || (extra_sdp == "recvonly"))
			msg.Headers["contact"] = from + ";+sip.rendering=\"no\"";
		else
			msg.Headers["contact"] = from;

		msg.Headers["call-id"] = callid;
		msg.Headers["cseq"] = "2 " + msg.Method;
		msg.Headers["supported"] = "outbound";

		msg.Headers["allow"] = SIP_ALLOW;

		msg.Headers["supported"] = SIP_SUPPORTED;
		msg.Headers["session-expires"] = "3600;refresher=uac";
    		
		var sess = parent_session ?? GetSession(msg);
		if (sess) {
			sess.is_invite = true;
			var payload = sdp_payload ?? sess.GetSDP(8, extra_sdp);
			var payload_type = "application/sdp";
			msg.Headers["content-length"] = length payload;
			msg.Headers["content-type"] = payload_type;
			msg.PayloadBlob = payload;

			if (parent_session) {
				if (validation_delegate)
					parent_session.Push([validation_delegate, msg]);
				else
					parent_session.Push(msg);
				return msg;
			}
			try {
				if (this.OnSend)
					this.OnSend(msg, server, server_port);

				// if (udpclientsocket.Write(msg.ToString(), server, server_port) <= 0)
				if (this.DoWrite(use_socket ?? udpclientsocket, msg.ToString(), server, server_port) <= 0)
					return null;
				return msg;
			} catch (var exc) {
				// nothing
			}
		}
		return null;
	}


	KeepAlive(ip, port) {
		try {
			// if (udpclientsocket.Write("\r\n", ip, port) <= 0)
			if (this.DoWrite(use_socket ?? udpclientsocket, "\r\n", ip, port) <= 0)
				return false;
			return true;
		} catch (var exc) {
			// nothing
		}
	}

	ParseHost(full_host, var host, var port) {
		port = 5060;
		if (full_host) {
			var arr = StrSplit(full_host, ":");
			if (length arr == 2) {
				host = arr[0];
				port = value arr[1];
			} else
				host = full_host;
			if (host)
				host = StrSplit(host, ">")[0];
		}
	}

	ParseBranch(msg) {
		var branch = msg.Branch;
		if (branch)
			return branch;
		var via = msg.Headers["via"];
		if (via) {
			if (typeof via == "array")
				via = via[0];
			var arr = StrSplit(via, " ");
			if (length arr >= 2) {
				var arr2 = StrSplit(arr[1], ";");
				for (var i = 1; i < length arr2; i++) {
					var arr3 = StrSplit(arr2[i], "=");
					if ((length arr3 == 2) && (trim(ToLower(arr3[0])) == "branch")) {
						branch = trim(arr3[1]);
						msg.Branch = branch;
						break;
					}
				}
			}
		}
		return branch;
	}

	ParseVia(msg, var host, var port, var protocol = null) {
		if (msg) {
			var via = msg.Headers["via"];
			if (via) {
				if (typeof via == "array")
					via = via[0];
				var arr = StrSplit(via, " ");
				if (length arr >= 2) {
					protocol = arr[0];
					ParseHost(StrSplit(arr[1], ";")[0], host, port);
				}
			}
		}
	}

	RequestAuth(msg, algorithm = "md5") {
		var nonce = md5(RandomString(32));
		var extra_headers = new [];
		extra_headers["WWW-Authenticate"] = "Digest realm=\"${this.realm}\", qop=\"auth\", nonce=\"$nonce\", algorithm=$algorithm";
		return extra_headers;
	}

	CheckAuth(auth, password, nonce = "", method = "REGISTER") {
		var res = ParseAuth(auth);
		if (!nonce)
			nonce = res["nonce"];
		var username = res["username"];
		var uri = res["uri"];

		if (typeof password == "delegate")
			password = password(username);

		if ((res["nonce"]) && (res["realm"]) && (res["response"]) && (username) && (uri)) {
			var alg = res["algorithm"];
			if (!alg) {
				switch (length res["response"]) {
					case 32:
						alg = "md5";
						break;
					case 40:
						alg = "sha1";
						break;
					case 64:
					default:
						alg = "sha256";
						break;
				}
			} else
				alg = ToLower(alg);
			var qop = ToLower("" + res["qop"]);
			switch (alg) {
				case "sha1":
					var ha1 = sha1(username + ":" + res["realm"] + ":" + password);
					var ha2 = sha1(method + ":" + uri);
					if ((qop == "auth") || (qop == "auth-int"))
						var response = sha1(ha1 +":" + nonce + ":" + res["nc"] + ":" + res["cnonce"] + ":" + qop + ":" + ha2);
					else
						response = sha1(ha1 +":" + nonce + ":" + ha2);
					break;
				case "sha256":
					ha1 = sha256(username + ":" + res["realm"] + ":" + password);
					ha2 = sha256(method + ":" + uri);
					if ((qop == "auth") || (qop == "auth-int"))
						response = sha256(ha1 +":" + nonce + ":" + res["nc"] + ":" + res["cnonce"] + ":" + qop + ":" + ha2);
					else
						response = sha256(ha1 +":" + nonce + ":" + ha2);
					break;
				default:
					ha1 = md5(username + ":" + res["realm"] + ":" + password);
					ha2 = md5(method + ":" + uri);
					if ((qop == "auth") || (qop == "auth-int"))
						response = md5(ha1 +":" + nonce + ":" + res["nc"] + ":" + res["cnonce"] + ":" + qop + ":" + ha2);
					else
						response = md5(ha1 +":" + nonce + ":" + ha2);

			}
			if (response == res["response"])
				return 200;
		}
		return 401;
	}

	BuildContact(username) {
		return "<" + sipproto + username + "@" + full_host + ">";
	}

	NonRoutable(ip) {
		if (!this.NATFriendly)
			return false;

		var arr = StrSplit(ip, ".");
		if (length arr >= 4) {
			switch (trim(arr[0])) {
					case "10":
						return true;
					case "192":
						if (trim(arr[1]) == "168")
							return true;
						break;
					case "172":
						var b = value arr[1];
						if ((b >= 16) && (b <= 31))
							return true;
						break;
			}
		} else
		if (length ip > 3) {
			// ipv6 ?
			if (ip[0] == "[")
				ip++;
			ip = ToLower(trim(ip));
			if (ip[0] + ip[1] == "fd")
				return true;
		}
		return false;
	}

	ContactNonRoutable(headers) {
		if (!headers)
			return false;
		var route = "";
		if (IsSet(headers, "contact"))
			route = headers["contact"];
		if ((!route) && (IsSet(headers, "via")))
			route = headers["via"];
		if (typeof route == "array")
			route = route[0];

		if (route) {
			var arr = StrSplit(route, "@");
			var ip = arr[1];
			if (ip)
				return NonRoutable(ip);
		}
		return false;
	}

	Iterate() {
		var sessions = this.Sessions;
		var ops = 0;
		for (var i = 0; i < length sessions; i++) {
			var session = sessions[i];
			if (session)
				ops += session.Iterate();
		}
		var msg;
		use_socket = null;
		if (tcp) {
			msg = this.PeekMessageTCP(var ip, var port, use_socket);
			if (!msg)
				msg = this.PeekMessage(ip, port);
		} else
			msg = this.PeekMessage(ip, port);

		if (msg) {
			if (this.OnFilter) {
				if (this.OnFilter(msg, ip, port)) {
					ops++;
					return;
				}
			}
			var routable_ip = "";
			var routable_port = 0;
			ops++;
			var non_routable = this.ContactNonRoutable(msg.Headers);
			if (this.OnNeedAuthorization) {
				var auth_code = this.OnNeedAuthorization(msg);
				if (auth_code) {
					this.ResponseUDP(auth_code, msg, msg.Headers["from"]);
					return;
				}
			}
			if ((msg.Method != "REGISTER") && (!ValidOrigin(ip))) {
				if (OnInvalidSource) {
					if (!OnInvalidSource(msg, ip, port))
						return;
				} else
					return;
			}

			var extra_headers;
			switch (msg.Method) {
				case "INVITE":
					SIPSession::EnsureTag(msg.Headers["from"]);
					SIPSession::EnsureTag(msg.Headers["to"]);
					var sess = this.CreateSession(msg, ip, port, true);
					if (sess) {
						if (non_routable)
							this.ResponseUDP(180, msg, msg.Headers["from"], "", "", 70, null, "", sess.ip, sess.port);
						else
							this.ResponseUDP(180, msg, msg.Headers["from"]);

						if (this.OnInvite)
							this.OnInvite(sess, msg);
					} else {
						echo "Cannot create session (session/branch already exists?)\n";
						// this.ResponseUDP(430, msg, msg.Headers["from"], "", "", 70, null, "", ip, port);
					}
					break;
				case "REGISTER":
					var register_response = 401;
					var auth = "";
					if (IsSet(msg.Headers, "authorization"))
						auth = msg.Headers["authorization"];
					if (!auth)
						extra_headers = RequestAuth(msg);

					if (this.OnRegister)
						register_response = this.OnRegister(msg, auth, extra_headers);
					var contact = "";
					if ((register_response == 200) && (auth)) {
						var pauth = ParseAuth(auth);
						var username = pauth["username"];
						if (username) {
							var uinfo = Users[username];
							if (!uinfo) {
								uinfo = new SIPUserInfo(username);
								Users[username] = uinfo;
							}
							uinfo.non_routable = non_routable;
							if ((RegisterTimeout > 0) || (NonRoutableRegisterTimeout > 0)) {
								var timeout = RegisterTimeout;
								if (non_routable)
									timeout = NonRoutableRegisterTimeout;
								if (timeout > 0) {
									if (username)
										contact = BuildContact(username) + ";" + "expires=" + timeout;
								}
								uinfo.Update(timeout);
							}
							uinfo.ip = ip;
							uinfo.port = port;
							uinfo.contact = msg.Headers["contact"];
						}
					}
					if (non_routable) {
						routable_ip = ip;
						routable_port = port;
					}
					this.ResponseUDP(register_response, msg, msg.Headers["from"], "", "", 70, extra_headers, contact, routable_ip, routable_port);
					break;
				case "NOTIFY":
					// message
					var code = 200;
					if (this.OnNotify)
						code = this.OnNotify(msg);
					if (this.ContactNonRoutable(msg.Headers))
						this.ResponseUDP(code, msg, msg.Headers["from"], "", "", 70, null, "", ip, port);
					else
						this.ResponseUDP(code, msg, msg.Headers["from"]);
					if (this.OnAfterNotify)
						this.OnAfterNotify(msg);
					break;
				case "CANCEL":
				case "BYE":
					sess = this.RemoveSession(msg);
					if (sess) {
						this.ResponseUDP(200, msg, msg.Headers["from"], "", "", 70, null, "", sess.ip, sess.port);
						if (this.OnEnd)
							this.OnEnd(sess, msg, msg.Headers["reason"]);
					} else {
						// Cannot remove non-existing session;
						if (non_routable)
							this.ResponseUDP(481, msg, msg.Headers["from"], "", "", 70, null, "", ip, port);
						else
							this.ResponseUDP(481, msg, msg.Headers["from"]);
					}
					break;
				case "ACK":
					// ignore it
					break;
				case "MESSAGE":
					var message_response = 202;
					if (this.OnTextMessage) {
						message_response = this.OnTextMessage(msg);
						if (!message_response)
							message_response = 200;
					}
					if (non_routable)
						this.ResponseUDP(message_response, msg, msg.Headers["from"], "", "", 70, extra_headers, "", ip, port);
					else
						this.ResponseUDP(message_response, msg, msg.Headers["from"], "", "", 70, extra_headers);
					break;
				case "INFO":
					message_response = 415;
					sess = GetSession(msg);
					if (OnInfo)
						message_response = this.OnInfo(sess, msg);
					if ((sess) && (ToLower("" + msg.Headers["content-type"]) == "application/dtmf-relay")) {
						if (this.OnDTMFRelay) {
							var payload = msg.PayloadBlob;
							if (payload) {
								payload = StrReplace(ToLower(payload), " ", "");
								var pos = Pos(payload, "signal=");
								if (pos > 0) {
									var key = trim("" + StrSplit(SubStr(payload, pos + 6), "\n")[0]);
									if (key) {
										sess.DTMFHistory += key;
										this.OnDTMFRelay(sess, key);
									}
								}
							}
						}
						message_response = 200;
					}
					if (non_routable)
						this.ResponseUDP(message_response, msg, msg.Headers["from"], "", "", 70, extra_headers, "", ip, port);
					else
						this.ResponseUDP(message_response, msg, msg.Headers["from"], "", "", 70, extra_headers);
					break;
				case "REFER":
					message_response = 603;
					sess = GetSession(msg);
					var refer = null;
					if (sess)
						message_response = this.ReferSession(sess, msg, refer);

					if (non_routable)
						this.ResponseUDP(message_response, msg, msg.Headers["from"], "", "", 70, extra_headers, "", ip, port);
					else
						this.ResponseUDP(message_response, msg, msg.Headers["from"], "", "", 70, extra_headers);
					if (refer) {
						if (non_routable)
							this.NotifyRefer(sess, msg, refer, ip, port);
						else
							this.NotifyRefer(sess, msg, refer, ip, port);
					}
					break;
				case "PUBLISH":
					code = 200;
					if (this.OnPublish)
						code = this.OnPublish(msg);
					if (this.ContactNonRoutable(msg.Headers))
						this.ResponseUDP(code, msg, msg.Headers["from"], "", "", 70, null, "", ip, port);
					else
						this.ResponseUDP(code, msg, msg.Headers["from"]);
					if (this.OnAfterPublish)
						this.OnAfterPublish(msg);
					break;
				default:
					var parent = null;
					if (msg.FromServer) {
						var ctype = msg.Headers["content-type"];
						sess = null;
						if (!sess) {
							sess = GetSession(msg);
							if (sess) {
								sess.write_timestamp = 0;
								delete sess.write_server;
							}
						}

						if ((ctype) && (ToLower(ctype) == "application/sdp") && (msg.Payload)) {
							sess = GetSession(msg);
							if (sess)
								sess.UpdateMedia(msg, ip, port);
						}

						if ((msg.ServerCode >= 200) && (msg.ServerCode < 300)) {
							if ((sess) && (!session.bye_set)) {
								sess.bye_set = true;
								sess.accept_bye = true;
								sess.bye_msg = msg;
								sess.UpdateTags();
							}

							if ((sess) && (this.OnAnswered) && (sess.is_invite == true)) {
								var cseq = "" + msg.Headers["cseq"];
								if (Pos(cseq, " INVITE") > 0) {
									this.OnAnswered(sess, msg);
									sess.is_invite = 2;
								}
							}
							if ((!sess) && (this.Registrations) && (msg.ServerCode == 200))
								this.Register200(msg);
						}

						if (this.OnResponse)
							this.OnResponse(msg);

						if (this.OnRinging) {
							if ((msg.ServerCode == 180) || (msg.ServerCode == 183)) {
								if (!sess)
									sess = GetSession(msg);
								if (sess)
									this.OnRinging(sess, msg);
							}
						}
						if (msg.ServerCode >= 400) {
							if (!sess)
								sess = GetSession(msg);

							if (sess) {
								if ((!this.Registrations) || (msg.ServerCode != 401) || (!this.Invite401(session, msg))) {
									parent = sess.Parent;
									// sess.Bye();
									this.RemoveSessionByRef(sess, msg.ServerCode);
									if (this.OnEnd)
										this.OnEnd(sess, msg, msg.Headers["reason"] ?? "");
								}
							} else
							if ((this.Registrations) && (msg.ServerCode == 401))
								this.Register401(msg);
						}
					} else {
						if (this.OnNotUnderstood)
							this.OnNotUnderstood(msg);
					}
					if (!sess)
						sess = GetSession(msg);

					if (sess) {
						sess.write_timestamp = 0;
						delete sess.write_server;
					}

					if ((sess) && (sess.OnMessage)) {
						sess.OnMessage(sess, msg, parent);
						if (sess.auth)
							sess.auth = true;
					}

					if (sess)
						var popped_msg = sess.Head();
					if (popped_msg) {
						if (typeof popped_msg == "array") {
							var start = 0;
							var validation_delegate = null;
							if (typeof popped_msg[0] == "delegate") {
								validation_delegate = popped_msg[0];
								start = 1;
							}
							for (var i2 = start; i2 < length popped_msg; i2++) {
								var popped_msg_i = popped_msg[i2];
								if (popped_msg_i) {
									if ((!validation_delegate) || (validation_delegate(msg, popped_msg_i))) {
										sess.Pop();
										WriteMessage(popped_msg_i);
									}
								}
							}
						} else {
							sess.Pop();
							WriteMessage(popped_msg);
						}
					}
					break;
			}
		}
		ops++;
	}
}
