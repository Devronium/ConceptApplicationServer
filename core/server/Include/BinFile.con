include File.con
include BTree.con
include BM25.con

import standard.lang.serialize
import standard.C.casts
import standard.net.socket
import standard.lib.str

define HEADER_SIZE		64
define DEFAULT_MODULO_SIZE	64

define BM25_GRAPH_LEVEL		7
define BM25_QUERY_LEVEL		7
define BM25_MODULO_SIZE		48
define BM25_MAX_WORDCACHE	5000

define MAX_CACHE_OBJECTS	1000

class TinQueryParser {
	var min;
	var min_mode = 0;
	var max;
	var max_mode = 0;
	var additional_filter;
	var reversed = false;
	var owner;
	var btree;
	var db;
	var fetch = -1;

	TinQueryParser(arr) {
		if (IsSet(arr, ">")) {
			min = arr[">"];
			min_mode = 1;
		} else
		if (IsSet(arr, ">=")) {
			min = arr[">="];
			min_mode = 2;
		}
		if (IsSet(arr, "<")) {
			max = arr["<"];
			max_mode = 1;
		} else
		if (IsSet(arr, "<=")) {
			max = arr["<="];
			max_mode = 2;
		}
	}

	CompareSimple(key, val) {
		if (reversed) {
			var t = key;
			key = val;
			val = t;
		}

		var min = this.min;
		var max = this.max;

		if (min_mode == 1) {
			if (key <= min)
				return false;
		}
		if (min_mode == 2) {
			if (key < min)
				return false;
		}
		if (max_mode == 1) {
			if (key >= max)
				return false;
		}
		if (max_mode == 2) {
			if (key > max)
				return false;
		}
		return true;
	}

	Compare(key, val, userdata = null, prec_result = 0) {
		if (reversed) {
			var t = key;
			key = val;
			val = t;
		}

		var min = this.min;
		var max = this.max;

		if (fetch == -1) {
			if ((db) && (owner) && (typeof key == "string") && ((min_mode) || (max_mode)))
				fetch = true;
			else
				fetch = false;
		}
		if (fetch) {
			if (length key == 8) {
				if (((typeof min == "string") && (length min > 8)) || ((typeof max == "string") && (length max > 8))) {
					if (val < 0) {
						if (btree)
							val = btree.GetValue(-val);
					}
					if (val >= 0) {
						var o = owner.ById(val, [db]);
						key = o[db];
					} else
						fetch = false;
				} else
					fetch = false;
			}
		}

		var result = prec_result;
		if (min_mode == 1) {
			if (key <= min)
				result |= QUERY_LESS;
		}
		if (min_mode == 2) {
			if (key < min)
				result |= QUERY_LESS;
		}
		if (max_mode == 1) {
			if (key >= max)
				result |= QUERY_GREAT;
		}
		if (max_mode == 2) {
			if (key > max)
				result |= QUERY_GREAT;
		}

		if (!result)
			result = QUERY_INTERVAL;

		if ((result & QUERY_ELEMENT_VALID) && (additional_filter)) {
			if (val >= 0) {
				if (!additional_filter(key, val, userdata, result, null))
					return QUERY_SKIP;
			}
		}
		return result;
	}
}

class BinIndex {
	protected var f;
	protected var _last_error;
	protected var _name;
	protected var _mode;
	protected var _size;
	protected var _cmp;
	protected var _cmp_reversed;
	protected var UserData;
	protected var[] index_cache;

	public var Unique = false;
	public var Database = "";
	public property LastError { get _last_error }
	public property LastErrorString { get GetLastErrorString }

	BinIndex(name, cmp_func, cmp_reversed, mode = "r+b") {
		this._name = name;
		this._mode = mode;
		this._cmp = cmp_func;
		this._cmp_reversed = cmp_reversed;
	}

	ResetCache() {
		index_cache = new [];
	}

	static FiltreName(origname) {
		if (Pos(origname, "composite.") == 1)
			origname = StrSplit(SubStr(origname, 10), "&");
		return origname;
	}

	GetIndex(idxname) {
		var origname = idxname;
		idxname = this._name + "." + idxname + ".idx";
		var idx = index_cache[idxname];
		if (idx)
			return idx;
		var f = new File(_mode);
		if (!FileExists(idxname))
			WriteFile("", idxname);
		f.Name = idxname;

		if (f.Open()) {
			origname = FiltreName(origname);

			if (Unique)
				idx = new BTreeFile(f, this._cmp, origname, true);
			else
				idx = new BTreeFile(f, this._cmp_reversed, origname, false);
			index_cache[idxname] = idx;
			return idx;
		}
		return null;
	}

	NewTree(idxname) {
		var idx = GetIndex(idxname);
		if (idx)
			return idx.CreateSubtree();
		return -1;
	}

	DropIndex(idxname) {
		_unlink(this._name + "." + idxname + ".idx");
	}

	Put(objid, db = "", cached_val = "dumybear") {
		if (!db)
			db = this.Database;

		var btree = GetIndex(db);
		if (!btree)
			throw "Cannot open index (${@class}.${@member})";
		btree.UserData = FiltreName(db);
		if (Unique)
			return btree.Add(objid, cached_val, Unique);
		return btree.Add(cached_val, objid);
	}

	operator << (values) {
		this.Put(values);
		return this;
	}

	operator[](key) {
		return this.Fetch(key);
	}

	Fetch(key, descending=false, start = -1, len = -1) {
		var btree = GetIndex(this.Database);
		if (!btree)
			throw "Cannot open index (${@class}.${@member})";

		if (typeof key == "string") {
			var val = btree.Get(key, var found);
			if ((!Unique) && (found)) {
				// return all values
				return btree.Query(null, null, descending, len, start, val);
			}
			if (found)
				return val;
			_last_error = 1;
		}
		return null;
	}

	_FetchMultiple(array keys, no_index_query = null, filter_func = null, owner = null, descending = false, start = 0, len = 0) {
		_last_error = 0;
		var databases = GetKeys(keys);

		var[] result;
		for (var i = 0; i < length databases; i++) {
			var db = databases[i];
			var key = keys[db];
			var btree = GetIndex(db);
			if (btree) {
				var no_index_keys;
				if (no_index_query) {
					no_index_keys = GetKeys(no_index_query);
					if (filter_func) {
						for (var k = 0; k < length no_index_keys; k++) {
							var ni_key = no_index_keys[k];
							var ni_q = no_index_query[ni_key];
							if ((typeof ni_q == "array") && (GetKeys(ni_q))) {
								var ni_qp = new TinQueryParser(ni_q);
								ni_qp.reversed = this.Unique;
								ni_qp.btree = btree;
								no_index_query[ni_key] = ni_qp;
							}
						}
					}
					no_index_keys = [no_index_keys, no_index_query];
				} else
					filter_func = null;

				if (typeof key == "array") {
					var key_list = GetKeys(key);
					if ((key_list) && (key_list[0])) {
						if (len <= 0)
							len = -1;
						var qp = new TinQueryParser(key);
						qp.owner = owner;
						qp.db = db;
						qp.btree = btree;
						//var no_index_keys;
						//if (no_index_query) {
						//	no_index_keys = GetKeys(no_index_query);
							if (no_index_keys) {
								qp.reversed = this.Unique;
								qp.additional_filter = filter_func;
							}

						//	no_index_keys = [no_index_keys, no_index_query];
						//}
						result = btree.Query(qp.Compare, no_index_keys, descending, len, start, filter_func);
						return result;
					}
					for (var j = 0; j < length key; j++) {
						var subkey = key[j];
						var res = btree.Get(subkey, var found);
						if (found) {
							if (typeof res == "array") {
								for (var i1 = 0; i1 < length res; i1++)
									result += res[i1];
							} else
								result += res;
						}
					}
				} else {
					res = btree.Get(key, found, start, len, filter_func, no_index_keys);
					if (found) {
						if (typeof res == "array") {
							if (result) {
								for (i1 = 0; i1 < length res; i1++)
									result += res[i1];
							} else
								result = res;
						} else
							result += res;
					}
				}
			}
		}
		return result;
	}


	RemoveKey(key) {
		var btree = GetIndex(this.Database);
		if (!btree)
			throw "Cannot open index (${@class}.${@member})";
		btree.DeleteByKey(key);
	}

	Remove(key, val, database = "") {
		if (!database)
			database = this.Database;
		var btree = GetIndex(database);
		if (!btree)
			throw "Cannot open index (${@class}.${@member})";

		//if (Unique)
			return btree.Delete(key, val);
		//else
		//	return btree.Delete(val, key);
	}

	Drop(database) {
		if (_unlink(database))
			return false;
		return true;
	}

	Count(key="") {
		return 0;
	}


	Close() {
		_last_error = 0;
	}

	GetLastErrorString() {
		if (_last_error)
			return "Key not found";
		return "";
	}

	Flush() {
		for (var i = 0; i < length index_cache; i++) {
			var idx = index_cache[i];	
			if (idx) {
				var f = idx.File;
				if (f) {
					try {
						f.Flush();
						f.DataSync();
					} catch (var exc) {
						echo "Index flush error: $exc\n";
					}
				}
			}
		}
	}
}

class BM25Index {
	var lang = "en";
	var[] fields;
	var file;
	var wordsfile;
	var graphfile;
	var dl;
	var N;

	BM25Index(basename = "", fields = null, lang = "en") {
		this.lang = lang;
		this.fields = fields;
		if (basename) {
			file = new BinFile(basename + ".words", "r+b", BM25_MODULO_SIZE);
			if (!file.Open()) {
				file = null;
				echo "Error opening BM25 index: " + file.name + "\n";
				return;
			}
			wordsfile = new BinFile(basename + ".all", "r+b", BM25_MODULO_SIZE);
			if (!wordsfile.Open()) {
				wordsfile = null;
				file = null;
				echo "Error opening BM25 index: " + wordsfile.name + "\n";
				return;
			}
			graphfile = new BinFile(basename + ".graph", "r+b", BM25_MODULO_SIZE);
			if (!graphfile.Open()) {
				wordsfile = null;
				file = null;
				graphfile = null;
				echo "Error opening BM25 index: " + graphfile.name + "\n";
				return;
			}
			try {
				file.EnsureIndex("w");
				file.EnsureIndex("d");
				file.EnsureIndex(["w", "d"]);
				wordsfile.EnsureIndex("w");
				graphfile.EnsureIndex(["w1", "w2"]);
				graphfile.EnsureIndex(["w1", "w2", "d"]);
				graphfile.EnsureIndex("d");
			} catch (var exc) {
				echo "BM25 index error: $exc\n";
			}
		}
	}

	protected recursive(o) {
		var document = "";
		for (var i = 0; i < length o; i++) {
			var e = o[i];
			if (e) {
				if (document)
					document += ";";
				document += e;
			}
		}
		return document;
	}

	document(o, var graph = null, graph_level = 0) {
		if (typeof o != "array")
			o = ToArray(o);

		var document = "";
		if (fields) {
			for (var i = 0; i < length fields; i++) {
				var f = fields[i];
				if ((f) && (f != '$') && (IsSet(o, f))) {
					var k = o[f];
					if (k) {
						if (typeof k == "array")
							k = recursive(k);
						if (document)
							document += ";";
						document += k;
					}
				}
			}
		} else {
			var keys = GetKeys(o);
			for (i = 0; i < length keys; i++) {
				k = keys[i];	
				if ((k) && (k != '$')) {
					var k2 = o[k];
					if (k2) {
						if (typeof k2 == "array")
							k2 = recursive(k2);
						if (document)
							document += ";";
						document += k2;
					}
				}
			}
		}
		if (!document)
			return null;

		return BM25::document(document, lang, graph, graph_level);
	}

	samefields(fields) {
		if (!this.fields) {
			if (fields)
				return false;
			return true;
		}
		if (!fields)
			return false;

		if (length fields != length this.fields)
			return false;

		for (var i = 0; i < length fields; i++) {
			var k = fields[i];
			if (k) {
				var found = false;
				for (var j = 0; j < length this.fields; j++) {
					var k2 = this.fields[j];
					if ((k2) && (k2 == k)) {
						found = true;
						break;
					}
				}
				if (!found)
					return false;
			}
		}
		return true;
	}

	protected delete_index(findex, id) {
		var objects = findex.Query(["d" => id], ['$', 'd']);
		if (objects) {
			// clean old objects
			for (var i = 0; i < length objects; i++) {
				var o = objects[i];
				if ((o) && (o['d'] == id)) {
					var ref_id = o['$'];
					if (ref_id)
						findex.Delete(ref_id);
				}
			}
		}
	}

	protected docadd(documents, add) {
		if (!add)
			return;
		for (var i = 0; i < length add; i++) {
			var d = add[i];
			if (d) {
				var id = d["d"];
				if (id) {
					var key = "" + id;
					documents[key] = id;
				}
			}
		}
	}

	arrayset(arr, key, word, val) {
		key = "" + key;
		var arr2 = arr[key];
		if (!arr2) {
			arr2 = new [];
			arr[key] = arr2;
		}
		arr2[word] = val;
	}

	statistics(word_query, n, f, lens, start, len, documents = null, add_to_documents = false) {
		// incomplete !!!
		// to sort by relevance !!!
		var wl = file.Query(word_query, null, false, start, len);
		if (wl) {
			var word = word_query["w"];
			if (!word)
				return false;
			if (add_to_documents)
				docadd(documents, wl);
			for (var i = 0; i < length wl; i++) {
				var wdoc = wl[i];
				if (wdoc) {
					var doc_id = wdoc["d"];
					var doc_len = wdoc["l"];
					var doc_word_count = wdoc["a"];
					if (doc_id) {
						var word_statistics_arr = wordsfile.Query(["w" => word], null, false, 0, 1);
						if (word_statistics_arr) {
							var word_statistics = word_statistics_arr[0];
							var n_qi = word_statistics["a"];
							if ((n_qi) && (doc_len) && (doc_word_count)) {
								// all elements encountered
								arrayset(n, doc_id, word, n_qi);
								arrayset(f, doc_id, word, doc_word_count / doc_len);
								lens["" + doc_id] = doc_len;
							}
						}
					}
				}
			}
			return true;
		}
		return false;
	}

	search(string query, start = 0, len = 100) {
		if (file) {
			if (len <= 0)
				len = 100;
			var words = BM25::document(query, lang);
			if (words) {
				var all_words = GetKeys(words);
				var documents = new [];
				var n = new [];
				var f = new [];
				var lens = new [];
				if (length words == 1) {
					if (!statistics(["w" => all_words[0]], n, f, lens, start, len, documents, true))
						return null;
				} else {
					var graph = BM25::complete(all_words, BM25_QUERY_LEVEL);
					for (var i = 0; i < length graph; i++) {
						var g = graph[i];	
						if (g)
							docadd(documents, graphfile.Query(g, ["d"], false, start, len));
					}
					if (length documents < len) {
						for (i = 0; i < length all_words; i++)
							statistics(["w" => all_words[i]], n, f, lens, start, len, documents, true);
					}
				}
				for (i = 0; i < length documents; i++) {	
					var id = documents[i];
					if (id) {
						var key_id = "" + id;
						if (!n[key_id]) {
							for (var j = 0; j < length words; j++) {
								var word = words[j];
								if (word)
									statistics(["w" => word, "d" => id], n, f, lens, start, len);
							}
						}
					}
				}
				var avgdl = 0;
				if (N)
					avgdl = dl/N;
				// some arbitray fall-back value (this should never happen)
				if (!avgdl)
					avgdl = 100;

				var k1 = 1.2;
				var b = 0.75;
				var bm25_array = new [];
				for (i = 0; i < length documents; i++) {
					id = documents[i];
					if (id) {
						key_id = "" + id;
						var sum = 0;
						var d_len = lens[key_id];
						if (d_len) {
							for (j = 0; j < length all_words; j++) {
								var qi = all_words[j];
								var d_n = n[key_id];
								var d_f = f[key_id];
								if ((d_n) && (d_f)) {
									var idf = BM25::idf(N, d_n[qi]);
									var f2 = d_f[qi];
									sum += idf * (f2 * (k1 + 1)) / (f2 + k1 * (1 - b + b * d_len / avgdl));
								}
							}
						}
						bm25_array[key_id] = sum;
					}
				}
				if (bm25_array) {
					var new_documents = new [];
					for (i = 0; i < length bm25_array; i++) {
						var key = "" + (10000000 - floor(bm25_array[i] * 100000));
						new_documents[key] = documents[i];
					}
					documents = KeySorted(new_documents);
				}
				return documents;
			}
		}
		return null;
	}

	increment(dl, inc = 1) {
		if (inc > 0) {
			this.N += inc;
			this.dl += dl;
		}
	}

	dumpcache(var wordcache) {
		if (wordcache) {
			for (var i = 0; i < length wordcache; i++) {
				var w = wordcache[i];
				if (w) {
					try {
						wordsfile.Store(w);
					} catch (var exc) {
						echo "BM25 dumpcache error: $exc\n";
					}
				}
			}
		}
		wordcache = ["." => null];
	}

	update(document, id, changed_keys = null, graph = null, do_flush = true, wordcache = null) {
		if (!document)
			return false;
		if ((changed_keys) && (fields)) {
			var key_exists = false;
			for (var i = 0; i < length changed_keys; i++) {
				var k = changed_keys[i];
				if (k) {
					for (var j = 0; j < length fields; j++) {
						var k2 = fields[j];
						if (k == k2) {
							key_exists = true;
							break;
						}
					}
					if (key_exists)
						break;
				}
			}
			if (!key_exists)
				return false;
		}
		if (id > 0) {
			var word_count = BM25::doclen(document);
			if (word_count) {
				if (file) {
					delete_index(file, id);
					delete_index(graphfile, id);
					var words = GetKeys(document);
					for (i = 0; i < length words; i++) {
						var word = words[i];
						if (word) {
							try {								
								file.Store(["w" => word, "d" => id, "a" => document[word], "l" => word_count]);
								
								var w = null;
								if ((wordcache) && (IsSet(wordcache, word))) {
									w = wordcache[word];
								} else {
									var wl = wordsfile.Query(["w" => word], null, false, 0, 1);

									if (wl)
										w = wl[0];
								}
								if (w)
									w["a"]++;
								else
									w = ["w" => word, "a" => 1];

								if (wordcache)
									wordcache[word] = w;
								else
									wordsfile.Store(w);
							} catch (var exc) {
								echo "BM25 store error: $exc\n";
								return false;
							}
						}
					}
					if (graph) {
						for (i = 0; i < length graph; i++) {
							var g = graph[i];
							if (g) {
								g["d"] = id;
								graphfile.Store(g);
							}
						}
					}
					if (!changed_keys)
						increment(word_count);

					if (do_flush)
						this.flush();
				}
			}
		}
		return true;
	}

	flush() {
		if (file) {
			file.FlushDB();
			wordsfile.FlushDB();
			graphfile.FlushDB();
		}
	}
}

class BinFile extends File {
	protected var deleted_records = 0;
	protected var _Index;
	protected var bm25;
	protected var cache_obj;
	protected var cache_id;
	protected var[] cache;
	protected var has_garbage;

	public var Compress = false;

	public property DeletedRecords { get deleted_records }
	public var[] Indexes;
	public var[] MinIndexFields;
	protected var[] LookForFields;
	protected var MODULO_SIZE = DEFAULT_MODULO_SIZE;
	public var Debug = false;
	public var[] __debug_block_info;


	BinFile(filename, mode="r+b", default_block_size = DEFAULT_MODULO_SIZE) {
		super(mode);
		this.name  = filename;
		_Index = new BinIndex(filename, this.CompareObjects, this.CompareObjectsReversed);
		_Index.Unique = false;
		var data = ReadFile(filename + ".idxn");
		if (default_block_size > 16)
			MODULO_SIZE = default_block_size;
		if (data) {
			Indexes = UnBinarizeObject(data);
			if (!Indexes)
				Indexes  = new [];
			this.SyncIndexes();
		}
		var bm25_name = filename + ".bm25";
		if (FileExists(bm25_name)) {
			data = ReadFile(bm25_name);
			if (data) {
				var fields = UnBinarizeObject(data);
				if (typeof fields == "array") {
					var lang = "en";
					if (fields["lang"])
						lang = fields["lang"];

					bm25 = new BM25Index(bm25_name, fields["fields"], lang);
					bm25.dl = fields["dl"];
					bm25.N = fields["N"];
				}
			}
		}
	}

	SyncIndexes() {
		LookForFields = new [];
		for (var i = 0; i < length Indexes; i++) {
			var index = Indexes[i];
			if (index) {
				var arr;
				if (typeof index != "array")
					arr = [index];
				else
					arr = index[1];

				for (var j = 0; j < length arr; j++)
					LookForFields += StrSplit(arr[j], ".");
			}
		}
		MinIndexFields = this.MinFields();
	}

	DropIndexes() {
		LookForFields = new [];
		for (var i = 0; i < length Indexes; i++) {
			var index = Indexes[i];
			if (index) {
				if (typeof index == "string")
					_Index.DropIndex(index);
			}
		}
		Indexes = new [];
	}

	Check(repair = false, var repaired = false) {
		repaired = false;
		if (fseek(hFile, 0, SEEK_END))
			return false;
		var pos = ftell(hFile);
		var payload_size = pos - HEADER_SIZE;
		var record_size = MODULO_SIZE + 8;
		var rem = payload_size % record_size;
		if (rem) {
			if (repair) {
				var delta = record_size - rem;
				var buf = pack(":$delta");
				if (this.Write(buf) != length buf)
					return false;
				repaired = true;
			} else
				return false;
		}
		return true;
	}

	CompareObjects(a, a_val, b, b_val, btree, bottom_layer) {
		if (a_val > b_val)
			return 1;
		if (a_val < b_val)
			return -1;
		var type = typeof a_val;
		if ((typeof a_val == typeof b_val) && (type != "string"))
			return 0;
		return this.CompareObjectsNoCache(a, b, btree, bottom_layer);
	}

	CompareObjectsReversed(a_val, a, b_val, b, btree, bottom_layer) {
		var b_val_orig = b_val;
		if ((typeof b_val == "string") && (length b_val > 8))
			b_val = SubStr(b_val, 0, 8);

		if (a_val > b_val)
			return 1;

		if (a_val < b_val)
			return -1;

		var type = typeof a_val;
		if ((typeof a_val == typeof b_val) && (type != "string"))
			return 0;

		if (a == b)
			return 0;

		if (a < -1)
			a = btree.GetValue(-a);

		if (b < -1)
			b = btree.GetValue(-b);

		if (a == b)
			return 0;

		if (b == -1)
			return this.CompareSearchObject(a, b_val_orig, btree, bottom_layer);

		return this.CompareObjectsNoCache(a, b, btree, bottom_layer);
	}

	CompareSearchObject(a, key_b, btree, bottom_layer) {
		var obj_a;
		var key = btree.UserData;

		if (a == cache_id) {
			obj_a = cache_obj;
		} else {
			if (length cache > MAX_CACHE_OBJECTS)
				cache = new [];
			obj_a = this.ById(a, LookForFields, !bottom_layer, cache);
		}
		if (obj_a != null) {
			var key_a;
			if (typeof key == "array")
				key_a = this.GetObjectFieldsAsString(obj_a, key);
			else
			if (!this.IsSet2(obj_a, StrSplit(key, "."), key_a))
				throw "Error in compare objects (non existing object) ($a), call stack:\n${_callstack()}";

			//key_a = obj_a[key];

			if (key_a > key_b)
				return 1;
			if (key_a < key_b)
				return -1;
			return 0;
		}
		throw "Error in compare objects (non existing object) ($a), call stack:\n${_callstack()}";
		// error
		return -2;
	}

	CompareObjectsWith(a, b, btree, bottom_layer) {
		var obj_a;
		var obj_b;
		var key = btree.UserData;

		if (length cache > MAX_CACHE_OBJECTS)
			cache = new [];

		if (a == cache_id) {
			obj_a = cache_obj;
			obj_b = this.ById(b, MinIndexFields, !bottom_layer, cache);
		} else
		if (b == cache_id) {
			obj_b = cache_obj;
			obj_a = this.ById(a, MinIndexFields, !bottom_layer, cache);
		} else {
			var res = this.ById([a,b], MinIndexFields, !bottom_layer, cache);
			obj_a = res[0];
			obj_b = res[1];
		}

		if ((obj_a != null) && (obj_b != null)) {
			var key_a;
			var key_b;
			if (typeof key == "array") {
				key_a = this.GetObjectFieldsAsString(obj_a, key);
				key_b = this.GetObjectFieldsAsString(obj_b, key);
			} else {
				key_a = obj_a[key];
				key_b = obj_b[key];
			}
			if (key_a > key_b)
				return 1;
			if (key_a < key_b)
				return -1;
			return 0;
		}
		throw "Error in compare objects (non existing object) ($a/$b), call stack:\n${_callstack()}";
		// error
		return -2;
	}

	CompareObjectsNoCache(a, b, btree, bottom_layer) {
		var obj_a;
		var obj_b;
		var key = btree.UserData;

		if (length cache > MAX_CACHE_OBJECTS)
			cache = new [];

		if (a == cache_id) {
			obj_a = cache_obj;
			obj_b = this.ById(b, MinIndexFields, !bottom_layer, cache);
		} else
		if (b == cache_id) {
			obj_b = cache_obj;
			obj_a = this.ById(a, MinIndexFields, !bottom_layer, cache);
		} else {
			var res = this.ById([a,b], MinIndexFields, !bottom_layer, cache);
			obj_a = res[0];
			obj_b = res[1];
		}

		if ((obj_a != null) && (obj_b != null)) {
			var key_a;
			var key_b;

			if (typeof key == "array") {
				key_a = this.GetObjectFieldsAsString(obj_a, key);
				key_b = this.GetObjectFieldsAsString(obj_b, key);
			} else {
				key_a = obj_a[key];
				key_b = obj_b[key];
			}

			if (key_a > key_b)
				return 1;
			if (key_a < key_b)
				return -1;
			return 0;
		}
		throw "Error in compare objects (non existing object) ($a/$b), call stack:\n${_callstack()}";
		// error
		return -2;
	}

	ReloadIndex() {
		var data = ReadFile(this.name + ".idxn");
		Indexes = UnBinarizeObject(data);
		if (!Indexes)
			Indexes  = new [];
	}

	override Open;
	Open() {
		var file_size = filesize(this.name);
		var valid_file = false;
		if (file_size < HEADER_SIZE) {
			WriteFile("", this.name);
			file_size = 0;
		} else
			valid_file = true;

		if (File::Open()) {
			if (valid_file) {
				//this.Read(var buf, 6);
				fread(var buf, 1, 6, hFile);
				if ((length buf != 6) || (buf != "CDB010")) {
					this.Close();
					throw "Invalid or corrupted data file";
				}
				this.Read(buf, 4);
				fread(buf, 1, 4, hFile);
				if (length buf == 4)
					deleted_records = htonl(tounumber(buf, 32));
				fread(buf, 1, 8, hFile);
				if (length buf != 8)
					throw @class + "." + @member + ": Corrupted header";

				if (unpack("u64", buf)[0])
					has_garbage = true;
				fread(buf, 1, 4, hFile);
				if (length buf != 4)
					throw @class + "." + @member + ": Corrupted header";
				var msize = unpack("u32", buf)[0];
				if (msize > 16)
					MODULO_SIZE = msize;
			} else
				this.WriteHeader();
			return true;
		}
		return false;
	}

	ResetCache() {
		cache = new [];
	}

	protected WriteHeader() {
		var header = pack("su64u64u32:" + HEADER_SIZE, "CDB010", deleted_records, 0, MODULO_SIZE);
		//this.Seek(0);	
		fseek(hFile, 0, SEEK_SET);
		this.Write(header);
	}

	protected WriteInfo() {
		//this.Seek(6);
		fseek(hFile, 6, SEEK_SET);
		if (deleted_records < 0)
			deleted_records = 0;
		this.Write(pack("u64", deleted_records));
	}

	protected PushGarbage(offset) {
		if (fseek(hFile, 14, SEEK_SET))
			return false;
		if (this.Read(var buf, 8) != 8)
			throw @class + "." + @member + ": Corrupted header";

		if (fseek(hFile, offset + MODULO_SIZE, SEEK_SET))
			throw @class + "." + @member + ": Invalid garbage page";

		this.Write(buf);

		if (fseek(hFile, 14, SEEK_SET))
			throw @class + "." + @member + ": Invalid writing header";

		this.Write(pack("u64", offset));
		has_garbage = true;
	}

	protected PopGarbage(var offset) {
		if (fseek(hFile, 14, SEEK_SET))
			return false;
		if (this.Read(var buf, 8) != 8)
			throw @class + "." + @member + ": Corrupted header";

		offset = unpack("u64", buf)[0];
		if (!offset)
			return false;

		if (fseek(hFile, offset + MODULO_SIZE, SEEK_SET))
			return false;

		if (this.Read(buf, 8) != 8)
			return false;

		var next_link = unpack("u64", buf)[0];

		if (next_link == offset)
			next_link = 0;

		fseek(hFile, 14, SEEK_SET);
		this.Write(pack("u64", next_link));

		if (next_link)
			has_garbage = true;
		else
			has_garbage = false;

		//this.Seek(offset + MODULO_SIZE);
		//this.Write(pack("u64", 0));
		this.Seek(offset);
		this.Write(this._EmptyBlock());
		return true;
	}

	public GetGarbageBlocks() {
		var pos = 14;
		var[] res;

		if (fseek(hFile, pos, SEEK_SET))
			return res;

		if (this.Read(var buf, 8) != 8)
			throw @class + "." + @member + ": Corrupted header";

		var offset = unpack("u64", buf)[0];
		if (!offset)
			return res;

		pos = offset + MODULO_SIZE;
		res[length res]  = offset;

		while (pos > 0) {
			buf = "";
			if (fseek(hFile, pos, SEEK_SET))
				return res;

			if (this.Read(buf, 8) != 8)
				throw @class + "." + @member + ": Corrupted header";

			offset = unpack("u64", buf)[0];

			if (!offset)
				return res;

			if (fseek(hFile, offset + MODULO_SIZE, SEEK_SET))
				return res;

			var prec_pos = pos;
			pos = offset + MODULO_SIZE;
			if (prec_pos == pos)
				break;

			res[length res]  = offset;
		}

		return res;
	}

	protected _EmptyBlock() {
		var empty_block = "";

		var block_size = MODULO_SIZE + 8;
		for (var i = 0; i < block_size; i++)
			empty_block += "\x00";

		return empty_block;
	}

	protected _DeleteChain(offset) {
		if (offset <= 0)
			return false;
		var pages = 0;
		var next_block = offset;

		var empty_block = this._EmptyBlock();

		do {
			fseek(hFile, next_block + MODULO_SIZE, SEEK_SET);
			if (this.Read(var ref_block, 8) != 8)
				throw @class + "." + @member + ": Corrupted database or invalid read offset";

			if (fseek(hFile, next_block, SEEK_SET))
				throw @class + "." + @member + ": Corrupted database / seek error";
			pages++;
			// this.Write("\x00");
			this.Write(empty_block);

			this.PushGarbage(next_block);
			var prec_next_block = next_block;
			next_block = unpack("u64", ref_block)[0];
			if (prec_next_block == next_block)
				break;
			this.deleted_records++;
		} while (next_block);
		this.WriteInfo();
		return pages;
	}

	protected WriteBlock(var data, var id) {
		var pos = 0;
		var file_pos = 0;
		var ref_id = -1;
		var next_block = 0;
		var popped = false;

		if (id >= HEADER_SIZE) {
			//if (!this.Seek(id))
			if (fseek(hFile, id, SEEK_SET))
				throw @class + "." + @member + ": Seek error";
		} else
			id = -1;
		var end_block = "\x0\x0\x0\x0\x0\x0\x0\x0";
		var query_garbage = true;
		var at_end = false;
		if ((id < 0) && (!has_garbage)) {
			if (length data > MODULO_SIZE) {
				for (var i = MODULO_SIZE; i < length data; i += MODULO_SIZE)
					data[i] = "\x00" + data[i];
			}
			var rem = length data % MODULO_SIZE;
			if (rem) {
				var padding = MODULO_SIZE - rem;
				data += pack(":"+padding);
			}
			i = 0;

			fseek(hFile, 0, SEEK_END);
			ref_id = ftell(hFile);
			while (i < length data) {
				i += MODULO_SIZE;
				if (i < length data) {
					data[i] = pack("u64", ref_id + i + 8) + data[i];
				} else {
					data += end_block;
					break;
				}
				i += 8;
			}
			Write(data);
		} else
		do {
			if (pos) {
				var buf = "\x00" + SubStr(data, pos, MODULO_SIZE - 1);
				if (length buf == 1)
					break;
				
				pos += length buf - 1;
			} else {
				buf = SubStr(data, pos, MODULO_SIZE);
				pos += length buf;
			}
			if (!buf)
				break;

			if (id < 0) {
				if ((query_garbage) && (this.PopGarbage(var offset))) {
					//this.Seek(offset);
					fseek(hFile, offset, SEEK_SET);
					popped = true;
				} else {
					//this.Seek(0, SEEK_END);
					fseek(hFile, 0, SEEK_END);
					query_garbage = false;
					at_end = true;
				}
				if (ref_id < 0)
					ref_id = ftell(hFile);
			}

			if (length buf < MODULO_SIZE)
				buf = pack("s:" + MODULO_SIZE, buf);

			if (next_block) {
				//if (!this.Seek(next_block))
				if (fseek(hFile, next_block, SEEK_SET))
					throw @class + "." + @member + ": Seek error";
			} else
			if (file_pos) {
				var next_pos = ftell(hFile);
				//this.Seek(file_pos - 8);
				fseek(hFile, file_pos - 8, SEEK_SET);
				this.Write(pack("u64", next_pos));
				//this.Seek(next_pos);
				fseek(hFile, next_pos, SEEK_SET);
			}

			if (id < 0) {
				if ((at_end) && (pos < length data)) {
					file_pos = ftell(hFile);
					var full_buf = buf;
					while (pos < length data) {
						file_pos += MODULO_SIZE + 8;
						full_buf += pack("u64", file_pos);
						if (pos)
							buf = "\x00" + SubStr(data, pos, MODULO_SIZE - 1);
						else
							buf = SubStr(data, pos, MODULO_SIZE);
						if (length buf < MODULO_SIZE)
							full_buf += pack("s:" + MODULO_SIZE, buf);
						else
							full_buf += buf;
						pos += length buf;
					}
					full_buf += end_block;
					// write all at once
					this.Write(full_buf);
					break;
				} else
					this.Write(buf + end_block);
			} else {
				this.Write(buf);

				var current = ftell(hFile);
				//this.Seek(0, SEEK_CUR);
				fseek(hFile, 0, SEEK_CUR);

				//if (this.Read(var buf2, 8) != 8)
				var read_size = fread(var buf2, 1, 8, hFile);
				if (read_size != 8) {
					// end of file ?
					if (read_size != 0)
						throw @class + "." + @member + ": Corrupted database / page link error in update";
					next_block = 0;
					this.Write(end_block);
				} else {
					next_block = unpack("u64", buf2)[0];
				}
				if (pos >= length data) {
					if (next_block)
						this._DeleteChain(next_block);
					//this.Seek(-8, SEEK_CUR);
					//fseek(hFile, -8, SEEK_CUR);
					fseek(hFile, current, SEEK_SET);
					this.Write(pack("u64", 0));
				} else
				if (!next_block) {
					if ((!query_garbage) || (!this.PopGarbage(next_block))) {
						//this.Seek(0, SEEK_END);
						fseek(hFile, 0, SEEK_END);
						next_block = ftell(hFile);
						query_garbage = false;
					} else
						popped = true;

					fseek(hFile, current, SEEK_SET);
					this.Write(pack("u64", next_block));
					fseek(hFile, 0, SEEK_CUR);
				}
			}
			file_pos = ftell(hFile);
		} while (true);
		if (id < 0)
			id = ref_id;
		return true;
	}

	protected _Store(var obj, update_index = true, id = -1, changed_keys = null, do_flush = true) {
		if (!hFile)
			throw "Invalid file descriptor or no open file";
		var data;
		var c;
		if (typeof obj == "array") {
			if (IsSet(obj, '$')) {
				var keys = GetKeys(obj);
				c = new [];
				for (var i = 0; i < length keys; i++) {
					var k = keys[i];
					if ((k) && (k != '$'))
						c[k] = obj[k];
				}
				if (id < 0)
					id = obj['$'];
			} else
				c = obj;
		} else
			c = ToArray(obj);

		var bm25_document = null;
		var graph = null;
		if ((bm25) && (c) && (update_index))
			bm25_document = bm25.document(c, graph, BM25_GRAPH_LEVEL);
			
		data = BinarizeObject(c);
		if (data) {
			var data_comp = "";
			if (Compress) {
				if (length data > MODULO_SIZE) {
					data_comp = "\x06" + compress(data);
					if (int32(length data_comp / MODULO_SIZE) >= int32(length data / MODULO_SIZE))
						data_comp = "";
				}
			}
			var orig_id = id;
			if (data_comp)
				var res = this.WriteBlock(data_comp, id);
			else
				res = this.WriteBlock(data, id);

			if ((orig_id > 0) && (cache)) {
				if (IsSet(cache, "" + orig_id))
					cache = new [];
			}
			if (res > 0) {
				if (do_flush)
					this.Flush();
				if (update_index) {
					if (changed_keys == null) {
						this.UpdateIndex(obj, id);
					} else
						this.UpdateIndex(changed_keys, id, obj);
				}
				if (bm25_document) {
					bm25.update(bm25_document, id, changed_keys, graph);
					this.SyncBM25Info();
				}
			}
			return id;
		}
		return id;
	}

	UpdateIndex(obj, id, extra_obj = null) {

		var c;
		if (typeof obj == "array")
			c = obj;
		else
			c = ToArray(obj);
		var index_data = this.Indexes;

		if (index_data) {
			cache_id = id;
			cache_obj = c;
			for (var i = 0; i < length index_data; i++) {
				var key = index_data[i];
				if (key) {
					if (typeof key == "array") {
						// to do
						var string_val = this.GetObjectFieldsAsString(c, key[1], var field_count, extra_obj);
						if ((field_count) && (!_Index.Put(id, key[0], string_val))) {
							// to do
							// this._Delete(id, false, false);
						}
					} else
					if (IsSet(c, key)) {
						if (!_Index.Put(id, key, c[key])) {
							// to do
							// this._Delete(id, false, false);
						}
					} else
					if (this.IsSet2(c, StrSplit(key, "."), var v)) {
						if (!_Index.Put(id, key, v)) {
							// to do
							// this._Delete(id, false, false);
						}
					}
				}
			}
			cache_id = -1;
			cache_obj = null;
		}
	}

	Store(var obj, update_index = true, do_flush = true) {
		return this._Store(obj, update_index, do_flush);
	}

	IsUnique(obj, fields) {
		if ((!fields) || (!obj))
			return true;
		if (typeof fields == "string")
			fields = [ fields ];
		if (typeof fields != "array")
			return true;

		var obj_id = obj['$'];
		var fetch_count = 1;
		if (obj_id > 0)
			fetch_count = 2;
		var db_obj = null;
		var sum_of_fields = [ ];

		for (var i = 0; i < length fields; i++) {
			var field = fields[i];
			switch (typeof field) {
				case "string":
					if (field)
						sum_of_fields[field] = field;
					break;
				case "array":
					for (var j = 0; j < length field; j++) {
						var f2 = field[j];
						if (f2) 
							sum_of_fields[f2] = f2;
					}
					break;
			}
		}

		for (i = 0; i < length fields; i++) {
			field = fields[i];
			switch (typeof field) {
				case "string":
					if (IsSet(obj, field)) {
						var objects = this.Query([field => obj[field]], ['$'], false, 0, fetch_count);
						if (objects) {
							for (j = 0; j < length objects; j++) {
								var o = objects[j];
								if ((o) && (o['$'] != obj_id))
									return false;
							}
						}
					}
					break;
				case "array":
					var query = [ ];
					if ((obj_id > 0) && (!db_obj)) {
						db_obj = this.ById(obj_id, sum_of_fields);
						// invalid id
						if (!db_obj)
							return false;
					}
					for (j = 0; j < length field; j++) {
						f2 = field[j];
						if (f2) {
							if (IsSet(obj, f2))
								query[f2] = obj[f2];
							else
							if ((db_obj) && (IsSet(db_obj, f2)))
								query[f2] = db_obj[f2];
						}
					}
					if (query) {
						objects = this.Query(query, ['$'], false, 0, fetch_count);
						if (objects) {
							for (j = 0; j < length objects; j++) {
								o = objects[j];
								if ((o) && (o['$'] != obj_id))
									return false;
							}
						}
					}
					break;
			}
		}
		return true;		
	}

	protected __Debug(id) {
		var key = "" + ftell(hFile);
		if (typeof __debug_block_info[key] == "array") {
			__debug_block_info[key] += id;
		} else
		if (__debug_block_info[key]) {
			__debug_block_info[key] = [__debug_block_info[key], id];
		} else
			__debug_block_info[key] = id;
	}

	protected GetOne(var id = null, strict = true, offset = -1) {
		if (offset < 0)
			id = ftell(hFile);
		else
			id = offset;
		var buf = "";
		var next_block;
		var prev_block;
		var compressed = false;
		var first_jump = 0;
		var blocks = 0;
		do {
			prev_block = next_block;
			if ((next_block > 0) && (next_block != ftell(hFile))) {
				//if (!this.Seek(next_block))
				if (!first_jump)
					first_jump = ftell(hFile);
				if (fseek(hFile, next_block, SEEK_SET)) {
					throw @class + "." + @member + ": Corrupted database / seek error";
				}
			}

			var size = fread(var buf_block, 1, MODULO_SIZE, hFile);
			//var size = this.Read(var buf_block, MODULO_SIZE);
			if (size != MODULO_SIZE) {
				if (buf)
					throw @class + "." + @member + ": Corrupted database or invalid read offset (page read)";
				return "";
			}
			blocks++;

			var flag = buf_block[0];
			if (!buf) {
				if (flag == "\x06")
					compressed = true;
				else
				if (flag != "\x05") {
					if (strict)
						return "";
					// deleted block
					next_block = -1;
					fseek(hFile, 8, SEEK_CUR);
					id = ftell(hFile);
					continue;
				}
			} else
			if (flag != "\x00") {
				throw @class + "." + @member + ": Invalid buffer for id $id ($next_block)";
				break;
			}
			if (Debug)
				this.__Debug(id);

			if (buf)
				buf += SubStr(buf_block, 1);
			else
				buf += buf_block;
			//if (this.Read(var ref_block, 8) != 8)
			if (fread(var ref_block, 1, 8, hFile) != 8)
				throw @class + "." + @member + ": Corrupted database or invalid read offset";
			next_block = unpack("u64", ref_block)[0];

			if ((next_block) && (this.InvalidId(next_block)))
				throw @class + "." + @member + ": Invalid offset for id $id ($next_block)";
			if ((next_block) && (next_block == prev_block))
				throw @class + "." + @member + ": Circular offset for id $id ($next_block) after $blocks read";
		} while (next_block);
		if (first_jump)
			fseek(hFile, first_jump, SEEK_SET);
		if ((compressed) && (buf))
			return uncompress(SubStr(buf, 1));
		return buf;
	}

	FetchByIndex(addr, start = 0, len = -1) {
		var[] result;
		for (var i = 0; i < length addr; i++) {
			var offset = addr[i] + HEADER_SIZE;
			//this.Seek(offset);
			fseek(hFile, offset, SEEK_SET);
			var obj = this.GetOne(var id, true, offset);
			if (obj) {
				var o = UnBinarizeObject(obj);
				if (o) {
					o['$'] = id;
					result[length result] = o;
				}
			}
		}
		return result;
	}

	InvalidId(id) {
		if (id < HEADER_SIZE)
			return true;
		id -= HEADER_SIZE;
		if (id % (MODULO_SIZE + 8))
			return true;
		return false;
	}

	InvalidOffset(rftell) {
		if (rftell <= 0)
			return false;

		if ((rftell - HEADER_SIZE - MODULO_SIZE) % (MODULO_SIZE + 8))
			return true;

		return false;
	}


	ById(id, fields = null, do_cache = false, cache = null) {
		if (typeof id == "array") {
			var res_array = new [];
			for (var i = 0; i < length id; i++) {
				var _id = id[i];
				if ((_id) && (!InvalidId(_id))) {
					if (do_cache) {
						var cache_key = "" + _id;
						var cached_obj = cache[cache_key];
						if (cached_obj) {
							res_array[cache_key] = cached_obj;
							continue;
						}
					}

					if (fseek(hFile, _id, SEEK_SET))
						continue;
					var res = GetOne(null, true, _id);
					if (res) {
						if (fields)
							var o = UnBinarizeObject(res, 0, fields);
						else
							o = UnBinarizeObject(res);
						if (o != null) {
							o['$'] = _id;
							res_array["" + _id]  = o;
							if (do_cache)
								cache[cache_key] = o;
						}
					}
				}
			}
			return res_array;
		} else {
			if (InvalidId(id))
				return null;

			if (do_cache) {
				cache_key = "" + id;
				cached_obj = cache[cache_key];
				if (cached_obj)
					return cached_obj;
			}

			//if (!this.Seek(id))
			if (fseek(hFile, id, SEEK_SET))
				return null;
			res = GetOne(null, true, id);
			if (res) {
				if (fields)
					o = UnBinarizeObject(res, 0, fields);
				else
					o = UnBinarizeObject(res);
				if (o) {
					o['$'] = id;

					if (do_cache)
						cache[cache_key] = o;
				}
				return o;
			}
			return null;
		}
	}

	RemoveIndexes(o, id) {
		if (o) {
			var indexes = Indexes;
			var Unique = _Index.Unique;
			for (var i = 0; i < length indexes; i++) {
				var index = indexes[i];
				if (index) { 
					if (typeof index == "array") {
						var string_val = this.GetObjectFieldsAsString(o, index[1], var field_count);
						if (field_count) {
							if (Unique)
								_Index.Remove(string_val, id, index[0]);
							else
								_Index.Remove(id, string_val, index[0]);
						}
					} else
					if (IsSet(o, index)) {
						var v = o[index];
						if (Unique)
							_Index.Remove(v, id, index);
						else
							_Index.Remove(id, v, index);
					}
				}
			}
		}
	}

	RemoveIndexesIfChanged(o, id, old = null) {
		var changed = 0;
		if (o) {
			var indexes = Indexes;
			var Unique = _Index.Unique;
			for (var i = 0; i < length indexes; i++) {
				var index = indexes[i];
				if (index) {
					if (typeof index == "array") {
						var string_val = this.GetObjectFieldsAsString(o, index[1], var field_count, old);
						if (field_count) {
							if (Unique)
								_Index.Remove(string_val, id, index[0]);
							else
								_Index.Remove(id, string_val, index[0]);
							changed++;
						}
					} else
					if (IsSet(o, index)) {
						var v = o[index];
						if (Unique)
							_Index.Remove(v, id, index);
						else
							_Index.Remove(id, v, index);
						changed++;
					}
				}
			}
		}
		return changed;
	}

	RemoveIndexesByObjects(arr) {
		for (var i = 0; i < length arr; i++) {
			var obj = arr[i];
			if ((obj) && (IsSet(obj, '$')))
				this.RemoveIndexes(obj, obj['$']);
		}
	}

	protected MinFields() {
		var[] fields;
		for (var i = 0; i < length Indexes; i++) {
			var index = Indexes[i];
			if (index) {
				switch (typeof index) {
					case "string":
						fields[index] = index;
						break;
					case "array":
						index = index[1];
						if (typeof index == "array") {
							for (var j = 0; j < length index; j++) {
								var index_2 = index[j];	
								if ((index_2) && (typeof index_2 == "string"))
									fields[index_2] = index_2;
							}
						}
						break;
				}
			}
		}
		return fields;
	}

	protected _Delete(id, strict = false, update_index = true) {
		//if (!this.Seek(id))
		if (InvalidId(id))
			return false;

		if (id <= 0)
			return false;

		if (fseek(hFile, id, SEEK_SET))
			return false;


		var obj = GetOne(null, true, id);
		if (!obj)
			return false;

		try {
			if ((Indexes) && (update_index))
				this.RemoveIndexes(UnBinarizeObject(obj, 0, MinIndexFields), id);
		} catch (var exc) {
			echo "Exception: $exc\n";
			return false;
		}

		this._DeleteChain(id);
		if (cache) {
			if (IsSet(cache, "" + id))
				cache = new [];
		}
		return true;
	}

	Delete(id, update_index = true) {
		var strict = false;
		if (typeof id == "array") {
			if (IsSet(id, '$')) {
				return this._Delete(id['$'], strict, update_index);
			} else {
				var cnt = 0;
				for (var i = 0; i < length id; i++) {
					var _id = id[i];
					if (_id) {

						if ((typeof _id == "array") && (IsSet(_id, '$'))) {
							cnt += this._Delete(_id['$'], strict, update_index);
						} else
							cnt += this._Delete(_id, strict, update_index);
					}
				}
				return cnt;
			}
		} else
			return this._Delete(id, strict, update_index);
	}

	protected SetKey(o, key_path, var v, var first_key, var prec_value, add_key = false) {
		var key_arr = StrSplit(key_path, ".");
		var last = length key_arr - 1;
		first_key = "";

		for (var i = 0; i < length key_arr; i++) {
			var key = key_arr[i];
			if (key) {
				if (i != last) {
					if (!IsSet(o, key))
						o[key] = new [];

					o = o[key];
					var type = typeof o;
					if ((type != "array") && (type != "class"))
						return false;
				} else {
					if ((!IsSet(o, key)) || (typeof o[key] != typeof v) || (o[key] != v) || (add_key)) {
						first_key = key_arr[0];
						prec_value = o[key];
						if (add_key) {
							if (typeof prec_value != "array")
								o[key] = [prec_value];

							o[key][length o[key]] = v;
						} else
							o[key] = v;
						return true;
					}
					return false;
				}
			} else
				return false;
		}
		return false;
	}

	Update(o, var id, update_index = true, var old_bin = null, var new_bin = null) {
		//old_bin = null;
		new_bin = null;
		//if (!this.Seek(id))
		if (fseek(hFile, id, SEEK_SET))
			return false;
		var keys = GetKeys(o);	
		if (keys) {
			var res = GetOne(null, true, id);
			if (res) {
				var old = UnBinarizeObject(res);
				if (old) {
					var[] changed;
					var[] new_values;
					for (var i = 0; i < length keys; i++) {
						var k = keys[i];
						if ((k) && (k != '$')) {
							// add to array
							var val = o[k];
							if (k[0] == "+") {
								k++;
								/*var has_key = IsSet(old, k);
								if (!has_key) {
									old[k] = [o["+" + k]];
								} else {
									if (typeof old[k] != "array")
										old[k] = [old[k]];

									old[k][length old[k]] = o["+" + k];
								}
								new_values[k] = old[k];
								// changed[k] = [ ];*/
								if (SetKey(old, k, val, var first_key, var prec_value, true)) {
									changed[k] = prec_value;
									new_values[k] = val;
								}
							} else {
								/*has_key = IsSet(old, k);
								if ((!has_key) || (old[k] != o[k])) {
									changed[k] = old[k];
									old[k]  = o[k];
									new_values[k] = o[k];
								}*/
								if (SetKey(old, k, val, first_key, prec_value)) {
									changed[k] = prec_value;
									new_values[/*first_key*/k] = val;
								}
							}
						}
					}

					if (update_index)
						update_index = this.RemoveIndexesIfChanged(changed, id, old);

					//if (!this.Seek(id))
					if (fseek(hFile, id, SEEK_SET))
						return false;
					this._Store(old, update_index, id, new_values);
					if (!update_index)
						new_bin  = old;
					return true;
				}
			}
		}
		return false;
	}

	Scan(callback, userdata = null) {
		//this.Seek(HEADER_SIZE);
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		while (var obj = this.GetOne(var id, false)) {
			var o = UnBinarizeObject(obj);
			if (o) {
				o['$'] = id;
				if (callback(o, id, userdata))
					break;
			}
		}
	}

	RebuildIndex(string field) {
		var prec_db = _Index.Database;
		_Index.Database = field;
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		Indexes[field] = field;
		this.Scan(function(c, id, field) {
			cache_id = id;
			cache_obj = c;
			var pos = ftell(hFile);
			if (this.IsSet2(c, StrSplit(field, "."), var v))
			//if (IsSet(c, field))
				_Index.Put(id, field, /*c[field]*/v);

			fseek(hFile, pos, SEEK_SET);
		}, field);
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		_Index.Database = prec_db;
		cache = new [];
		cache_id = -1;
		cache_obj = null;
	}

	RebuildBM25() {
		if (!bm25)
			return;
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		var word_cache = ["." => 0];
		this.Scan(function(c, id, var word_cache) {
			cache_id = id;
			cache_obj = c;
			bm25.update(bm25.document(c, var graph, BM25_GRAPH_LEVEL), id, null, graph, false, word_cache);
			if (length word_cache >= BM25_MAX_WORDCACHE)
				bm25.dumpcache(word_cache);
		}, word_cache);
		bm25.dumpcache(word_cache);
		bm25.flush();
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		cache = new [];
		cache_id = -1;
		cache_obj = null;
	}

	GetObjectFields(obj, fields) {
		var[] indexed_object;

		for (var i = 0; i < length fields; i++) {
			var field = fields[i];
			if ((field) && (this.IsSet2(obj, StrSplit(field, "."), var v)))
				indexed_object[field] = v;//obj[field];
		}
		return indexed_object;
	}

	GetObjectFieldsAsString(obj, fields, var field_count = null, extra_obj = null) {
		var indexed_object = "";
		field_count = 0;

		for (var i = 0; i < length fields; i++) {
			var field = fields[i];
			if (field) {
				if (IsSet(obj, field)) {
					field_count++;
					indexed_object += obj[field];
				} else
				if (this.IsSet2(obj, StrSplit(field, "."), var v)) {
					field_count++;
					indexed_object += v;
				} else
				if (extra_obj) {
					if (IsSet(extra_obj, field)) {
						field_count++;
						indexed_object += extra_obj[field];
					} else
					if (this.IsSet2(extra_obj, StrSplit(field, "."), v)) {
						field_count++;
						indexed_object += v;
					}
				}
				indexed_object += "|";
			}
		}
		return indexed_object;
	}

	RebuildCompositeIndex(array fields) {
		var index_name = this.IndexName(fields);
		if (!index_name)
			return;
		var prec_db = _Index.Database;
		_Index.Database = index_name;
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		Indexes[index_name] = fields;
		this.Scan(function(c, id, userdata) {
			cache_id = id;
			cache_obj = c;
			var fields = userdata[0];
			var index_name = userdata[1];
			var pos = ftell(hFile);
			for (var i = 0; i < length fields; i++) {
				var field = fields[i];
				if ((field) && (this.IsSet2(c, StrSplit(field, "."), null))) {
					_Index.Put(id, index_name, GetObjectFieldsAsString(c, fields));
					break;
				}
			}
			fseek(hFile, pos, SEEK_SET);
		}, [fields, index_name]);
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		_Index.Database = prec_db;
		cache = new [];
		cache_id = -1;
		cache_obj = null;
	}

	EnsureIndex(field) {
		if (typeof field == "array")
			return this.EnsureCompositeIndex(field);
		else
		if (typeof field != "string")
			return false;

		for (var i = 0; i < length Indexes; i++) {
			var index = Indexes[i];
			if ((typeof index == "string") && (field == index))
				return true;
		}
		this.RebuildIndex(field);
		this.FlushDB();
		Indexes[field] = field;
		WriteFile(BinarizeObject(Indexes), name + ".idxn");
		this.SyncIndexes();
		cache = new [];
		cache_id = -1;
		cache_obj = null;
	}

	EnsureFullTextIndex(fields, lang = "en") {
		if (bm25) {
			if (bm25.samefields(fields))
				return false;
		}
		if (!fields)
			fields = new [];
		var bm25_name = this.name + ".bm25";
		bm25 = new BM25Index(bm25_name, fields, lang);
		this.RebuildBM25();
		this.SyncBM25Info();
		this.FlushDB();
		cache = new [];
		cache_id = -1;
		cache_obj = null;
	}

	SyncBM25Info() {
		if (bm25) {
			var bm25_name = this.name + ".bm25";
			WriteFile(BinarizeObject(["fields" => bm25.fields, "lang" => bm25.lang, "dl" => bm25.dl, "N" => bm25.N]), bm25_name);
		}
	}

	IndexName(fields) {
		if (typeof fields == "array") {
			var index_name = "";
			var[] fields2;
			for (var i = 0; i < length fields; i++) {
				var field = fields[i];
				if (field)
					fields2[field] = field;
			}
			fields = KeySorted(fields2);
			for (i = 0; i < length fields; i++) {
				field = fields[i];
				if (field) {
					if (index_name)
						index_name += "&";
					index_name += field;
				}
			}
			if (index_name)
				index_name = "composite." + index_name;
			return index_name;
		}
		return fields;
	}
	
	EnsureCompositeIndex(array fields) {
		if (!fields)
			return false;

		var index_name = this.IndexName(fields);
		if (!index_name)
			return false;

		for (var i = 0; i < length Indexes; i++) {
			var index =  Indexes[i];
			if ((index) && (typeof index == "array") && (index_name == index[0]))
				return true;
		}
		this.RebuildCompositeIndex(fields);
		this.FlushDB();
		Indexes[index_name] = [index_name, fields];
		WriteFile(BinarizeObject(Indexes), name + ".idxn");
		this.SyncIndexes();
	}

	EnsureIndexes(array fields) {
		for (var i = 0; i < length fields; i++) {
			var field = fields[i];
			if (field)
				EnsureIndex(field);
		}
	}

	static GetMin(var arr) {
		var[] res;
		var min = -1;
		var min_pos = -1;
		var keys = GetKeys(arr);
		for (var i = 0; i < length arr; i++) {
			var v = arr[i];	
			if ((v < min) || (min == -1)) {
				min = v;
				min_pos = i;
			}
		}
		if (min_pos >= 0) {
			for (i = 0; i < length arr; i++) {
				if (i != min_pos)
					res[keys[i]] = arr[i];
			}
			arr = res;
			return [keys[min_pos] => min];
		}
		return null;
	}

	protected IsSet2(o, key_arr, var v) {
		var last = length key_arr - 1;
		for (var i = 0; i < length key_arr; i++) {
			var key = key_arr[i];
			if ((key) && (IsSet(o, key))) {
				o = o[key];
				if (i != last) {
					var type = typeof o;
					if ((type != "array") && (type != "class"))
						return false;
				} else
					v = o;
			} else
				return false;
		}
		return true;
	}

	protected ScanFilter(obj_key, obj_val, keys_data, prec_result, cached_o = null) {
		var keys = keys_data[0];
		var vals = keys_data[1];
		var cache = keys_data[7];
		if (!cache) {
			cache = new [];
			keys_data[7] = cache;
		}
		var o = cached_o;

		if (o == null)
			o = this.ById(obj_val, keys, false, null);

		if (o) {
			var add_item = true;
			for (var j = 0; j < length keys; j++) {
				var key = keys[j];
				var key_arr = cache[j];
				if (!key_arr) {
					key_arr = StrSplit(key, ".");
					cache[j] = key_arr;
				}
				if ((key) && (IsSet2(o, key_arr, var v))) {
				//if ((key) && (IsSet(o, key))) {
					add_item = false;
					var arr = vals[key];
					var typeof_arr = typeof arr;
					//var v = o[key];
					if (typeof_arr == "array") {
						for (var i = 0; i < length arr; i++) {
							if (arr[i] == v) {
								add_item = true;
								break;
							}
						}
						if (!add_item)
							return false;
					} else
					if (typeof_arr == "class") {
						if (arr.CompareSimple(v, key)) {
							add_item = true;
						} else
							return false;
					} else
					if (v != vals[key])
						return false;
					else
						add_item = true;
				} else
					return false;
			}
			return add_item;
		}
		return false;
	}

	protected CompositeIndexQuery(array keys, array q) {
		if ((!keys) || (!q))
			return false;
		for (var i = 0; i < length keys; i++) {
			var index_key = keys[i];
			if (!IsSet(q, index_key))
				return false;
			// do not use index for OR values
			if (typeof q[index_key] == "array")
				return false;
		}
		return true;
	}

	protected CompositeFilterKeys(array index_keys, array keys) {
		var[] new_keys;
		var[] ignore;
		for (var i = 0; i < length index_keys; i++) {
			var key = index_keys[i];
			if (key)
				ignore[key] = true;
		}
		for (i = 0; i < length keys; i++) {
			key = keys[i];
			if ((key) && (!ignore[key]))
				new_keys[length new_keys] = key;
		}
		return new_keys;
	}

	Count(q = null) {
		return this.Query(['#' => q])[0];
	}

	Search(string q, fields = null, start = 0, len = 0) {
		var bm = this.bm25;
		if (!bm)
			bm = new BM25Index();

		var qdoc = BM25::query(q, bm.lang);
		if (!qdoc)
			return [ ];
		if (this.bm25) {
			var ids = this.bm25.search(q, start, len);
			if (ids)
				return this.ById(ids, fields);
		} else {
			var documents = new [];
			this.Scan(function(o, id, userdata) {
				var ids = userdata[0];
				var bm = userdata[1];
				var q = userdata[2];

				var doc = bm.document(o);
				if ((doc) && (BM25::contains(doc, q))) {
					doc['$'] = id;
					ids[length ids] = doc;
				}
			}, [documents, bm, qdoc]);
			var[] weights;
			var documents_qi = BM25::count(qdoc, documents, var avgdl);
			for (var i = 0; i < length documents; i++) {
				var doc = documents[i];
				if (doc) {
					var score = BM25::score(qdoc, documents_qi, documents[i], length documents, avgdl);
					if (score > 0) {
						var id = doc['$'];
						var key = "" + (1000000 - floor(score * 1000));
						var prec = weights[key];
						if (prec)
							key = key + "." + i;
						weights[key] = id;
					}
				}
			}
			ids = KeySorted(weights);
			if ((len) || (start)) {
				if (len <= 0)
					len = length ids;

				if (len - start > length ids)
					len = length ids - start;

				var new_ids = new [];
				for (i = start; i < len; i++) {
					id = ids[i];
					if (id)
						new_ids[length new_ids] = id;
				}
				ids = new_ids;
			}
			return this.ById(ids, fields);
		}
		return [ ];
	}

	Query(q = null, fields = null, descending = false, start = 0, len = 0) {
		var count;
		if ((q) && (IsSet(q, '#'))) {
			q = q['#'];
			count = true;
		}
		if (q == null)
			q = new [];
		var indexes = Indexes;
		var keys = GetKeys(q);
		var index_to_use = new [];
		var index_counts = new [];
		var indexed_query = [ ];
		var result2;
		for (var i = 0; i < length indexes; i++) {
			var index = indexes[i];
			if (index) {
				if (typeof index == "array") {
					if (CompositeIndexQuery(index[1], q)) {
						var index_name = index[0];
						if (index_name) {
							_Index.Database = index_name;
							index_to_use[index_name] = index_name;
							index_counts[index_name] = length indexes - i;
							indexed_query[index_name] = this.GetObjectFieldsAsString(q, index[1]);
							keys = CompositeFilterKeys(index[1], keys);
						}
					}
				} else
				if (IsSet(q, index)) {
					_Index.Database = index;
					index_to_use[index] = index;
					index_counts[index] = length indexes - i;
				}
			}
		}
		var result = new [];
		var filter_ids;
		var filter_by_id = false;

		if (IsSet(q/*keys*/, '$')) {
			filter_by_id = true;
			var ref_filter_ids = q['$'];//keys['$'];
			if (typeof ref_filter_ids != "array")
				ref_filter_ids = [ref_filter_ids];

			filter_ids = new [];
			for (i = 0; i < length ref_filter_ids; i++) {
				var fi = ref_filter_ids[i];
				if (fi)
					filter_ids["" + fi] = fi;
			}
			if (length keys == 1)
				return this.ById(filter_ids);
		}

		if (index_to_use) {
			var non_indexed_query = [ ];
			for (i = 0; i < length keys; i++) {
				var key = keys[i];
				if ((indexed_query) || (!IsSet(index_to_use, key)))
					non_indexed_query[key] = q[key];
				else
					indexed_query[key] = q[key];
			}
			var ids = _Index._FetchMultiple(indexed_query, non_indexed_query, this.ScanFilter, this, descending, start, len);
			if (ids) {
				if (count)
					return [length ids];
				result = this.ById(ids, fields);
			}
		} else {
			if (q) {
				var Unique = false;
				if (this._Index)
					Unique = this._Index.Unique;
				for (var k = 0; k < length keys; k++) {
					var ni_key = keys[k];
					var ni_q = q[ni_key];
					if (typeof ni_q == "array") {
						var key_list = GetKeys(ni_q);
						if ((key_list) && (key_list[0])) {
							var ni_qp = new TinQueryParser(ni_q);
							ni_qp.reversed = Unique;
							q[ni_key] = ni_qp;
						}
					}
				}
			}
			var userdata = [keys, q, result, start, len, fields, count, null]; // null is cache //[result, q, GetKeys(q), start, len, 0];
			this.Scan(function(o, id, var userdata) {
				var result = userdata[2];
				var start = userdata[3];
				var len = userdata[4];
				var fields = userdata[5];
				var count = userdata[6];

				if ((len > 0) && (start > 0)) {
					start--;
					userdata[3] = start;
					return false;
				}
				if (userdata[0]) {
					if (!this.ScanFilter(-1, -1, userdata, 0, o))
						return false;
				}
				if (fields) {
					var new_o = [ ];
					for (var i = 0; i < length fields; i++) {
						var field = fields[i];
						if ((field) && (IsSet(o, field)))
							new_o[field] = o[field];
					}
					o = new_o;
				}
				if (count)
					result[0]++;
				else
					result[length result] = o;

				// stop scanning ?
				if ((len > 0) && (length result >= len))
					return true;
			}, userdata);
			if ((result) && (descending)) {
				result2 = new [];
				var idx = length result - 1;
				for (i = 0; i < length result; i++)
					result2[idx--] = result[i];
				result = result2;
			}
		}
		return result;
	}

	FlushDB(flush_index = true) {
		if (hFile) {
			try {
				this.Flush();
				this.DataSync();
			} catch (var exc) {
				echo "FlushDB error: $exc\n";
			}
		}
		if (flush_index) {
			_Index.Flush();
			if (bm25)
				bm25.flush();
		}
	}

	Drop() {
		if (hFile) {
			fclose(hFile);
			delete hFile;
			_Index.ResetCache();
			_unlink(this.name);
			_unlink(this.name + ".idxn");
			this.DropIndexes();
			cache = new [];
		}	
	}
}
