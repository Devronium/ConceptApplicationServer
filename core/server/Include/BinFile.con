include File.con
include BTree.con
include BM25.con

import standard.lang.serialize
import standard.C.casts
import standard.C.time
import standard.net.socket
import standard.lib.str
import standard.lib.thread
import standard.lib.cripto
import standard.lang.cli

define HEADER_SIZE		64
define DEFAULT_MODULO_SIZE	64
// don't fragment new records (faster)
define NO_FRAGMENTATION_SIZE	DEFAULT_MODULO_SIZE
define MAX_STRUCTURE_SIZE	0x2000

include LucyIndex.con
// define FULLTEXT_INDEX_TYPE	BM25Index
define FULLTEXT_INDEX_TYPE	LucyIndex

define BM25_GRAPH_LEVEL		5
define BM25_QUERY_LEVEL		5
define BM25_MODULO_SIZE		48
define BM25_GRAPH_MODULO_SIZE	72
define BM25_MAX_WORDCACHE	5000
define BM25_MAX_WORDLEN		0
define BM25_USE_HASH		false
define BM25_HASH		Murmur

define MAX_CACHE_OBJECTS	1000

define READ_VBUF_SIZE		4096

// ASCII char record separator
define COMPOSITE_FIELD_SEPARATOR "\x1E"

define INDEX_REFRESH_TIMEOUT	30

class TinQueryParser {
	var min;
	var min_mode = 0;
	var max;
	var max_mode = 0;
	var additional_filter;
	var reversed = false;
	var owner;
	var btree;
	var db;
	var fetch = -1;

	TinQueryParser(arr) {
		if (IsSet(arr, ">")) {
			min = arr[">"];
			min_mode = 1;
		} else
		if (IsSet(arr, ">=")) {
			min = arr[">="];
			min_mode = 2;
		} else
		if (IsSet(arr, "^")) {
			min = arr["^"];
			min_mode = 3;
		} else
		if (IsSet(arr, "*")) {
			min = new RegExp(arr["*"], 1);
			min_mode = 4;
		} else
		if (IsSet(arr, "!=")) {
			min = arr["!="];
			min_mode = 5;
		}

		if (IsSet(arr, "<")) {
			max = arr["<"];
			max_mode = 1;
		} else
		if (IsSet(arr, "<=")) {
			max = arr["<="];
			max_mode = 2;
		}

		if ((typeof arr == "array") && (!min_mode) && (!max_mode)) {
			this.sort(arr);
			min = arr;
			min_mode = 6;
		}
	}

	sort(arr) {
		if (arr) {
			for (var i = 0; i < length arr; i++) {
				for (var j = i + 1; j < length arr; j++) {
					var ni = arr[i];
					var nj = arr[j];
					if (ni > nj) {
						arr[i] = nj;
						arr[j] = ni;
					}
				}
			}
		}
	}

	Differs(key, val) {
		if ((typeof key != "string") && (typeof key != "numeric"))
			return false;

		if (typeof min == "array") {
			for (var i = 0; i < length min; i++) {
				var e = min[i];
				if (key == e)
					return false;
			}
			return true;
		} else
		if (key == min)
			return false;

		return true;
	}

	Equals(key, val, remove = false) {
		if ((typeof key != "string") && (typeof key != "numeric"))
			return false;

		if (typeof min == "array") {
			for (var i = 0; i < length min; i++) {
				var e = min[i];
				if (key == e) {
					if (remove)
						min = this.Remove(min, i);
					return true;
				}
			}
			return false;
		} else
		if (key == min)
			return true;

		return false;
	}

	CompareSimple(key, val) {
		if (reversed) {
			var t = key;
			key = val;
			val = t;
		}

		var min = this.min;
		var max = this.max;

		if (min_mode == 1) {
			if (key <= min)
				return false;
		}
		if (min_mode == 2) {
			if (key < min)
				return false;
		}
		if (min_mode >= 3) {
			if (min_mode == 5)
				return Differs(key, min);
			if (min_mode == 6)
				return Equals(key, min);

			if (typeof key == "numeric")
				key = "" + key;

			if (typeof key != "string")
				return false;

			if (min_mode == 4) {
				if (!min.test(key))
					return false;
			} else {
				if (typeof min != "string")
					return false;
				if ((min) && (Pos(key, min) != 1))
					return false;
			}
		}
		if (max_mode == 1) {
			if (key >= max)
				return false;
		}
		if (max_mode == 2) {
			if (key > max)
				return false;
		}
		return true;
	}

	Remove(arr, index) {
		var[] arr2;
		if (arr) {
			for (var i = 0; i < length arr; i++) {
				if (i != index)
					arr2[length arr2] = arr[i];
			}
		}
		return arr2;
	}

	Compare(key, val, userdata = null, prec_result = 0) {
		if (reversed) {
			var t = key;
			key = val;
			val = t;
		}

		var min = this.min;
		var max = this.max;

		if (fetch == -1) {
			if ((db) && (owner) && (typeof key == "string") && ((min_mode) || (max_mode)))
				fetch = true;
			else
				fetch = false;
		}
		if (fetch) {
			if ((typeof key == "string") && (length key == 8)) {
				if (((typeof min == "string") && (length min > 8)) || ((typeof max == "string") && (length max > 8)) || (min_mode == 5) || (min_mode == 6)) {
					if (val < 0) {
						if (btree)
							val = btree.GetValue(-val);
					}
					if (val >= 0) {
						var o = owner.ById(val, [db]);
						key = o[db];
					} else
						fetch = false;
				} else
					fetch = false;
			}
		}

		if (((min_mode) || (max_mode)) && (typeof key != typeof min))
			key = "" + key;


		var result = prec_result;
		if (min_mode == 1) {
			if (key <= min)
				result |= QUERY_LESS;
		}
		if (min_mode == 2) {
			if (key < min)
				result |= QUERY_LESS;
		}
		if (min_mode >= 3) {
			if (min_mode == 5) {
				result |= QUERY_LESS | QUERY_GREAT;
				if (Differs(key, min))
					result |= QUERY_ELEMENT_VALID;
			} else
			if (min_mode == 6) {
				result |= QUERY_LESS | QUERY_GREAT;
				if (Equals(key, min, true))
					result |= QUERY_ELEMENT_VALID;
				else
				if (min) {
					var arr_min;
					var arr_max;
					if (length min == 1) {
						arr_min = min[0];
						arr_max = arr_min;
					} else {
						arr_min = min[0];
						arr_max = min[length min - 1];
					}
					if (key < arr_min)
						result = prec_result | QUERY_LESS;
					else
					if (key > arr_max)
						result = prec_result | QUERY_GREAT;
				} else
					return 0;
			} else {
				if (typeof key == "numeric")
					key = "" + key;

				if (typeof key != "string")
					result |= QUERY_LESS;
				else
				if (min_mode == 4) {
					if (!min.test(key))
						result |= QUERY_LESS | QUERY_GREAT;
				} else {
					if (typeof min != "string")
						result |= QUERY_LESS;
					else
					if ((min) && (Pos(key, min) != 1)) {
						if (key < min)
							result |= QUERY_LESS;
						else
							result |= QUERY_GREAT;
					}
				}
			}
		}

		if (max_mode == 1) {
			if (key >= max)
				result |= QUERY_GREAT;
		}
		if (max_mode == 2) {
			if (key > max)
				result |= QUERY_GREAT;
		}

		if (!result)
			result = QUERY_INTERVAL;

		if ((result & QUERY_ELEMENT_VALID) && (additional_filter)) {
			if (val >= 0) {
				if (!additional_filter(key, val, userdata, result, null))
					return QUERY_SKIP;
			}
		}
		return result;
	}
}

class BinIndex {
	protected var f;
	protected var _last_error;
	protected var _name;
	protected var _mode;
	protected var _size;
	protected var _cmp;
	protected var _cmp_reversed;
	protected var UserData;
	protected var[] index_cache;

	public var Unique = false;
	public var Database = "";
	public var CacheRoot = false;
	public var Locked = false;
	public var GetIndexFields;
	public property LastError { get _last_error }
	public property LastErrorString { get GetLastErrorString }

	// public var __vbufsize = 0;

	BinIndex(name, cmp_func, cmp_reversed, mode = "r+b") {
		this._name = name;
		this._mode = mode;
		this._cmp = cmp_func;
		this._cmp_reversed = cmp_reversed;
	}

	ResetCache() {
		index_cache = new [];
	}

	FilterName(origname) {
		if (GetIndexFields)
			return GetIndexFields(origname);

		if (Pos(origname, "composite.") == 1)
			origname = StrSplit(SubStr(origname, 10), "&");
		return origname;
	}

	GetIndex(idxname, fields = null) {
		var origname = idxname;
		idxname = this._name + "." + idxname + ".idx";
		var idx = index_cache[idxname];
		if (idx) {
			idx.CacheRoot = this.CacheRoot;
			if ((!Locked) || (Locked == 2)) {
				if (Locked == 2)
					Locked = 1;
				if (idx.Reopen()) {
					// var f_handle = idx.File.Handle;
					// if (f_handle)
					// 	setvbuf(f_handle, __vbufsize);
					return idx;
				}
			} else {
				// f_handle = idx.File.Handle;
				// if (f_handle)
				// 	setvbuf(f_handle, __vbufsize);
				return idx;
			}

			index_cache[idxname] = null;
			console.error(LOG_THIS, "Error #${_errno()} reopening index $idxname");
			return null;
		}
		if (Locked == 2)
			Locked = 1;

		var f = new File(_mode);
		if (!FileExists(idxname))
			WriteFile("", idxname);
		f.Name = idxname;

		if (f.Open()) {
			// setvbuf(f.Handle, __vbufsize);
			if (fields)
				origname = fields;
			else
				origname = FilterName(origname);

			if (Unique)
				idx = new BTreeFile(f, this._cmp, origname, true);
			else
				idx = new BTreeFile(f, this._cmp_reversed, origname, false);
			index_cache[idxname] = idx;
			idx.CacheRoot = this.CacheRoot;
			return idx;
		}
		return null;
	}

	NewTree(idxname, fields = null) {
		var idx = GetIndex(idxname, fields);
		if (idx)
			return idx.CreateSubtree();
		return -1;
	}

	DropIndex(idxname) {
		_unlink(this._name + "." + idxname + ".idx");
	}

	Put(objid, db = "", cached_val = "dumybear", flush = true) {
		if (!db)
			db = this.Database;
		var code;
		var btree = GetIndex(db);
		if (!btree)
			throw "Cannot open index (${@class}.${@member})";
		btree.UserData = FilterName(db);
		if (Unique)
			code = btree.Add(objid, cached_val, Unique);
		else
			code = btree.Add(cached_val, objid);
		if (flush)
			btree.File.Flush();
		return code;
	}

	operator << (values) {
		this.Put(values);
		return this;
	}

	operator[](key) {
		return this.Fetch(key);
	}

	Fetch(key, descending=false, start = -1, len = -1) {
		var btree = GetIndex(this.Database);
		if (!btree)
			throw "Cannot open index (${@class}.${@member})";

		if (typeof key == "string") {
			var val = btree.Get(key, var found);
			if ((!Unique) && (found)) {
				// return all values
				return btree.Query(null, null, descending, len, start, val);
			}
			if (found)
				return val;
			_last_error = 1;
		}
		return null;
	}

	_FetchMultiple(array keys, no_index_query = null, filter_func = null, owner = null, descending = false, start = 0, len = 0) {
		_last_error = 0;
		var databases = GetKeys(keys);
		var[] result;
		for (var i = 0; i < length databases; i++) {
			var db = databases[i];
			var key = keys[db];
			var btree = GetIndex(db);
			if (btree) {
				var no_index_keys;
				if (no_index_query) {
					no_index_keys = GetKeys(no_index_query);
					if (filter_func) {
						for (var k = 0; k < length no_index_keys; k++) {
							var ni_key = no_index_keys[k];
							var ni_q = no_index_query[ni_key];
							if (typeof ni_q == "array") {
								var ni_key_list = GetKeys(ni_q);
							 	if ((ni_key_list) && (ni_key_list[0])) {
									var ni_qp = new TinQueryParser(ni_q);
									ni_qp.reversed = this.Unique;
									ni_qp.btree = btree;
									no_index_query[ni_key] = ni_qp;
								}
							}
						}
					}
					no_index_keys = [no_index_keys, no_index_query];
				} else
					filter_func = null;

				if (typeof key == "array") {
					// var key_list = GetKeys(key);
					if (len <= 0)
						len = -1;
					// if ((key_list) && (key_list[0])) {
					var qp = new TinQueryParser(key);
					qp.owner = owner;
					qp.db = db;
					qp.btree = btree;
					//var no_index_keys;
					// if (no_index_query) {
					//	no_index_keys = GetKeys(no_index_query);
					if (no_index_keys) {
						qp.reversed = this.Unique;
						qp.additional_filter = filter_func;
					}
					//	no_index_keys = [no_index_keys, no_index_query];
					// }
					result = btree.Query(qp.Compare, no_index_keys, descending, len, start, filter_func);
					return result;
					// }
					// for (var j = 0; j < length key; j++) {
					//	var subkey = key[j];
					//	var res = btree.Get(subkey, var found, start, len, filter_func, no_index_keys);
					//	if (found) {
					//		if (typeof res == "array") {
					//			for (var i1 = 0; i1 < length res; i1++)
					//				result += res[i1];
					//		} else
					//			result += res;
					//	}
					// }
				} else {
					var res = btree.Get(key, var found, start, len, filter_func, no_index_keys);
					if (found) {
						if (typeof res == "array") {
							if (result) {
								for (var i1 = 0; i1 < length res; i1++)
									result += res[i1];
							} else
								result = res;
						} else
							result += res;
					}
				}
			}
		}
		return result;
	}


	RemoveKey(key, flush = true) {
		var btree = GetIndex(this.Database);
		if (!btree)
			throw "Cannot open index (${@class}.${@member})";
		btree.DeleteByKey(key);
		if (flush)
			btree.File.Flush();
	}

	Remove(key, val, database = "", flush = true) {
		if (!database)
			database = this.Database;
		var btree = GetIndex(database);
		if (!btree)
			throw "Cannot open index (${@class}.${@member})";
		var code;
		//if (Unique)
			code = btree.Delete(key, val);
		//else
		//	code = btree.Delete(val, key);
		if (flush)
			btree.File.Flush();
		return code;
	}

	Drop(database) {
		if (_unlink(database))
			return false;
		return true;
	}

	Count(key="") {
		return 0;
	}


	Close() {
		_last_error = 0;
	}

	GetLastErrorString() {
		if (_last_error)
			return "Key not found";
		return "";
	}

	Flush(sync = true) {
		for (var i = 0; i < length index_cache; i++) {
			var idx = index_cache[i];
			if (idx) {
				var f = idx.File;
				if (f) {
					try {
						f.Flush();
						if (sync)
							f.DataSync();
					} catch (var exc) {
						console.error(LOG_THIS, "Index flush error: $exc");
					}
				}
			}
		}
	}
}

class BM25Index {
	var lang = "en";
	var[] fields;
	var file;
	var wordsfile;
	var graphfile;
	var dl;
	var N;
	var Locked;

	BM25Index(basename = "", fields = null, lang = "en") {
		this.lang = lang;
		this.fields = fields;
		if (basename) {
			var word_format = "s" + BM25_MAX_WORDLEN;
			if (BM25_USE_HASH)
				word_format = "U32";
			file = FixedStorageHelper::Create(basename + ".words", "r+b", ["w" => word_format, "d" => "U64", "a" => "U64", "l" => "U32"]);
			if (!file.Open()) {
				console.error(LOG_THIS, "Error #${_errno()} opening BM25 index (words): " + file.Name);
				file = null;
				return;
			}
			wordsfile = FixedStorageHelper::Create(basename + ".all", "r+b", ["w" => word_format, "a" => "U64"]);
			if (!wordsfile.Open()) {
				console.error(LOG_THIS, "Error #${_errno()} opening BM25 index (all): " + wordsfile.Name);
				wordsfile = null;
				file = null;
				return;
			}
			var graph_structure = [ ];
			for (var j = 0; j < BM25_GRAPH_LEVEL; j++)
				graph_structure["" + j] = "U32";
			graph_structure["d"] = "U64";
			graphfile = FixedStorageHelper::Create(basename + ".graph", "r+b", graph_structure);
			if (!graphfile.Open()) {
				console.error(LOG_THIS, "Error #${_errno()} opening BM25 index (graph): " + graphfile.Name);
				wordsfile = null;
				file = null;
				graphfile = null;
				return;
			}
			try {
				file.EnsureIndex("w");
				file.EnsureIndex("d");
				file.EnsureIndex(["w", "d"]);
				wordsfile.EnsureIndex("w");
				for (var i = 0; i < BM25_GRAPH_LEVEL; i++)
					graphfile.EnsureIndex("" + i);
				// graphfile.EnsureIndex("a");
				// graphfile.EnsureIndex(["a", "b"]);
				// not needed yet & slow
				// graphfile.EnsureIndex(["a", "b", "d"]);
				graphfile.EnsureIndex("d");
			} catch (var exc) {
				console.error(LOG_THIS, "BM25 index error: $exc");
			}
		}
	}

	Reopen() {
		if (file) {
			if (!file.Open())
				console.error(LOG_THIS, "Error #${_errno()} opening BM25 index (words): " + file.Name);
		}
		if (wordsfile) {
			if (!wordsfile.Open())
				console.error(LOG_THIS, "Error #${_errno()} opening BM25 index (all): " + wordsfile.Name);
		}
		if (graphfile) {
			if (!graphfile.Open())
				console.error(LOG_THIS, "Error #${_errno()} opening BM25 index (graph): " + graphfile.Name);
		}
	}

	SetIndexLock(lock) {
		if (file)
			file.SetIndexLock(lock);
		if (wordsfile)
			wordsfile.SetIndexLock(lock);
		if (graphfile)
			graphfile.SetIndexLock(lock);
		Locked = lock;
	}

	ReleaseLock() {
		if (file)
			file.ReleaseLock();
		if (wordsfile)
			wordsfile.ReleaseLock();
		if (graphfile)
			graphfile.ReleaseLock();
	}

	protected recursive(o) {
		var document = "";
		for (var i = 0; i < length o; i++) {
			var e = o[i];
			if (e) {
				if (document)
					document += ";";
				if (typeof e == "array")
					document += recursive(e);
				else
					document += e;
			}
		}
		return document;
	}

	static wordlengthlimit(word) {
		if ((BM25_MAX_WORDLEN) && (!BM25_USE_HASH))
			word = SubStr("" + word, 0, BM25_MAX_WORDLEN);
		return word;
	}

	document(o, var graph = null, graph_level = 0) {
		if (typeof o != "array")
			o = ToArray(o);

		var document = "";
		if (fields) {
			for (var i = 0; i < length fields; i++) {
				var f = fields[i];
				if ((f) && (f != '$') && (f != '$oid') && (f != '$v') && (IsSet(o, f))) {
					var k = o[f];
					if (k) {
						if (typeof k == "array")
							k = recursive(k);
						if (document)
							document += ";";
						document += wordlengthlimit(k);
					}
				}
			}
		} else {
			var keys = GetKeys(o);
			for (i = 0; i < length keys; i++) {
				k = keys[i];	
				if ((k) && (k != '$') && (k != '$oid') && (k != '$v')) {
					var k2 = o[k];
					if (k2) {
						if (typeof k2 == "array")
							k2 = recursive(k2);
						if (document)
							document += ";";
						document += wordlengthlimit(k2);
					}
				}
			}
		}
		if (!document)
			return null;

		return BM25::document(document, lang, graph, graph_level, 0, true);
	}

	samefields(fields) {
		if (!this.fields) {
			if (fields)
				return false;
			return true;
		}
		if (!fields)
			return false;

		if (length fields != length this.fields)
			return false;

		for (var i = 0; i < length fields; i++) {
			var k = fields[i];
			if (k) {
				var found = false;
				for (var j = 0; j < length this.fields; j++) {
					var k2 = this.fields[j];
					if ((k2) && (k2 == k)) {
						found = true;
						break;
					}
				}
				if (!found)
					return false;
			}
		}
		return true;
	}

	protected delete_index(findex, id) {
		var objects = findex.Query(["d" => id], ['$', 'd']);
		if (objects) {
			// clean old objects
			for (var i = 0; i < length objects; i++) {
				var o = objects[i];
				if ((o) && (o['d'] == id)) {
					var ref_id = o['$'];
					if (ref_id)
						findex.Delete(ref_id);
				}
			}
		}
	}

	protected docadd(documents, add) {
		if (!add)
			return;
		for (var i = 0; i < length add; i++) {
			var d = add[i];
			if (d) {
				var id = d["d"];
				if (id) {
					var key = "" + id;
					documents[key] = id;
				}
			}
		}
		return true;
	}

	protected docadd_match(documents, match, add) {
		if (!add)
			return;
		for (var i = 0; i < length add; i++) {
			var d = add[i];
			if (d) {
				var id = d["d"];
				if (id) {
					var key = "" + id;
					documents[key] = id;
					match[key]++;
				}
			}
		}
		return true;
	}

	arrayset(arr, key, word, val) {
		key = "" + key;
		var arr2 = arr[key];
		if (!arr2) {
			arr2 = new [];
			arr[key] = arr2;
		}
		arr2["" + word] = val;
	}

	statistics(word_query, n, f, lens, start, len, documents = null, add_to_documents = false) {
		// incomplete !!!
		// to sort by relevance !!!
		var wl = file.Query(word_query, null, false, start, len);
		if (wl) {
			var word = word_query["w"];
			if (!word)
				return false;
			if (add_to_documents)
				docadd(documents, wl);
			for (var i = 0; i < length wl; i++) {
				var wdoc = wl[i];
				if (wdoc) {
					var doc_id = wdoc["d"];
					var doc_len = wdoc["l"];
					var doc_word_count = wdoc["a"];
					if (doc_id) {
						var word_statistics_arr = wordsfile.Query(["w" => word], null, false, 0, 1);
						if (word_statistics_arr) {
							var word_statistics = word_statistics_arr[0];
							var n_qi = word_statistics["a"];
							if ((n_qi) && (doc_len) && (doc_word_count)) {
								// all elements encountered
								arrayset(n, doc_id, word, n_qi);
								arrayset(f, doc_id, word, doc_word_count / doc_len);
								lens["" + doc_id] = doc_len;
							}
						}
					}
				}
			}
			return true;
		}
		return false;
	}

	__tostring(arr) {
		var[] arr2;
		if (arr) {
			for (var i = 0; i < length arr; i++)
				arr2[i] = "" + arr[i];
		}
		return arr2;
	}

	search(string query, start = 0, len = 100) {
		if (file) {
			if (len <= 0)
				len = 100;
			var words = BM25::document(query, lang, null, 0, 0, true);
			if (words) {
				var all_words = GetKeys(words);
				var documents = new [];
				var n = new [];
				var f = new [];
				var lens = new [];
				var len_coef = len;
				if (len_coef < 30)
					len_coef = 30;
				var threshold = 0;
				var threshold2 = 0;

				if (BM25_USE_HASH) {
					for (var i = 0; i < length all_words; i++) {
						var word = all_words[i];
						if (word)
							all_words[i] = BM25_HASH(word);
					}
				}

				if (length words == 1) {
					if (!statistics(["w" => all_words[0]], n, f, lens, start, len_coef, documents, true))
						return null;
				} else {
					if (length all_words < BM25_QUERY_LEVEL) {
						var all_words2 = new [];
						for (i = 0; i < length all_words; i++) {
							word = all_words[i];
							if (word) {
								var word_statistics_arr = wordsfile.Query(["w" => word], null, false, 0, 1);
								if (word_statistics_arr) {
									var word_statistics = word_statistics_arr[0];
									var word_count = word_statistics["a"];
									var word_key = "" + word_count;
									while (length word_key < 10)
										word_key = "0" + word_key;
									word_key += "." + i;
									all_words2[word_key] = word;
								}
							}
						}
						if (all_words2)
							all_words = KeySorted(all_words2);
					}
					// first strategy, words at 1 distance
					var graph;
					if (BM25_USE_HASH)
						graph = BM25::complete(__tostring(all_words), BM25_QUERY_LEVEL, 0, true);
					else
						graph = BM25::complete(all_words, BM25_QUERY_LEVEL, 0, true);
					var[] match;
					for (i = 0; i < length graph; i++) {
						var g = graph[i];	
						if (g) {
							for (var j = 0; j < BM25_QUERY_LEVEL; j++) {
								var key_g = "" + j;
								var gk = g[key_g];
								if (gk)
									docadd_match(documents, match, graphfile.Query([key_g => gk], ["d"], false, start, len_coef));
							}
						}
					}
					// second strategy (words at > 1 distance)
					if (length documents < len) {
						if (length documents)
							threshold = length documents;
						for (i = 0; i < length graph; i++) {
							g = graph[i];	
							if (g) {
								for (j = 0; j < length g; j++) {
									gk = g[j];
									if (gk) {
										for (var j1 = 0; j1 < BM25_QUERY_LEVEL; j1++) {
											key_g = "" + j1;
											docadd_match(documents, match, graphfile.Query([key_g => gk], ["d"], false, start, len_coef));
										}
									}
								}
							}
						}
					}
					// any word
					if (length documents < len) {
						if (!threshold)
							threshold = length documents;
						if (!threshold2)
							threshold2 = length documents;
						for (i = 0; i < length all_words; i++)
							statistics(["w" => all_words[i]], n, f, lens, start, len_coef, documents, true);
					}
				}
				for (i = 0; i < length documents; i++) {	
					var id = documents[i];
					if (id) {
						var key_id = "" + id;
						if (!n[key_id]) {
							for (j = 0; j < length all_words; j++) {
								word = all_words[j];
								if (word)
									statistics(["w" => word, "d" => id], n, f, lens, start, len_coef);
							}
						}
					}
				}
				var avgdl = 0;
				if (N)
					avgdl = dl/N;
				// some arbitray fall-back value (this should never happen)
				if (!avgdl)
					avgdl = 100;

				var k1 = 1.2;
				var b = 0.75;
				var bm25_array = new [];
				for (i = 0; i < length documents; i++) {
					id = documents[i];
					if (id) {
						key_id = "" + id;
						var sum = 0;
						var d_len = lens[key_id];
						if (d_len) {
							for (j = 0; j < length all_words; j++) {
								var qi = "" + all_words[j];
								var d_n = n[key_id];
								var d_f = f[key_id];
								if ((d_n) && (d_f)) {
									var idf = BM25::idf(N, d_n[qi]);
									var f2 = d_f[qi];
									sum += idf * (f2 * (k1 + 1)) / (f2 + k1 * (1 - b + b * d_len / avgdl));

									if ((threshold) && (i < threshold))
										sum += 100;
									else
									if ((threshold2) && (i < threshold2))
										sum += 20;
									sum += sum * match[key_id];
								}
							}
						}
						bm25_array[key_id] = sum;
					}
				}
				if (bm25_array) {
					var new_documents = new [];
					for (i = 0; i < length bm25_array; i++) {
						var key = "" + (10000000 - floor(bm25_array[i] * 100000)) + "." + i;
						new_documents[key] = documents[i];
					}
					documents = KeySorted(new_documents);
					if ((len > 0) && (length documents > len)) {
						new_documents = new [];
						for (i = 0; i < len; i++)
							new_documents[i] = documents[i];
					}
					documents = new_documents;
				}
				return documents;
			}
		}
		return null;
	}

	increment(dl, inc = 1) {
		if (inc > 0) {
			this.N += inc;
			this.dl += dl;
		}
	}

	dumpcache(var wordcache, var cache1 = null, var cache2 = null) {
		if (wordcache) {
			for (var i = 0; i < length wordcache; i++) {
				var w = wordcache[i];
				if (w) {
					try {
						var update_index = true;
						if ((IsSet(w, '$')) && (w['$'] > 0))
							update_index = false;
						wordsfile.Store(w, update_index);
					} catch (var exc) {
						console.error(LOG_THIS, "BM25 dumpcache error: $exc");
					}
				}
			}
			wordcache = ["." => null];
		}
		if (cache1) {
			this.dump(file, cache1);
			cache1 = new [];
		}
		if (cache2) {
			this.dump(graphfile, cache2);
			cache2 = new [];
		}
	}

	dump(targetfile, var cache, sync_index = true) {
		if (cache)
			targetfile._FastStoreMulti(cache, sync_index, false);
	}

	notifybulk() {
		if (file)
			file.InvalidateAndRebuildIndexes();

		if (graphfile)
			graphfile.InvalidateAndRebuildIndexes();
	}

	delete_before_update(id) {
		if (id > 0) {
			delete_index(file, id);
			delete_index(graphfile, id);
		}
	}

	update(document, id, changed_keys = null, graph = null, do_flush = true, var wordcache = null, cache1 = null, cache2 = null, check_existing_index = true, sync_index = true) {
		if (!document)
			return false;
		if ((changed_keys) && (fields)) {
			var key_exists = false;
			for (var i = 0; i < length changed_keys; i++) {
				var k = changed_keys[i];
				if (k) {
					for (var j = 0; j < length fields; j++) {
						var k2 = fields[j];
						if (k == k2) {
							key_exists = true;
							break;
						}
					}
					if (key_exists)
						break;
				}
			}
			if (!key_exists)
				return false;
		}
		if (id > 0) {
			var word_count = BM25::doclen(document);
			if (word_count) {
				if (file) {
					if (check_existing_index) {
						delete_index(file, id);
						delete_index(graphfile, id);
					}
					var words = GetKeys(document);
					var word_arr;
					if (wordcache)
						word_arr = cache1;
					else
						word_arr = new [];

					for (i = 0; i < length words; i++) {
						var word = words[i];
						if (word) {
							try {
								//file.Store(["w" => word, "d" => id, "a" => document[word], "l" => word_count], true, false);
								var w = null;
								var update_index = true;

								var word_key;
								if (BM25_USE_HASH)
									word_key = BM25_HASH(word);
								else
									word_key = word;

								word_arr[length word_arr] = ["w" => word_key, "d" => id, "a" => document[word], "l" => word_count];

								if ((wordcache) && (IsSet(wordcache, word))) {
									w = wordcache[word];
								} else {
									var wl = wordsfile.Query(["w" => word_key], null, false, 0, 1);

									if (wl)
										w = wl[0];
								}
								if (w) {
									w["a"]++;
									update_index = false;
								} else
									w = ["w" => word_key, "a" => 1];

								if (wordcache)
									wordcache[word] = w;
								else
									wordsfile.Store(w, update_index, false);

							} catch (var exc) {
								console.error(LOG_THIS, "BM25 store error: $exc");
								return false;
							}
						}
					}
					if ((word_arr) && (!wordcache))
						file._FastStoreMulti(word_arr, sync_index, false);
					if (graph) {
						for (i = 0; i < length graph; i++) {
							var g = graph[i];
							if (g) {
								g["d"] = id;
								if (wordcache)
									cache2[length cache2] = g;
								//graphfile.Store(g, true, false);
							}
						}
						if (!wordcache)
							graphfile._FastStoreMulti(graph, sync_index, false);
					}
					if (!changed_keys)
						increment(word_count);

					if (do_flush)
						this.flush();
				}
			}
		}
		return true;
	}

	flush() {
		if (file) {
			file.FlushDB();
			wordsfile.FlushDB();
			graphfile.FlushDB();
		}
	}

	Close() {
		flush();
		if (file) {
			try {
				file.Reset();
			} catch (var exc) {
			}
			try {
				file.Close();
			} catch (exc) {
			}
		}
		if (wordsfile) {
			try {
				wordsfile.Reset();
			} catch (exc) {
			}
			try {
				wordsfile.Close();
			} catch (exc) {
			}
		}
		if (graphfile) {
			try {
				graphfile.Reset();
			} catch (exc) {
			}
			try {
				graphfile.Close();
			} catch (exc) {
			}
		}
		file = null;
		wordsfile = null;
		graphfile = null;
	}

	Delete() {
		flush();
		if (file) {
			try {

				file.Drop();
			} catch (var exc) {
			}
			try {
				file.Reset();
			} catch (exc) {
			}
		}
		if (wordsfile) {
			try {
				wordsfile.Drop();
			} catch (exc) {
			}
			try {
				wordsfile.Reset();
			} catch (exc) {
			}
		}
		if (graphfile) {
			try {
				graphfile.Drop();
			} catch (exc) {
			}
			try {
				wordsfile.Reset();
			} catch (exc) {
			}
		}
		file = null;
		wordsfile = null;
		graphfile = null;

	}

	ResetCache() {
		if (file)
			file.ResetCache();
		if (wordsfile)
			wordsfile.ResetCache();
		if (graphfile)
			graphfile.ResetCache();
	}

	finalize() {
		Close();
	}
}

class BinFile extends File {
	protected var deleted_records = 0;
	protected var _Index;
	protected var bm25;
	protected var cache_obj;
	protected var cache_id;
	protected var[] cache;
	protected var has_garbage;
	protected var locked;

	public var Compress = false;

	public property DeletedRecords { get deleted_records }
	public var[] Indexes;
	public var[] MinIndexFields;
	protected var[] LookForFields;
	protected var MODULO_SIZE = DEFAULT_MODULO_SIZE;
	public var Debug = false;
	public var[] __debug_block_info;
	protected var index_refresh_time;
	protected var _prec_bulk_op;
	public var DebugPath;
	public var Journal;

	BinFile(filename, mode="r+b", default_block_size = DEFAULT_MODULO_SIZE, use_index = true) {
		super(mode);
		this.name  = filename;
		if (use_index) {
			_Index = new BinIndex(filename, this.CompareObjects, this.CompareObjectsReversed);
			_Index.GetIndexFields = this.GetIndexFields;
			_Index.Unique = false;
			if (default_block_size > 16)
				MODULO_SIZE = default_block_size;

			this.RefreshIndexes();
		}
	}

	SetIndexLock(lock) {
		if (_Index)
			_Index.Locked = lock;
	}

	GetIndexFields(name) {
		if (IsSet(Indexes, name)) {
			var idx = Indexes[name];
			if (idx) {
				if (typeof idx == "array")
					return idx[1];
				return idx;
			}
		}
		return "";
	}
	
	DropBM25Index() {
		var dropped = false;
		if (bm25) {
			bm25.Delete();
			bm25.Close();
			bm25 = null;
			dropped = true;
		}
		if (this.name)
			_unlink(this.name+ ".bm25");
		return dropped;
	}

	RemoveIndex(fields) {
		var idxname = this.IndexName(fields);
		if (!idxname)
			return false;
		if (!Indexes)
			return false;
		if (!IsSet(Indexes, idxname))
			return false;
		var idx = _Index.GetIndex(idxname, fields);
		if (!idx)
			return false;

		var index_keys = GetKeys(Indexes);
		var new_indexes = new [];
		for (var i = 0; i < length index_keys; i++) {
			var k = index_keys[i];
			if ((k) && (k != idxname))
				new_indexes[k] = Indexes[k];
		}
		Indexes = new_indexes;
		WriteFile(BinarizeObject(Indexes), name + ".idxn");
		this.RefreshIndexes();
		_Index.ResetCache();
		_Index.DropIndex(idxname);
		return true;
	}

	DeleteIndexes(array fields) {
		this.RefreshIndexes();
		var count = 0;
		for (var i = 0; i < length fields; i++) {
			var field = fields[i];
			if (field) {
				if (this.RemoveIndex(field))
					count++;
			}
		}
		return count;
	}

	BeginBulkOp() {
		_prec_bulk_op = _Index.CacheRoot;
		_Index.CacheRoot = true;
	}

	EndBulkOp() {
		_Index.CacheRoot = _prec_bulk_op;
	}

	CreateFullText(name, fields = null, lang = "en") {
		bm25 = new FULLTEXT_INDEX_TYPE(name, fields, lang);
		if (classof bm25 == "BM25Index") {
			bm25.dl = fields["dl"];
			bm25.N = fields["N"];
		}
	}

	RefreshIndexes() {
		index_refresh_time = time();
		var filename = this.name;
		var data = ReadFile(filename + ".idxn");
		if (data) {
			Indexes = UnBinarizeObject(data);
			if (!Indexes)
				Indexes  = new [];
			this.SyncIndexes();
		}

		var bm25_name = filename + ".bm25";
		if (FileExists(bm25_name)) {
			data = ReadFile(bm25_name);
			if (data) {
				var fields = UnBinarizeObject(data);
				if (typeof fields == "array") {
					var lang = "en";
					if (fields["lang"])
						lang = fields["lang"];

					this.CreateFullText(bm25_name, fields["fields"], lang);
				}
			}
		}
	}

	Lock(write = false) {
		if (hFile) {
			if (write) {
				setvbuf(hFile, 0);
				// if (_Index)
				//	_Index.__vbufsize = 0;
			} else {
				setvbuf(hFile, READ_VBUF_SIZE);
				// if (_Index)
				// 	_Index.__vbufsize = READ_VBUF_SIZE;
			}
			locked = 1 + write;
			if (write)
				return WorkerSharedRWLock(this.name, RWLOCK_WRITE); // LockFileBytes(hFile, F_SETLKW, start, len);
			return WorkerSharedRWLock(this.name, RWLOCK_READ);// LockFileBytes(hFile, F_SETLKW, start, len, SEEK_SET, F_RDLCK);
		}
		return false;
	}

	Unlock(write = false) {
		if (locked) {
			locked = false;
			if (hFile) {
				setvbuf(hFile, 0);
				if (write)
					return WorkerSharedRWLock(this.name, RWUNLOCK_WRITE); //LockFileBytes(hFile, F_UNLCK, start, len);
				return WorkerSharedRWLock(this.name, RWUNLOCK_READ); // LockFileBytes(hFile, F_UNLCK, start, len, SEEK_SET, F_RDLCK);
			}
		}
		return false;
	}

	ReleaseLock() {
		if (locked == 1)
			this.Unlock();
		else
		if (locked == 2)
			this.Unlock(true);
	}

	SyncIndexes() {
		LookForFields = new [];
		for (var i = 0; i < length Indexes; i++) {
			var index = Indexes[i];
			if (index) {
				var arr;
				if (typeof index != "array")
					arr = [index];
				else
					arr = index[1];

				for (var j = 0; j < length arr; j++)
					LookForFields += StrSplit(arr[j], ".");
			}
		}
		MinIndexFields = this.MinFields();
	}

	DropIndexes() {
		LookForFields = new [];
		for (var i = 0; i < length Indexes; i++) {
			var index = Indexes[i];
			if (index) {
				if (typeof index == "string")
					_Index.DropIndex(index);
				else
				if (typeof index == "array")
					_Index.DropIndex(index[0]);
			}
		}
		Indexes = new [];
		this.ResetCache();
	}

	Check(repair = false, var repaired = false) {
		repaired = false;
		if (fseek(hFile, 0, SEEK_END))
			return false;
		var pos = ftell(hFile);
		var payload_size = pos - HEADER_SIZE;
		var record_size = MODULO_SIZE + 8;
		var rem = payload_size % record_size;
		if (rem) {
			if (repair) {
				var delta = record_size - rem;
				var buf = pack(":$delta");
				if (this.Write(buf) != length buf)
					return false;
				repaired = true;
			} else
				return false;
		}
		return true;
	}

	CompareObjects(a, a_val, b, b_val, btree, bottom_layer) {
		// if (a_val > b_val)
		// 	return 1;
		// if (a_val < b_val)
		// 	return -1;
		var cmp = this.anycmp(a_val, b_val);
		if (cmp)	
			return cmp;
		var type = typeof a_val;
		if ((type == typeof b_val) && (type != "string"))
			return 0;
		return this.CompareObjectsNoCache(a, b, btree, bottom_layer);
	}

	static anycmp(a_val, b_val) {
		if ((typeof a_val == typeof b_val) || (typeof a_val == "string")) {
			if (a_val > b_val)
				return 1;

			if (a_val < b_val)
				return -1;
		} else {
			if (b_val > a_val)
				return -1;

			if (b_val < a_val)
				return 1;
		}
		return 0;
	}

	CompareObjectsReversed(a_val, a, b_val, b, btree, bottom_layer) {
		var b_val_orig = b_val;
		var type_b = typeof b_val;
		if ((type_b == "string") && (length b_val > 8))
			b_val = SubStr(b_val, 0, 8);

		var type = typeof a_val;
		var cmp = anycmp(a_val, b_val);
		if (cmp)
			return cmp;
		// if (a_val > b_val)
		// 	return 1;

		// if (a_val < b_val)
		// 	return -1;

		if (type == "string") {
			if (length a_val < 8)
				return 0;
		} else
		if (type == type_b)
			return 0;

		if (a == b)
			return 0;

		if (a < -1)
			a = btree.GetValue(-a);

		if (b < -1)
			b = btree.GetValue(-b);

		if (a == b)
			return 0;

		if (b == -1)
			return this.CompareSearchObject(a, b_val_orig, btree, bottom_layer);

		return this.CompareObjectsNoCache(a, b, btree, bottom_layer, b_val_orig);
	}

	CompareSearchObject(a, key_b, btree, bottom_layer) {
		var obj_a;
		var key = btree.UserData;

		if (a == cache_id) {
			obj_a = cache_obj;
		} else {
			if (length cache > MAX_CACHE_OBJECTS)
				cache = new [];
			obj_a = this.ById(a, LookForFields, !bottom_layer, cache);
		}
		if (obj_a != null) {
			var key_a;
			if (typeof key == "array")
				key_a = this.GetObjectFieldsAsString(obj_a, key);
			else
			if (!this.IsSet2(obj_a, StrSplit(key, "."), key_a))
				throw "Error in compare objects (non existing object) ($a), call stack:\n${_callstack()}";
			//key_a = obj_a[key];

			return anycmp(key_a, key_b);
			/* if (key_a > key_b)
				return 1;
			if (key_a < key_b)
				return -1;

			return 0;*/
		}
		throw "Error in compare objects (non existing object) ($a), call stack:\n${_callstack()}";
		// error
		return -2;
	}

	CompareObjectsWith(a, b, btree, bottom_layer) {
		var obj_a;
		var obj_b;
		var key = btree.UserData;

		if (length cache > MAX_CACHE_OBJECTS)
			cache = new [];

		if (a == cache_id) {
			obj_a = cache_obj;
			obj_b = this.ById(b, MinIndexFields, !bottom_layer, cache);
		} else
		if (b == cache_id) {
			obj_b = cache_obj;
			obj_a = this.ById(a, MinIndexFields, !bottom_layer, cache);
		} else {
			var res = this.ById([a,b], MinIndexFields, !bottom_layer, cache);
			obj_a = res[0];
			obj_b = res[1];
		}

		if ((obj_a != null) && (obj_b != null)) {
			var key_a;
			var key_b;
			if (typeof key == "array") {
				key_a = this.GetObjectFieldsAsString(obj_a, key);
				key_b = this.GetObjectFieldsAsString(obj_b, key);
			} else {
				key_a = obj_a[key];
				key_b = obj_b[key];
			}
			return anycmp(key_a, key_b);
			/*if (key_a > key_b)
				return 1;
			if (key_a < key_b)
				return -1;
			return 0;*/
		}
		throw "Error in compare objects (non existing object) ($a/$b), call stack:\n${_callstack()}";
		// error
		return -2;
	}

	CompareObjectsNoCache(a, b, btree, bottom_layer, b_val_orig = null) {
		var obj_a;
		var obj_b;
		var key_a;
		var key_b;

		var key = btree.UserData;

		if (length cache > MAX_CACHE_OBJECTS)
			cache = new [];

		if (a == cache_id) {
			obj_a = cache_obj;
			obj_b = this.ById(b, MinIndexFields, !bottom_layer, cache);
		} else
		if (b == cache_id) {
			obj_b = cache_obj;
			obj_a = this.ById(a, MinIndexFields, !bottom_layer, cache);
		} else {
			var res = this.ById([a,b], MinIndexFields, !bottom_layer, cache);
			obj_a = res[0];
			obj_b = res[1];
		}
		if ((obj_a != null) && (obj_b != null)) {
			if (typeof key == "array") {
				key_a = this.GetObjectFieldsAsString(obj_a, key);
				if ((!bottom_layer) && (b_val_orig))
					key_b = b_val_orig;
				else
					key_b = this.GetObjectFieldsAsString(obj_b, key);
			} else {
				key_a = obj_a[key];
				key_b = obj_b[key];
			}

			return anycmp(key_a, key_b);
		}
		throw "Error in compare objects (non existing object) ($a/$b), call stack:\n${_callstack()}";
		// error
		return -2;
	}

	ReloadIndex() {
		var data = ReadFile(this.name + ".idxn");
		Indexes = UnBinarizeObject(data);
		if (!Indexes)
			Indexes  = new [];
	}

	override Open;
	Open(with_lock = false) {
		var file_size = filesize(this.name);
		var valid_file = false;
		if (file_size < HEADER_SIZE) {
			WriteFile("", this.name);
			file_size = 0;
		} else
			valid_file = true;

		if (File::Open()) {
			setvbuf(hFile, 0);
			if (valid_file) {
				if (with_lock)
					this.Lock();
				fread(var buf, 1, 6, hFile);
				if ((length buf != 6) || (buf != "CDB010")) {
					this.Close();
					if (with_lock)
						this.ReleaseLock();
					var err = _errno();
					if (err == 13)
						throw "Datafile is locked";
					throw "Invalid or corrupted data file (errno ${err})";
				}
				// this.Read(buf, 4);
				fread(buf, 1, 8, hFile);
				if (length buf == 8)
					deleted_records = unpack("u64", buf)[0];//htonl(tounumber(buf, 32));
				else
					deleted_records = 0;
				fread(buf, 1, 8, hFile);
				if (length buf != 8) {
					if (with_lock)
						this.ReleaseLock();
					throw @class + "." + @member + ": Corrupted header";
				}

				if (unpack("u64", buf)[0])
					has_garbage = true;
				fread(buf, 1, 4, hFile);
				if (length buf != 4) {
					if (with_lock)
						this.ReleaseLock();
					throw @class + "." + @member + ": Corrupted header";
				}
				var msize = unpack("u32", buf)[0];
				if (msize > 16)
					MODULO_SIZE = msize;
				if (with_lock)
					this.ReleaseLock();
			} else
				this.WriteHeader();
			return true;
		}
		return false;
	}

	Reopen(with_lock = false) {
		if (this.Open(with_lock)) {
			if (bm25)
				bm25.Reopen();
		}
	}

	ResetCache(all = false) {
		cache = new [];
		if ((all) && (bm25))
			bm25.ResetCache();
	}

	protected WriteHeader() {
		var header = pack("su64u64u32:" + HEADER_SIZE, "CDB010", deleted_records, 0, MODULO_SIZE);
		//this.Seek(0);	
		fseek(hFile, 0, SEEK_SET);
		this.Write(header);
	}

	protected WriteInfo() {
		//this.Seek(6);
		fseek(hFile, 6, SEEK_SET);
		if (deleted_records < 0)
			deleted_records = 0;
		this.Write(pack("u64", deleted_records));
	}

	protected PushGarbage(offset) {
		if (fseek(hFile, 14, SEEK_SET))
			return false;
		if (this.Read(var buf, 8) != 8)
			throw @class + "." + @member + ": Corrupted header";

		if (fseek(hFile, offset + MODULO_SIZE, SEEK_SET))
			throw @class + "." + @member + ": Invalid garbage page";

		this.Write(buf);

		if (fseek(hFile, 14, SEEK_SET))
			throw @class + "." + @member + ": Invalid writing header";

		this.Write(pack("u64", offset));
		has_garbage = true;
	}

	protected PopGarbage(var offset) {
		if (fseek(hFile, 14, SEEK_SET))
			return false;
		if (this.Read(var buf, 8) != 8)
			throw @class + "." + @member + ": Corrupted header";

		offset = unpack("u64", buf)[0];
		if (!offset)
			return false;

		if (fseek(hFile, offset + MODULO_SIZE, SEEK_SET))
			return false;

		if (this.Read(buf, 8) != 8)
			return false;

		var next_link = unpack("u64", buf)[0];

		if (next_link == offset)
			next_link = 0;

		fseek(hFile, 14, SEEK_SET);
		this.Write(pack("u64", next_link));

		if (next_link)
			has_garbage = true;
		else
			has_garbage = false;

		//this.Seek(offset + MODULO_SIZE);
		//this.Write(pack("u64", 0));
		this.Seek(offset);
		this.Write(this._EmptyBlock());
		return true;
	}

	public GetGarbageBlocks() {
		var pos = 14;
		var[] res;

		if (fseek(hFile, pos, SEEK_SET))
			return res;

		if (this.Read(var buf, 8) != 8)
			throw @class + "." + @member + ": Corrupted header";

		var offset = unpack("u64", buf)[0];
		if (!offset)
			return res;

		pos = offset + MODULO_SIZE;
		res[length res]  = offset;

		while (pos > 0) {
			buf = "";
			if (fseek(hFile, pos, SEEK_SET))
				return res;

			if (this.Read(buf, 8) != 8)
				throw @class + "." + @member + ": Corrupted header";

			offset = unpack("u64", buf)[0];

			if (!offset)
				return res;

			if (fseek(hFile, offset + MODULO_SIZE, SEEK_SET))
				return res;

			var prec_pos = pos;
			pos = offset + MODULO_SIZE;
			if (prec_pos == pos)
				break;

			res[length res]  = offset;
		}

		return res;
	}

	protected _EmptyBlock() {
		var empty_block = "";

		var block_size = MODULO_SIZE + 8;
		for (var i = 0; i < block_size; i++)
			empty_block += "\x00";

		return empty_block;
	}

	protected _DeleteChain(offset) {
		if (offset <= 0)
			return false;
		var pages = 0;
		var next_block = offset;

		var empty_block = this._EmptyBlock();

		do {
			fseek(hFile, next_block + MODULO_SIZE, SEEK_SET);
			if (this.Read(var ref_block, 8) != 8)
				throw @class + "." + @member + ": Corrupted database or invalid read offset";

			if (fseek(hFile, next_block, SEEK_SET))
				throw @class + "." + @member + ": Corrupted database / seek error";
			pages++;
			// this.Write("\x00");
			this.Write(empty_block);

			this.PushGarbage(next_block);
			var prec_next_block = next_block;
			next_block = unpack("u64", ref_block)[0];
			if (prec_next_block == next_block)
				break;
			this.deleted_records++;
		} while (next_block);
		this.WriteInfo();
		return pages;
	}

	protected WriteBlock(var data, var id) {
		var pos = 0;
		var file_pos = 0;
		var ref_id = -1;
		var next_block = 0;

		if (id >= HEADER_SIZE) {
			//if (!this.Seek(id))
			if (fseek(hFile, id, SEEK_SET))
				throw @class + "." + @member + ": Seek error";
		} else
			id = -1;
		var end_block = "\x0\x0\x0\x0\x0\x0\x0\x0";
		var query_garbage = true;
		var at_end = false;
		if ((id < 0) && ((!has_garbage) || (length data > NO_FRAGMENTATION_SIZE))) {
			fseek(hFile, 0, SEEK_END);
			ref_id = ftell(hFile);
			if (Journal)
				Journal(data, this.name, ref_id, 1);

			if (length data > MODULO_SIZE) {
				for (var i = MODULO_SIZE; i < length data; i += MODULO_SIZE)
					data[i] = "\x00" + data[i];
			}
			var rem = length data % MODULO_SIZE;
			if (rem) {
				var padding = MODULO_SIZE - rem;
				data += pack(":"+padding);
			}
			i = 0;
			while (i < length data) {
				i += MODULO_SIZE;
				if (i < length data) {
					data[i] = pack("u64", ref_id + i + 8) + data[i];
				} else {
					data += end_block;
					break;
				}
				i += 8;
			}
			Write(data);
		} else {
			if ((Journal) && (id >= 0))
				Journal(data, this.name, id, 2);
			do {
				if (pos) {
					var buf = "\x00" + SubStr(data, pos, MODULO_SIZE - 1);
					if (length buf == 1)
						break;

					pos += length buf - 1;
				} else {
					buf = SubStr(data, pos, MODULO_SIZE);
					pos += length buf;
				}
				if (!buf)
					break;

				if (id < 0) {
					if ((query_garbage) && (this.PopGarbage(var offset))) {
						//this.Seek(offset);
						fseek(hFile, offset, SEEK_SET);
					} else {
						//this.Seek(0, SEEK_END);
						fseek(hFile, 0, SEEK_END);
						query_garbage = false;
						at_end = true;
					}
					if (ref_id < 0) {
						ref_id = ftell(hFile);
						if (Journal)
							Journal(data, this.name, ref_id, 2);
					}
				}

				if (length buf < MODULO_SIZE)
					buf = pack("s:" + MODULO_SIZE, buf);

				if (next_block) {
					//if (!this.Seek(next_block))
					if (fseek(hFile, next_block, SEEK_SET))
						throw @class + "." + @member + ": Seek error";
				} else
				if (file_pos) {
					var next_pos = ftell(hFile);
					//this.Seek(file_pos - 8);
					fseek(hFile, file_pos - 8, SEEK_SET);
					this.Write(pack("u64", next_pos));
					//this.Seek(next_pos);
					fseek(hFile, next_pos, SEEK_SET);
				}

				if (id < 0) {
					if ((at_end) && (pos < length data)) {
						file_pos = ftell(hFile);
						var full_buf = buf;
						var buf_size;
						while (pos < length data) {
							file_pos += MODULO_SIZE + 8;
							full_buf += pack("u64", file_pos);
							if (pos) {
								buf_size = MODULO_SIZE - 1;
								buf = "\x00" + SubStr(data, pos, buf_size);
							} else {
								buf_size = MODULO_SIZE;
								buf = SubStr(data, pos, buf_size);
							}
							if (length buf < MODULO_SIZE)
								full_buf += pack("s:" + MODULO_SIZE, buf);
							else
								full_buf += buf;
							pos += buf_size;
						}
						full_buf += end_block;
						// write all at once
						this.Write(full_buf);
						break;
					} else
						this.Write(buf + end_block);
				} else {
					this.Write(buf);

					var current = ftell(hFile);
					//this.Seek(0, SEEK_CUR);
					fseek(hFile, 0, SEEK_CUR);

					//if (this.Read(var buf2, 8) != 8)
					var read_size = fread(var buf2, 1, 8, hFile);
					if (read_size != 8) {
						// end of file ?
						if (read_size != 0)
							throw @class + "." + @member + ": Corrupted database / page link error in update";
						next_block = 0;
						this.Write(end_block);
					} else {
						next_block = unpack("u64", buf2)[0];
					}
					if (pos >= length data) {
						if (next_block)
							this._DeleteChain(next_block);
						//this.Seek(-8, SEEK_CUR);
						//fseek(hFile, -8, SEEK_CUR);
						fseek(hFile, current, SEEK_SET);
						this.Write(pack("u64", 0));
					} else
					if (!next_block) {
						if ((!query_garbage) || (!this.PopGarbage(next_block))) {
							//this.Seek(0, SEEK_END);
							fseek(hFile, 0, SEEK_END);
							next_block = ftell(hFile);
							query_garbage = false;
						}

						fseek(hFile, current, SEEK_SET);
						this.Write(pack("u64", next_block));
						fseek(hFile, 0, SEEK_CUR);
					}
				}
				file_pos = ftell(hFile);
			} while (true);
		}
		if (id < 0)
			id = ref_id;
		return true;
	}

	public _FastStoreMulti(arr, update_index = true, do_flush = true, virtual_store_field = null) {
		var[] ids;
		for (var i = 0; i < length arr; i++) {
			var obj = arr[i];
			if ((obj) && (IsSet(obj, '$')))
				throw "Cannot call _FastStoreMulti on already stored objects";
			if (virtual_store_field) {
				var id = obj[virtual_store_field];
				if (id > 0)
					ids[i] = id;
			} else {
				var data = BinarizeObject(obj);
				if (data) {
					var data_comp = "";
					if (Compress) {
						if (length data > MODULO_SIZE) {
							data_comp = "\x06" + compress(data);
							if (int32(length data_comp / MODULO_SIZE) >= int32(length data / MODULO_SIZE))
								data_comp = "";
						}
					}
					id = -1;
					if (data_comp)
						var res = this.WriteBlock(data_comp, id);
					else
						res = this.WriteBlock(data, id);

					ids[i] = id;
				}
			}
		}
		if (update_index) {
			for (i = 0; i < length arr; i++) {
				id = ids[i];
				if (id > 0)
					this.UpdateIndex(arr[i], id);
			}
		}
		if (do_flush)
			this.Flush();
	}

	BM25UpdateStart() {
		if (bm25) {
			var word_cache = ["." => 0];
			bm25.SetIndexLock(2);
			return [word_cache, new [], new []];
		}
		return null;
	}

	BM25UpdateEnd(word_cache) {
		if (bm25) {
			if ((word_cache) && (word_cache[0]))
				bm25.dumpcache(word_cache[0], word_cache[1], word_cache[2]);
			bm25.flush();
			bm25.SetIndexLock(false);
		}
	}

	protected _Store(var obj, update_index = true, id = -1, changed_keys = null, do_flush = true, change_oid = false, wordcache = null) {
		if (!hFile)
			throw "Invalid file descriptor or no open file";
		var data;
		var c;
		var not_oid_update = true;
		if (typeof obj == "array") {
			if (IsSet(obj, '$')) {
				var keys = GetKeys(obj);
				c = new [];
				for (var i = 0; i < length keys; i++) {
					var k = keys[i];
					if ((k) && (k != '$') && ((change_oid) || (k != '$oid')))
						c[k] = obj[k];
				}
				if (id < 0)
					id = value obj['$'];
			} else
				c = obj;
			if ((length c == 1) && (IsSet(c, '$oid')))
				not_oid_update = false;
		} else
			c = ToArray(obj);

		if ((changed_keys) && (length changed_keys == 1) && (IsSet(changed_keys, '$oid')))
			not_oid_update = false;
		var bm25_document = null;
		var graph = null;
		// bm25 index updated
		if ((bm25) && (c) && (not_oid_update) && ((update_index) || (changed_keys)))
			bm25_document = bm25.document(c, graph, BM25_GRAPH_LEVEL);
		data = BinarizeObject(c);
		if (data) {
			var data_comp = "";
			if (Compress) {
				if (length data > MODULO_SIZE) {
					data_comp = "\x06" + compress(data);
					if (int32(length data_comp / MODULO_SIZE) >= int32(length data / MODULO_SIZE))
						data_comp = "";
				}
			}
			var orig_id = id;
			if (data_comp)
				var res = this.WriteBlock(data_comp, id);
			else
				res = this.WriteBlock(data, id);

			if ((orig_id > 0) && (cache)) {
				if (IsSet(cache, "" + orig_id))
					cache = new [];
			}
			if (res > 0) {
				if (do_flush)
					this.Flush();
				if (update_index) {
					if (changed_keys == null)
						this.UpdateIndex(obj, id);
					else
						this.UpdateIndex(changed_keys, id, obj);
				}
				if (bm25_document) {
					if (wordcache) {
						try {
							bm25.update(bm25_document, id, changed_keys, graph, false, wordcache[0], wordcache[1], wordcache[2], orig_id > 0);
							if (length wordcache[0] >= BM25_MAX_WORDCACHE)
								bm25.dumpcache(wordcache[0], wordcache[1], wordcache[2]);
							if ((length wordcache[1] >= BM25_MAX_WORDCACHE) || (length wordcache[2] >= BM25_MAX_WORDCACHE))
								bm25.dumpcache(null, wordcache[1], wordcache[2]);
						} catch (var exc) {
							console.error(LOG_THIS, "Error in bm25.update $exc");
						}
					} else {
						bm25.SetIndexLock(2);
						try {
							bm25.update(bm25_document, id, changed_keys, graph, true, null, null, null, orig_id > 0);
						} catch (exc) {
							console.error(LOG_THIS, "Error in bm25.update $exc");
						}
						bm25.SetIndexLock(false);
						if (exc)
							throw exc;
						this.SyncBM25Info();
					}
				}
			}
			if (DebugPath) {
				if (orig_id > 0)
					WriteFile(data, DebugPath + "/${time()}-${microseconds()}-$id.update.bin");
				else
					WriteFile(data, DebugPath + "/${time()}-${microseconds()}-$id.bin");
			}
			return id;
		}
		return id;
	}

	UpdateIndex(obj, id, extra_obj = null) {
		var c;
		if (typeof obj == "array")
			c = obj;
		else
			c = ToArray(obj);
		var index_data = this.Indexes;

		if (index_data) {
			cache_id = id;
			cache_obj = c;
			for (var i = 0; i < length index_data; i++) {
				var key = index_data[i];
				if (key) {
					if (typeof key == "array") {
						// to do
						var string_val = "" + this.GetObjectFieldsAsString(c, key[1], var field_count, extra_obj);
						if ((field_count) && (!_Index.Put(id, key[0], string_val))) {
							console.error(LOG_THIS, "Error writing composite index");
							// to do
							// this._Delete(id, false, false);
						}
					} else
					if (IsSet(c, key)) {
						if (!_Index.Put(id, key, c[key])) {
							// to do
							// this._Delete(id, false, false);
							console.error(LOG_THIS, "Error writing index $key");
						}
					} else
					if (this.IsSet2(c, StrSplit(key, "."), var v)) {
						if (!_Index.Put(id, key, v)) {
							// to do
							// this._Delete(id, false, false);
							console.error(LOG_THIS, "Error writing index $key");
						}
					}
				}
			}
			cache_id = -1;
			cache_obj = null;
		}
	}

	Store(var obj, update_index = true, do_flush = true, change_oid = true) {
		return this._Store(obj, update_index, -1, null, do_flush, change_oid);
	}

	_StoreHint(var obj, update_index = true, do_flush = true, change_oid = true, changed_keys = null, wordcache = null, old_values = null, old_changed = null) {
		if ((update_index) && (old_values) && (old_changed)) {
			var id = obj['$'];
			if (id)
				update_index = this.RemoveIndexesIfChanged(old_changed, id, old_values);
		}
		return this._Store(obj, update_index, -1, changed_keys, do_flush, change_oid, wordcache);
	}

	SafeStore(var obj, update_index = true, do_flush = true, change_oid = true) {
		var do_unlock = false;
		var prev_lock = false;
		if (locked != 2) {
			if (locked) {
				prev_lock = true;
				this.ReleaseLock();
			}
			this.Lock(true);
			do_unlock = true;
		}
		try {
			var res = this.Store(obj, update_index, do_flush, change_oid);
		} catch (var exc) {
			this.Unlock(true);
			throw exc;
		}
		if (do_unlock) {
			this.Unlock(true);
			if (prev_lock)
				this.Lock();
		}
		return res;
	}

	IsUnique(obj, fields) {
		if ((!fields) || (!obj))
			return true;
		if (typeof fields == "string")
			fields = [ fields ];
		if (typeof fields != "array")
			return true;

		var obj_id = obj['$'];
		var fetch_count = 1;
		if (obj_id > 0)
			fetch_count = 2;
		var db_obj = null;
		var sum_of_fields = [ ];

		for (var i = 0; i < length fields; i++) {
			var field = fields[i];
			switch (typeof field) {
				case "string":
					if (field)
						sum_of_fields[field] = field;
					break;
				case "array":
					for (var j = 0; j < length field; j++) {
						var f2 = field[j];
						if (f2) 
							sum_of_fields[f2] = f2;
					}
					break;
			}
		}

		for (i = 0; i < length fields; i++) {
			field = fields[i];
			switch (typeof field) {
				case "string":
					if (IsSet(obj, field)) {
						var objects = this.Query([field => obj[field]], ['$', field], false, 0, fetch_count);
						if (objects) {
							for (j = 0; j < length objects; j++) {
								var o = objects[j];
								if ((o) && (o['$'] != obj_id))
									return false;
							}
						}
					}
					break;
				case "array":
					var query = [ ];
					var object_fields = ['$'];
					if ((obj_id > 0) && (!db_obj)) {
						db_obj = this.ById(obj_id, sum_of_fields);
						// invalid id
						if (!db_obj)
							return false;
					}
					for (j = 0; j < length field; j++) {
						f2 = field[j];
						if (f2) {
							if (IsSet(obj, f2)) {
								query[f2] = obj[f2];
								object_fields[length object_fields] = f2;
							} else
							if ((db_obj) && (IsSet(db_obj, f2))) {
								query[f2] = db_obj[f2];
								object_fields[length object_fields] = f2;
							}
						}
					}
					if (query) {
						objects = this.Query(query, object_fields, false, 0, fetch_count);
						if (objects) {
							for (j = 0; j < length objects; j++) {
								o = objects[j];
								if ((o) && (o['$'] != obj_id))
									return false;
							}
						}
					}
					break;
			}
		}
		return true;		
	}

	protected __Debug(id) {
		var key = "" + ftell(hFile);
		if (typeof __debug_block_info[key] == "array") {
			__debug_block_info[key] += id;
		} else
		if (__debug_block_info[key]) {
			__debug_block_info[key] = [__debug_block_info[key], id];
		} else
			__debug_block_info[key] = id;
	}

	GetOne(var id = null, strict = true, offset = -1) {
		if (offset < 0)
			id = ftell(hFile);
		else
			id = offset;
		var buf = "";
		var next_block;
		var prev_block;
		var compressed = false;
		var first_jump = 0;
		var blocks = 0;
		do {
			prev_block = next_block;
			if ((next_block > 0) && (next_block != ftell(hFile))) {
				//if (!this.Seek(next_block))
				if (!first_jump)
					first_jump = ftell(hFile);
				if (fseek(hFile, next_block, SEEK_SET)) {
					throw @class + "." + @member + ": Corrupted database / seek error";
				}
			}

			var size = fread(var buf_block, 1, MODULO_SIZE, hFile);
			//var size = this.Read(var buf_block, MODULO_SIZE);
			if (size != MODULO_SIZE) {
				if (buf)
					throw @class + "." + @member + ": Corrupted database or invalid read offset (page read)";
				return "";
			}
			blocks++;

			var flag = buf_block[0];
			if (!buf) {
				if (flag == "\x06")
					compressed = true;
				else
				if (flag != "\x05") {
					if (strict)
						return "";
					// deleted block
					next_block = -1;
					fseek(hFile, 8, SEEK_CUR);
					id = ftell(hFile);
					continue;
				}
			} else
			if (flag != "\x00") {
				throw @class + "." + @member + ": Invalid buffer for id $id ($next_block)";
				break;
			}
			if (Debug)
				this.__Debug(id);

			if (buf)
				buf += SubStr(buf_block, 1);
			else
				buf += buf_block;
			//if (this.Read(var ref_block, 8) != 8)
			if (fread(var ref_block, 1, 8, hFile) != 8)
				throw @class + "." + @member + ": Corrupted database or invalid read offset";
			next_block = unpack("u64", ref_block)[0];

			if ((next_block) && (this.InvalidId(next_block)))
				throw @class + "." + @member + ": Invalid offset for id $id ($next_block)";
			if ((next_block) && (next_block == prev_block))
				throw @class + "." + @member + ": Circular offset for id $id ($next_block) after $blocks read";
		} while (next_block);
		if (first_jump)
			fseek(hFile, first_jump, SEEK_SET);
		if ((compressed) && (buf))
			return uncompress(SubStr(buf, 1));
		return buf;
	}

	FetchByIndex(addr, start = 0, len = -1) {
		var[] result;
		for (var i = 0; i < length addr; i++) {
			var offset = addr[i] + HEADER_SIZE;
			//this.Seek(offset);
			fseek(hFile, offset, SEEK_SET);
			var obj = this.GetOne(var id, true, offset);
			if (obj) {
				var o = UnBinarizeObject(obj);
				if (o) {
					o['$'] = id;
					result[length result] = o;
				}
			}
		}
		return result;
	}

	InvalidId(id) {
		if (id < HEADER_SIZE)
			return true;
		id -= HEADER_SIZE;
		if (id % (MODULO_SIZE + 8))
			return true;
		return false;
	}

	InvalidOffset(rftell) {
		if (rftell <= 0)
			return false;

		if ((rftell - HEADER_SIZE - MODULO_SIZE) % (MODULO_SIZE + 8))
			return true;

		return false;
	}

	ValueToString(val) {
		switch (typeof val) {
			case "string":
				return val;
			case "numeric":
				return "" + val;
			case "array":
				var as_str = "";
				for (var i = 0; i < length val; i++) {
					if (i)
						as_str += ", ";
					as_str += this.ValueToString(val[i]);
				}
				return as_str;
		}
		return "";
	}

	FieldAsString(o, field) {
		if ((!o) || (!field))
			return "";

		if (typeof field == "array") {
			var key = "";
			for (var i = 0; i < length field; i ++) {
				if (i)
					key += ", ";
				key += this.FieldAsString(o, field[i]);
			}
			return key;
		}

		field = "" + field;
		
		if (!IsSet(o, field))
			return "";

		return this.ValueToString(o[field]);
	}

	protected GroupKey(obj, group_by, arr, return_placeholder = false, count = false) {
		for (var i = 0; i < length group_by; i++) {
			var group_key = this.FieldAsString(obj, group_by[i]);
			if ((count) && (i == length group_by - 1)) {
				arr[group_key] ++;
				break;
			}
			var new_arr = arr[group_key];

			if (!new_arr) {
				new_arr = new [];
				arr[group_key] = new_arr;
			}
			arr = new_arr;
		}
		if (return_placeholder)
			return arr;
		arr[length arr] = obj;
	}

	ById(id, fields = null, do_cache = false, cache = null, notify_one = null, notify_data = null, group_by = null) {
		if (typeof id == "array") {
			var[] id_flags;
			var res_array = new [];	
			for (var i = 0; i < length id; i++) {
				var _id = id[i];
				var _id_key = "" + _id;
				if ((_id) && (!InvalidId(_id)) && (!id_flags[_id_key])) {
					id_flags[_id_key]++;
					if (do_cache) {
						var cached_obj = cache[_id_key];
						if (cached_obj) {
							if (group_by)
								this.GroupKey(cached_obj, group_by, res_array);
							else
								res_array[length res_array] = cached_obj;
							// res_array[_id_key] = cached_obj;
							continue;
						}
					}

					if (fseek(hFile, _id, SEEK_SET))
						continue;
					var res = GetOne(null, true, _id);
					if (res) {
						if (fields)
							var o = UnBinarizeObject(res, 0, fields);
						else
							o = UnBinarizeObject(res);
						if (o != null) {
							o['$'] = _id;
							if (notify_one) {
								notify_one(o, notify_data);
							} else {
								if (group_by)
									this.GroupKey(o, group_by, res_array);
								else
									res_array[length res_array] = o;
							}
							if (do_cache)
								cache[_id_key] = o;
						}
					}
				}
			}
			return res_array;
		} else {
			if (InvalidId(id))
				return null;

			if (do_cache) {
				var cache_key = "" + id;
				cached_obj = cache[cache_key];
				if (cached_obj)
					return cached_obj;
			}

			//if (!this.Seek(id))
			if (fseek(hFile, id, SEEK_SET))
				return null;
			res = GetOne(null, true, id);
			if (res) {
				if (fields)
					o = UnBinarizeObject(res, 0, fields);
				else
					o = UnBinarizeObject(res);
				if (o) {
					o['$'] = id;

					if (do_cache)
						cache[cache_key] = o;
				}
				return o;
			}
			return null;
		}
	}

	RemoveIndexes(o, id) {
		if (o) {
			var indexes = Indexes;
			var Unique = _Index.Unique;
			for (var i = 0; i < length indexes; i++) {
				var index = indexes[i];
				if (index) { 
					if (typeof index == "array") {
						var string_val = this.GetObjectFieldsAsString(o, index[1], var field_count);
						if (field_count) {
							if (Unique)
								_Index.Remove(string_val, id, index[0]);
							else
								_Index.Remove(id, string_val, index[0]);
						}
					} else
					if (IsSet(o, index)) {
						var v = o[index];
						if (Unique)
							_Index.Remove(v, id, index);
						else
							_Index.Remove(id, v, index);
					}
				}
			}
		}
	}

	RemoveIndexesIfChanged(o, id, old = null) {
		var changed = 0;
		if (o) {
			var indexes = Indexes;
			var Unique = _Index.Unique;
			for (var i = 0; i < length indexes; i++) {
				var index = indexes[i];
				if (index) {
					if (typeof index == "array") {
						var string_val = this.GetObjectFieldsAsString(o, index[1], var field_count, old);
						if (field_count) {
							if (Unique)
								_Index.Remove(string_val, id, index[0]);
							else
								_Index.Remove(id, string_val, index[0]);
							changed++;
						}
					} else
					if (IsSet(o, index)) {
						var v = o[index];
						if (Unique)
							_Index.Remove(v, id, index);
						else
							_Index.Remove(id, v, index);
						changed++;
					}
				}
			}
		}
		return changed;
	}

	RemoveIndexesByObjects(arr) {
		for (var i = 0; i < length arr; i++) {
			var obj = arr[i];
			if ((obj) && (IsSet(obj, '$')))
				this.RemoveIndexes(obj, obj['$']);
		}
	}

	protected MinFields() {
		var[] fields;
		for (var i = 0; i < length Indexes; i++) {
			var index = Indexes[i];
			if (index) {
				switch (typeof index) {
					case "string":
						fields[index] = index;
						break;
					case "array":
						index = index[1];
						if (typeof index == "array") {
							for (var j = 0; j < length index; j++) {
								var index_2 = index[j];	
								if ((index_2) && (typeof index_2 == "string"))
									fields[index_2] = index_2;
							}
						}
						break;
				}
			}
		}
		return fields;
	}

	protected _Delete(id, strict = false, update_index = true) {
		//if (!this.Seek(id))
		if (InvalidId(id))
			return false;

		if (id <= 0)
			return false;

		if (fseek(hFile, id, SEEK_SET))
			return false;


		var obj = GetOne(null, true, id);
		if (!obj)
			return false;

		try {
			if ((Indexes) && (update_index))
				this.RemoveIndexes(UnBinarizeObject(obj, 0, MinIndexFields), id);
		} catch (var exc) {
			console.error(LOG_THIS, "Exception: $exc");
			return false;
		}

		if (Journal)
			Journal(obj, this.name, id, 3);

		this._DeleteChain(id);
		if (cache) {
			if (IsSet(cache, "" + id))
				cache = new [];
		}
		return true;
	}

	Delete(id, update_index = true) {
		var strict = false;
		if (typeof id == "array") {
			if (IsSet(id, '$')) {
				return this._Delete(id['$'], strict, update_index);
			} else {
				var cnt = 0;
				for (var i = 0; i < length id; i++) {
					var _id = id[i];
					if (_id) {
						if ((typeof _id == "array") && (IsSet(_id, '$'))) {
							cnt += this._Delete(_id['$'], strict, update_index);
						} else
							cnt += this._Delete(_id, strict, update_index);
					}
				}
				return cnt;
			}
		} else
			return this._Delete(id, strict, update_index);
	}

	protected SetKey(o, key_path, var v, var first_key, var prec_value, add_key = false) {
		var key_arr = StrSplit(key_path, ".");
		var last = length key_arr - 1;
		first_key = "";

		for (var i = 0; i < length key_arr; i++) {
			var key = key_arr[i];
			if (key) {
				if (i != last) {
					if (!IsSet(o, key))
						o[key] = new [];

					o = o[key];
					var type = typeof o;
					if ((type != "array") && (type != "class"))
						return false;
				} else {
					if ((!IsSet(o, key)) || (typeof o[key] != typeof v) || (o[key] != v) || (add_key)) {
						first_key = key_arr[0];
						prec_value = o[key];
						if (add_key) {
							if (typeof prec_value != "array")
								o[key] = [prec_value];

							o[key][length o[key]] = v;
						} else
							o[key] = v;
						return true;
					}
					return false;
				}
			} else
				return false;
		}
		return false;
	}

	Update(o, var id, update_index = true, var oid = null, getoid = false, getfull_obj = false, var full_obj = null) {
		// new_bin = null;
		oid = null;
		full_obj = null;
		//if (!this.Seek(id))
		if (fseek(hFile, id, SEEK_SET))
			return false;
		var keys = GetKeys(o);
		if (keys) {
			// nothing to update
			if ((length keys == 1) && (keys[0] == '$'))
				return true;
			var res = GetOne(null, true, id);
			if (res) {
				var old = UnBinarizeObject(res);
				if (old) {
					var[] new_values;
					var[] changed;
					for (var i = 0; i < length keys; i++) {
						var k = keys[i];
						if ((k) && (k != '$')) {
							// add to array
							var val = o[k];
							if (k[0] == "+") {
								k++;
								if (SetKey(old, k, val, var first_key, var prec_value, true)) {
									changed[k] = prec_value;
									new_values[k] = val;
								}
							} else {
								if (SetKey(old, k, val, first_key, prec_value)) {
									changed[k] = prec_value;
									new_values[/*first_key*/k] = val;
								}
							}
						}
					}
					if (getoid)
						oid = old['$oid'];
					// nothing changed
					if (!changed)
						return true;
					if (update_index)
						update_index = this.RemoveIndexesIfChanged(changed, id, old);

					//if (!this.Seek(id))
					if (fseek(hFile, id, SEEK_SET))
						return false;
					this._Store(old, update_index, id, new_values);
					// if (!update_index)
					// 	new_bin  = old;
					if (getfull_obj)
						full_obj = old;
					return true;
				}
			}
		}
		return false;
	}

	Scan(callback, var userdata = null) {
		//this.Seek(HEADER_SIZE);
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		while (var obj = this.GetOne(var id, false)) {
			var o = UnBinarizeObject(obj);
			if (o) {
				o['$'] = id;
				if (callback(o, id, userdata))
					break;
			}
		}
	}

	RebuildIndex(string field) {
		_Index.ResetCache();
		_Index.DropIndex(field);
		var prec_db = _Index.Database;
		_Index.Database = field;
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		Indexes[field] = field;
		this.SyncIndexes();
		_Index.CacheRoot = true;
		_Index.Locked = 2;
		var exc;
		try {
			this.Scan(function(c, id, field) {
				cache_id = id;
				cache_obj = c;
				var pos = ftell(hFile);
				if (this.IsSet2(c, StrSplit(field, "."), var v))
				//if (IsSet(c, field))
					_Index.Put(id, field, /*c[field]*/v);

				fseek(hFile, pos, SEEK_SET);
			}, field);
		} catch (exc) {	
			console.error(LOG_THIS, exc);
		}
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		_Index.Locked = false;
		_Index.CacheRoot = false;
		_Index.Database = prec_db;
		cache = new [];
		cache_id = -1;
		cache_obj = null;
		if (exc)
			throw exc;
	}

	RebuildBM25() {
		if (!bm25)
			return;
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		var word_cache = ["." => 0];
		var cache1 = new [];
		var cache2 = new [];
		bm25.SetIndexLock(2);
		this.Scan(function(c, id, var word_cache) {
			cache_id = id;
			cache_obj = c;

			bm25.update(bm25.document(c, var graph, BM25_GRAPH_LEVEL), id, null, graph, false, word_cache[0], word_cache[1], word_cache[2], false, true);
			if (length word_cache[0] >= BM25_MAX_WORDCACHE)
				bm25.dumpcache(word_cache[0], word_cache[1], word_cache[2]);
			if ((length word_cache[1] >= BM25_MAX_WORDCACHE) || (length word_cache[2] >= BM25_MAX_WORDCACHE))
				bm25.dumpcache(null, word_cache[1], word_cache[2]);
		}, [word_cache, cache1, cache2]);
		bm25.dumpcache(word_cache, cache1, cache2);
		bm25.SetIndexLock(false);
		bm25.flush();
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		cache = new [];
		cache_id = -1;
		cache_obj = null;

		//bm25.notifybulk();
	}

	GetObjectFields(obj, fields) {
		var[] indexed_object;

		for (var i = 0; i < length fields; i++) {
			var field = fields[i];
			if ((field) && (this.IsSet2(obj, StrSplit(field, "."), var v)))
				indexed_object[field] = v;//obj[field];
		}
		return indexed_object;
	}

	GetObjectFieldsAsString(obj, fields, var field_count = null, extra_obj = null) {
		var indexed_object = "";
		field_count = 0;
		for (var i = 0; i < length fields; i++) {
			var field = fields[i];
			if (field) {
				if (IsSet(obj, field)) {
					field_count++;
					indexed_object += obj[field];
				} else
				if (this.IsSet2(obj, StrSplit(field, "."), var v)) {
					field_count++;
					indexed_object += v;
				} else
				if (extra_obj) {
					if (IsSet(extra_obj, field)) {
						field_count++;
						indexed_object += extra_obj[field];
					} else
					if (this.IsSet2(extra_obj, StrSplit(field, "."), v)) {
						field_count++;
						indexed_object += v;
					}
				}
				indexed_object += COMPOSITE_FIELD_SEPARATOR;
			}
		}
		return indexed_object;
	}

	RebuildCompositeIndex(array fields) {
		var index_name = this.IndexName(fields);
		if (!index_name)
			return;
		var prec_db = _Index.Database;
		_Index.Database = index_name;
		_Index.CacheRoot = true;
		_Index.Locked = 2;
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		Indexes[index_name] = fields;
		this.SyncIndexes();
		var exc;
		try {
			this.Scan(function(c, id, userdata) {
				cache_id = id;
				cache_obj = c;
				var fields = userdata[0];
				var index_name = userdata[1];
				var pos = ftell(hFile);
				for (var i = 0; i < length fields; i++) {
					var field = fields[i];
					if ((field) && (this.IsSet2(c, StrSplit(field, "."), null))) {
						_Index.Put(id, index_name, GetObjectFieldsAsString(c, fields));
						break;
					}
				}
				fseek(hFile, pos, SEEK_SET);
			}, [fields, index_name]);
		} catch (exc) {
			console.error(LOG_THIS, exc);
		}
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		_Index.Locked = false;
		_Index.CacheRoot = false;
		_Index.Database = prec_db;
		cache = new [];
		cache_id = -1;
		cache_obj = null;
		if (exc)
			throw exc;
	}

	EnsureIndex(field) {
		this.RefreshIndexes();
		if (typeof field == "array")
			return this.EnsureCompositeIndex(field);
		else
		if (typeof field != "string")
			return false;

		for (var i = 0; i < length Indexes; i++) {
			var index = Indexes[i];
			if ((typeof index == "string") && (field == index))
				return true;
		}
		this.RebuildIndex(field);
		this.FlushDB();
		Indexes[field] = field;
		WriteFile(BinarizeObject(Indexes), name + ".idxn");
		this.SyncIndexes();
		cache = new [];
		cache_id = -1;
		cache_obj = null;
		return false;
	}

	InvalidateAndRebuildIndexes() {
		this.RefreshIndexes();
		for (var i = 0; i < length Indexes; i++) {
			var index = Indexes[i];
			if (index) {
				if (typeof index == "array") {
					var fields = index[1];
					if (typeof fields == "array")
						this.RebuildCompositeIndex(fields);
					else
						this.RebuildIndex(fields);
				} else
				if (typeof index == "string")
						this.RebuildIndex(index);
			}
		}
	}

	EnsureFullTextIndex(fields, lang = "en") {
		var bm25_name = this.name + ".bm25";
		if (!bm25)
			this.RefreshIndexes();

		if (bm25) {
			if (bm25.samefields(fields))
				return true;
			_unlink(bm25_name);
		}
		if (!fields)
			fields = new [];
		this.CreateFullText(bm25_name, fields, lang);
		// sync twice (to ensure no double-indexing)
		this.SyncBM25Info();
		this.RebuildBM25();
		// second
		this.SyncBM25Info();
		this.FlushDB();
		cache = new [];
		cache_id = -1;
		cache_obj = null;

		return false;
	}

	SyncBM25Info() {
		if (bm25) {
			var bm25_name = this.name + ".bm25";
			var bin_data;
			if (classof bm25 == "BM25Index")
				bin_data = ["fields" => bm25.fields, "lang" => bm25.lang, "dl" => bm25.dl, "N" => bm25.N];
			else
				bin_data = ["fields" => bm25.fields, "lang" => bm25.lang, "dl" => 0, "N" => 0];
			WriteFile(BinarizeObject(bin_data), bm25_name);
		}
	}

	IndexName(fields) {
		if (typeof fields == "array") {
			var index_name = "";
			var[] fields2;
			for (var i = 0; i < length fields; i++) {
				var field = fields[i];
				if (field)
					fields2[field] = field;
			}
			fields = KeySorted(fields2);
			for (i = 0; i < length fields; i++) {
				field = fields[i];
				if (field) {
					if (index_name)
						index_name += "&";
					index_name += field;
				}
			}
			if (index_name)
				index_name = "composite." + index_name;
			return index_name;
		}
		return fields;
	}
	
	EnsureCompositeIndex(array fields) {
		if (!fields)
			return false;
		this.RefreshIndexes();
		var index_name = this.IndexName(fields);
		if (!index_name)
			return false;

		for (var i = 0; i < length Indexes; i++) {
			var index = Indexes[i];
			if ((index) && (typeof index == "array") && (index_name == index[0]))
				return true;
		}
		this.RebuildCompositeIndex(fields);
		this.FlushDB();
		Indexes[index_name] = [index_name, fields];
		WriteFile(BinarizeObject(Indexes), name + ".idxn");
		this.SyncIndexes();
		return false;
	}

	EnsureIndexes(array fields) {
		this.RefreshIndexes();
		var count = 0;
		for (var i = 0; i < length fields; i++) {
			var field = fields[i];
			if (field) {
				if (!EnsureIndex(field))
					count++;
			}
		}
		return count;
	}

	static GetMin(var arr) {
		var[] res;
		var min = -1;
		var min_pos = -1;
		var keys = GetKeys(arr);
		for (var i = 0; i < length arr; i++) {
			var v = arr[i];	
			if ((v < min) || (min == -1)) {
				min = v;
				min_pos = i;
			}
		}
		if (min_pos >= 0) {
			for (i = 0; i < length arr; i++) {
				if (i != min_pos)
					res[keys[i]] = arr[i];
			}
			arr = res;
			return [keys[min_pos] => min];
		}
		return null;
	}

	protected IsSet2(o, key_arr, var v) {
		var last = length key_arr - 1;
		for (var i = 0; i < length key_arr; i++) {
			var key = key_arr[i];
			if ((key) && (IsSet(o, key))) {
				o = o[key];
				if (i != last) {
					var type = typeof o;
					if ((type != "array") && (type != "class"))
						return false;
				} else
					v = o;
			} else
				return false;
		}
		return true;
	}

	protected ScanFilter(obj_key, obj_val, keys_data, prec_result, cached_o = null) {
		var keys = keys_data[0];
		var vals = keys_data[1];
		var cache = keys_data[7];
		if (!cache) {
			cache = new [];
			keys_data[7] = cache;
		}
		var o = cached_o;

		if (o == null)
			o = this.ById(obj_val, keys, false, null);

		if (o) {
			var add_item = true;
			for (var j = 0; j < length keys; j++) {
				var key = keys[j];
				var key_arr = cache[j];
				if ((key) && (!key_arr)) {
					key_arr = StrSplit(key, ".");
					cache[j] = key_arr;
				}
				if ((key) && (IsSet2(o, key_arr, var v))) {
				//if ((key) && (IsSet(o, key))) {
					add_item = false;
					var arr = vals[key];
					var typeof_arr = typeof arr;
					//var v = o[key];

					if (typeof_arr == "array") {
						for (var i = 0; i < length arr; i++) {
							if (arr[i] == v) {
								add_item = true;
								break;
							}
						}
						if (!add_item)
							return false;
					} else
					if (typeof_arr == "class") {
						if (arr.CompareSimple(v, key)) {
							add_item = true;
						} else
							return false;
					} else
					if (v != arr) {
						var not_found = true;
						if (typeof v != typeof_arr) {
							if (typeof v == "array") {
								for (var k = 0; k < length v; k++) {
									if (v[0] == arr) {
										add_item = true;
										not_found = false;
										break;
									}
								}
							}
						}
						if (not_found)
							return false;
					} else
						add_item = true;
				} else
					return false;
			}
			return add_item;
		}
		return false;
	}

	protected CompositeIndexQuery(array keys, array q) {
		if ((!keys) || (!q))
			return false;
		for (var i = 0; i < length keys; i++) {
			var index_key = keys[i];
			if (!IsSet(q, index_key))
				return false;
			// do not use index for OR values
			if (typeof q[index_key] == "array")
				return false;
		}
		return true;
	}

	protected CompositeFilterKeys(array index_keys, array keys) {
		var[] new_keys;
		var[] ignore;
		for (var i = 0; i < length index_keys; i++) {
			var key = index_keys[i];
			if (key)
				ignore[key] = true;
		}
		for (i = 0; i < length keys; i++) {
			key = keys[i];
			if ((key) && (!ignore[key]))
				new_keys[length new_keys] = key;
		}
		return new_keys;
	}

	Count(q = null) {
		return this.Query(['#' => q])[0];
	}

	Search(string q, fields = null, start = 0, len = 0) {
		var bm = this.bm25;
		if (!bm)
			this.RefreshIndexes();

		if (!bm)
			return [ ];

		var qdoc = BM25::query(q, bm.lang);
		if (!qdoc)
			return [ ];
		if (this.bm25) {
			var ids = this.bm25.search(q, start, len);
			if (ids)
				return this.ById(ids, fields);
		} else {
			var documents = new [];
			this.Scan(function(o, id, userdata) {
				var ids = userdata[0];
				var bm = userdata[1];
				var q = userdata[2];

				var doc = bm.document(o);
				if ((doc) && (BM25::contains(doc, q))) {
					doc['$'] = id;
					ids[length ids] = doc;
				}
			}, [documents, bm, qdoc]);
			var[] weights;
			var documents_qi = BM25::count(qdoc, documents, var avgdl);
			for (var i = 0; i < length documents; i++) {
				var doc = documents[i];
				if (doc) {
					var score = BM25::score(qdoc, documents_qi, documents[i], length documents, avgdl);
					if (score > 0) {
						var id = doc['$'];
						var key = "" + (1000000 - floor(score * 1000));
						var prec = weights[key];
						if (prec)
							key = key + "." + i;
						weights[key] = id;
					}
				}
			}
			ids = KeySorted(weights);
			if ((len) || (start)) {
				if (len <= 0)
					len = length ids;

				if (len - start > length ids)
					len = length ids - start;

				var new_ids = new [];
				for (i = start; i < len; i++) {
					id = ids[i];
					if (id)
						new_ids[length new_ids] = id;
				}
				ids = new_ids;
			}
			return this.ById(ids, fields);
		}
		return [ ];
	}

	Explain(q = null) {
		if (q == null)
			q = new [];
		var keys = GetKeys(q);
		var index_to_use = new [];
		var indexed_query = new [];
		var indexes = Indexes;
		var target_index;
		for (var i = 0; i < length indexes; i++) {
			var index = indexes[i];
			if (index) {
				if (typeof index == "array") {
					if (CompositeIndexQuery(index[1], q)) {
						var index_name = index[0];
						if (index_name) {
							_Index.Database = index_name;
							indexed_query[index_name] = this.GetObjectFieldsAsString(q, index[1]);
							keys = CompositeFilterKeys(index[1], keys);
							index_to_use[index_name] = keys;
						}
					}
				} else
				if (IsSet(q, index)) {
					_Index.Database = index;
					index_to_use[index] = index;
				}
			}
		}
		var non_indexed_query = [ ];
		if (index_to_use) {
			for (i = 0; i < length keys; i++) {
				var key = keys[i];
				if ((indexed_query) || (!IsSet(index_to_use, key))) {
					non_indexed_query[key] = q[key];
				} else {
					target_index = key;
					indexed_query[key] = q[key];
				}
			}
		}

		var[] explain;
		explain["collection"] = this.name;
		if (IsSet(q, '$')) {
			explain["type"] = "direct access";
			var vals = q['$'];
			if ((typeof vals == "array") && (length vals > 1))
				explain["complexity"] = "${length vals} * O(1)";
			else
				explain["complexity"] = "O(1)";
			explain["note"] = "This query is ideal";
		} else
		if (!target_index) {
			explain["type"] = "full table scan";
			explain["complexity"] = "O(n)";
			if (q)
				explain["note"] = "Consider creating an index";
			else
				explain["note"] = "Consider using an index, by adding a filter";
		} else {
			if (length q > 1) {
				explain["type"] = "index + scan";
				explain["complexity"] = "[O(log(n)) .. O(n)]";
				explain["note"] = "This query is suboptimal. Consider creating a composite index, only if this query is executed frequently.";
			} else {
				explain["type"] = "index";
				explain["complexity"] = "O(log(n))";
				explain["note"] = "This query is optimal";
			}
			explain["index"] = target_index;
			if (index_to_use) {
				explain["method"] = "first available index";
				explain["available"] = index_to_use;
			} else
				explain["method"] = "single index";
		}
		if (indexed_query)
			explain["using index"] = indexed_query;
		if (non_indexed_query)
			explain["not using index"] = non_indexed_query;
		explain["keys"] = keys;
		return explain;
	}

	Query(q = null, fields = null, descending = false, start = 0, len = 0, notify_one = null, notify_data = null, group_by = null) {
		// if (time() - index_refresh_time > INDEX_REFRESH_TIMEOUT)
		//	this.RefreshIndexes();
		var count;
		if ((q) && (IsSet(q, '#'))) {
			q = q['#'];
			count = true;
			// ignore notify for count queries
			notify_one = null;
		}
		if (q == null)
			q = new [];

		var indexes = Indexes;
		var keys = GetKeys(q);
		var index_to_use = new [];
		var index_counts = new [];
		var indexed_query = [ ];
		var result2;
		for (var i = 0; i < length indexes; i++) {
			var index = indexes[i];
			if (index) {
				if (typeof index == "array") {
					if (CompositeIndexQuery(index[1], q)) {
						var index_name = index[0];
						if (index_name) {
							_Index.Database = index_name;
							index_to_use[index_name] = index_name;
							index_counts[index_name] = length indexes - i;
							indexed_query[index_name] = this.GetObjectFieldsAsString(q, index[1]);
							// ensure index is created!
							_Index.GetIndex(index_name, index[1]); 
							keys = CompositeFilterKeys(index[1], keys);
						}
					}
				} else
				if (IsSet(q, index)) {
					_Index.Database = index;
					index_to_use[index] = index;
					index_counts[index] = length indexes - i;
				}
			}
		}
		var result = new [];
		var filter_ids;
		var filter_by_id = false;
		if ((group_by) && (typeof group_by != "array"))
			group_by = [ group_by ];

		if (IsSet(q/*keys*/, '$')) {
			filter_by_id = true;
			var ref_filter_ids = q['$'];//keys['$'];
			var has_rowids = true;
			if (typeof ref_filter_ids == "string") {
				ref_filter_ids = [value ref_filter_ids];
			} else
			if (typeof ref_filter_ids != "array") {
				ref_filter_ids = [ref_filter_ids];
			} else {
				var ref_keys = GetKeys(ref_filter_ids);
				if ((ref_keys) && (ref_keys[0]))
					has_rowids = false;
			}
			if (has_rowids) {
				filter_ids = new [];
				for (i = 0; i < length ref_filter_ids; i++) {
					var fi = ref_filter_ids[i];
					if (fi)
						filter_ids["" + fi] = fi;
				}
				if (length keys == 1) {
					if (count)
						return [length filter_ids];
					return this.ById(filter_ids, null, false, null, notify_one, notify_data, group_by);
				}
			}
		}
		if (index_to_use) {
			var non_indexed_query = [ ];
			for (i = 0; i < length keys; i++) {
				var key = keys[i];
				if ((indexed_query) || (!IsSet(index_to_use, key)))
					non_indexed_query[key] = q[key];
				else
					indexed_query[key] = q[key];
			}
			var ids = _Index._FetchMultiple(indexed_query, non_indexed_query, this.ScanFilter, this, descending, start, len);
			if (ids) {
				if ((count) && (!group_by))
					return [length ids];

				result = this.ById(ids, fields, false, null, notify_one, notify_data, group_by);
				if ((count) && (group_by)) {
					for (i = 0; i < length result; i++)
						result[i] = length result[i];
				}
			}
		} else {
			if (q) {
				var Unique = false;
				if (this._Index)
					Unique = this._Index.Unique;
				for (var k = 0; k < length keys; k++) {
					var ni_key = keys[k];
					var ni_q = q[ni_key];
					if (typeof ni_q == "array") {
						var key_list = GetKeys(ni_q);
						if ((key_list) && (key_list[0])) {
							var ni_qp = new TinQueryParser(ni_q);
							ni_qp.reversed = Unique;
							q[ni_key] = ni_qp;
						}
					}
				}
			}
			var userdata = [keys, q, result, start, len, fields, count, null, notify_one, notify_data, group_by]; // null is cache //[result, q, GetKeys(q), start, len, 0];
			this.Scan(function(o, id, var userdata) {
				var result = userdata[2];
				var start = userdata[3];
				var len = userdata[4];
				var fields = userdata[5];
				var count = userdata[6];
				var notify_one = userdata[8];
				var group_by = userdata[10];

				if (start > 0) {
					start--;
					userdata[3] = start;
					return false;
				}
				if (userdata[0]) {
					if (!this.ScanFilter(-1, -1, userdata, 0, o))
						return false;
				}
				if ((group_by) && (!count))
					result = this.GroupKey(o, group_by, result, true);

				if (fields) {
					var new_o = [ ];
					for (var i = 0; i < length fields; i++) {
						var field = fields[i];
						if ((field) && (IsSet(o, field)))
							new_o[field] = o[field];
					}
					o = new_o;
				}
				if (count) {
					if (group_by)
						this.GroupKey(o, group_by, result, true, true);
					else
						result[0]++;
					if (len) {
						var e_count;
						if (group_by) {
							userdata[12] ++;
							e_count = userdata[12];
						} else
							e_count = result[0];
						if (e_count >= len)
							return true;
					}
				} else {
					if (notify_one) {
						notify_one(o, userdata[9]);
						if (len > 0) {
							userdata[12]++;
							// stop scanning ?
							if ((len > 0) && (userdata[12] >= len))
								return true;
						}
					} else {
						result[length result] = o;
						// stop scanning ?
						if ((len > 0) && (length result >= len))
							return true;
					}
				}
			}, userdata);
			if ((result) && (descending)) {
				result2 = new [];
				var idx = length result - 1;
				for (i = 0; i < length result; i++)
					result2[idx--] = result[i];
				result = result2;
			}
		}
		return result;
	}

	SafeQuery(q = null, fields = null, descending = false, start = 0, len = 0) {
		try {
			this.Lock();
			var res = this.Query(q, fields, descending, start, len);
		} catch (var exc) {
			this.Unlock();
			throw exc;
		}
		this.Unlock();
		return res;
	}

	FlushDB(flush_index = true) {
		if (hFile) {
			try {
				this.Flush();
				this.DataSync();
			} catch (var exc) {
				console.error(LOG_THIS, "FlushDB error: $exc");
			}
		}
		if (flush_index) {
			if (_Index)
				_Index.Flush();
			if (bm25)
				bm25.flush();
		}
	}

	Drop() {
		if (hFile) {
			fclose(hFile);
			delete hFile;
			_Index.ResetCache();
			_unlink(this.name);
			_unlink(this.name + ".idxn");
			this.DropBM25Index();
			this.DropIndexes();
			cache = new [];
		}	
	}

	Reset() {
		if (_Index) {
			this.ResetCache();
			_Index.ResetCache();
			_Index = null;
		}
	}

	finalize() {
		this.Reset();
		File::finalize();
	}
}

class FixedStorage extends BinFile {
	var[] structure;
	protected var[] keys;
	protected var description = "";
	protected var record_size;

	FixedStorage(filename, mode="r+b", use_index = true) {
		super(filename, mode, use_index);
	}

	override Open;
	Open(with_lock = false) {
		var file_size = filesize(this.name);
		var valid_file = false;
		if (file_size < HEADER_SIZE) {
			WriteFile("", this.name);
			file_size = 0;
		} else
			valid_file = true;

		if (File::Open()) {
			setvbuf(hFile, 0);
			if (valid_file) {
				if (with_lock)
					this.Lock();
				fread(var buf, 1, 6, hFile);
				if ((length buf != 6) || (buf != "CFDB10")) {
					this.Close();
					if (with_lock)
						this.ReleaseLock();
					var err = _errno();
					if (err == 13)
						throw "Datafile is locked";
					throw "Invalid or corrupted data file (errno ${err})";
				}
				var structure_ok = this.ReadStructure();
				if (with_lock)
					this.ReleaseLock();
				if (!structure_ok)
					throw "Invalid or corrupted data file (no structure info)";
			} else {
				this.WriteHeader();
				this.WriteStructure();
			}
			return true;
		}
		return false;
	}

	protected UpdateStructure() {
		if (this.structure) {
			this.keys = GetKeys(this.structure);
			this.description = "";
			this.record_size = 0;
			for (var i = 0; i < length this.keys; i++) {
				var k = this.keys[i];
				if (k) {
					var type = this.structure[k];
					this.description += type;
					switch (type[0]) {
						case "i":
						case "I":
						case "u":
						case "U":
							this.record_size += (value SubStr(type, 1)) / 8;
							break;
						case "f":
							this.record_size += 4;
							break;
						case "d":
							this.record_size += 8;
							break;
						case "s":
						case ":":
							this.record_size += value SubStr(type, 1);
							break;
						default:
							throw "Unsupported type specifier: $type";
					}
				}
			}
		}
	}

	public SetStructure(array structure) {
		this.structure = structure;
		if (hFile)
			this.WriteStructure();
		this.UpdateStructure();
	}

	override WriteHeader;
	protected WriteHeader() {
		var header = pack("su64u64u32:" + HEADER_SIZE, "CFDB10", 0, 0, MODULO_SIZE);
		fseek(hFile, 0, SEEK_SET);
		this.Write(header);
	}

	protected WriteStructure() {
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		this.Write(pack("s:" + MAX_STRUCTURE_SIZE, BinarizeObject(structure)));
	}

	protected ReadStructure() {
		fseek(hFile, HEADER_SIZE, SEEK_SET);
		fread(var buf, 1, MAX_STRUCTURE_SIZE, hFile);
		if ((length buf != MAX_STRUCTURE_SIZE) && (buf))
			return false;
		if (buf) {
			this.structure = UnBinarizeObject(buf);
			this.UpdateStructure();
		}
		return true;
	}

	protected variablepack(structure, variables) {
		switch (length variables) {
			case 0:
				return pack(structure);
			case 1:
				return pack(structure, variables[0]);
			case 2:
				return pack(structure, variables[0], variables[1]);
			case 3:
				return pack(structure, variables[0], variables[1], variables[2]);
			case 4:
				return pack(structure, variables[0], variables[1], variables[2], variables[3]);
			case 5:
				return pack(structure, variables[0], variables[1], variables[2], variables[3], variables[4]);
			case 6:
				return pack(structure, variables[0], variables[1], variables[2], variables[3], variables[4], variables[5]);
			case 7:
				return pack(structure, variables[0], variables[1], variables[2], variables[3], variables[4], variables[5], variables[6]);
			case 8:
				return pack(structure, variables[0], variables[1], variables[2], variables[3], variables[4], variables[5], variables[6], variables[7]);
			case 9:
				return pack(structure, variables[0], variables[1], variables[2], variables[3], variables[4], variables[5], variables[6], variables[7], variables[8]);
			case 10:
				return pack(structure, variables[0], variables[1], variables[2], variables[3], variables[4], variables[5], variables[6], variables[7], variables[8], variables[9]);
			case 11:
				return pack(structure, variables[0], variables[1], variables[2], variables[3], variables[4], variables[5], variables[6], variables[7], variables[8], variables[9], variables[10]);
			case 12:
				return pack(structure, variables[0], variables[1], variables[2], variables[3], variables[4], variables[5], variables[6], variables[7], variables[8], variables[9], variables[10], variables[11]);
			case 13:
				return pack(structure, variables[0], variables[1], variables[2], variables[3], variables[4], variables[5], variables[6], variables[7], variables[8], variables[9], variables[10], variables[11], variables[12]);
			case 14:
				return pack(structure, variables[0], variables[1], variables[2], variables[3], variables[4], variables[5], variables[6], variables[7], variables[8], variables[9], variables[10], variables[11], variables[12], variables[13]);
			case 15:
				return pack(structure, variables[0], variables[1], variables[2], variables[3], variables[4], variables[5], variables[6], variables[7], variables[8], variables[9], variables[10], variables[11], variables[12], variables[13], variables[14]);
			case 16:
				return pack(structure, variables[0], variables[1], variables[2], variables[3], variables[4], variables[5], variables[6], variables[7], variables[8], variables[9], variables[10], variables[11], variables[12], variables[13], variables[14], variables[15]);
		}
		throw "Too many variables";
	}

	variableunpack(buf) {
		var arr = unpack(description, buf);
		var[] obj;
		for (var i = 0; i < length keys; i++) {
			var k = keys[i];
			if (k) {
				var val = arr[i];
				if (typeof val == "string")
					val = String(val);
				obj[k] = val;
			}
		}
		return obj;
	}

	override WriteBlock;
	protected WriteBlock(var data, var id) {
		if (id >= HEADER_SIZE) {
			if (fseek(hFile, id, SEEK_SET))
				throw @class + "." + @member + ": Seek error";
		} else {
			id = -1;
			fseek(hFile, 0, SEEK_END);
			id = ftell(hFile);
		}
		var buf = "\x05" + data;
		this.Write(buf);
		return true;
	}

	override _Store;
	protected _Store(var obj, update_index = true, id = -1, changed_keys = null, do_flush = true, change_oid = false, wordcache = null) {
		if (!hFile)
			throw "Invalid file descriptor or no open file";
		if (!structure)
			throw "No structure set. Call SetStructure first.";
changed_keys = null;
		var data;
		var not_oid_update = true;
		if (typeof obj == "array") {
			if ((id < 0) && (IsSet(obj, '$')))
				id = value obj['$'];
		} else
			obj = ToArray(obj);

		var c = this.filterobject(obj);

		if ((changed_keys) && (length changed_keys == 1) && (IsSet(changed_keys, '$oid')))
			not_oid_update = false;
		var bm25_document = null;
		var graph = null;
		// bm25 index updated
		if ((bm25) && (c) && (not_oid_update) && ((update_index) || (changed_keys)))
			bm25_document = bm25.document(c, graph, BM25_GRAPH_LEVEL);

		data = this.variablepack(this.description, c);
		if (length data != record_size)
			throw "Invalid data size";
		if (data) {
			var orig_id = id;
			var res = this.WriteBlock(data, id);

			if ((orig_id > 0) && (cache)) {
				if (IsSet(cache, "" + orig_id))
					cache = new [];
			}
			if (res > 0) {
				if (do_flush)
					this.Flush();
				if (update_index) {
					if (changed_keys == null)
						this.UpdateIndex(obj, id);
					else
						this.UpdateIndex(changed_keys, id, obj);
				}
				if (bm25_document) {
					if (wordcache) {
						try {
							bm25.update(bm25_document, id, changed_keys, graph, false, wordcache[0], wordcache[1], wordcache[2], orig_id > 0);
							if (length wordcache[0] >= BM25_MAX_WORDCACHE)
								bm25.dumpcache(wordcache[0], wordcache[1], wordcache[2]);
							if ((length wordcache[1] >= BM25_MAX_WORDCACHE) || (length wordcache[2] >= BM25_MAX_WORDCACHE))
								bm25.dumpcache(null, wordcache[1], wordcache[2]);
						} catch (var exc) {
							console.error(LOG_THIS, "Error in bm25.update $exc");
						}
					} else {
						bm25.SetIndexLock(2);
						try {
							bm25.update(bm25_document, id, changed_keys, graph, true, null, null, null, orig_id > 0);
						} catch (exc) {
							console.error(LOG_THIS, "Error in bm25.update $exc");
						}
						bm25.SetIndexLock(false);
						if (exc)
							throw exc;
						if (classof bm25 == "BM25Index")
							this.SyncBM25Info();
					}
				}
			}
			if (DebugPath) {
				if (orig_id > 0)
					WriteFile(data, DebugPath + "/${time()}-${microseconds()}-$id.update.bin");
				else
					WriteFile(data, DebugPath + "/${time()}-${microseconds()}-$id.bin");
			}
			return id;
		}
		return id;
	}


	override InvalidId;
	InvalidId(id) {
		if (id < HEADER_SIZE)
			return true;
		id -= HEADER_SIZE;
		if (id < MAX_STRUCTURE_SIZE)
			return true;
		id -= MAX_STRUCTURE_SIZE;
		if (id % (record_size + 1))
			return true;
		return false;
	}

	override GetOne;
	GetOne(var id = null, strict = true, offset = -1) {
		if (offset < 0)
			id = ftell(hFile);
		else
			id = offset;
		var buf = "";
		var mod_size = record_size + 1;
		do {
			var size = fread(var buf_block, 1, mod_size, hFile);
			if (size != mod_size) {
				if (buf)
					throw @class + "." + @member + ": Corrupted database or invalid read offset (page read)";
				return "";
			}

			var flag = buf_block[0];
			switch (flag) {
				case "\x05":
					break;
				case "\x00":
					if (strict)
						return "";
					// deleted block
					id = ftell(hFile);
					continue;
				default:
					throw @class + "." + @member + ": Invalid buffer for id $id";
			}
			if (Debug)
				this.__Debug(id);

			buf = SubStr(buf_block, 1);
		} while (!buf);
		return buf;
	}

	override ById;
	ById(id, fields = null, do_cache = false, cache = null, notify_one = null, notify_data = null) {
		if (typeof id == "array") {
			var[] id_flags;
			var res_array = new [];
			for (var i = 0; i < length id; i++) {
				var _id = id[i];
				var _id_key = "" + _id;
				if ((_id) && (!InvalidId(_id)) && (!id_flags[_id_key])) {
					id_flags[_id_key]++;
					if (do_cache) {
						var cached_obj = cache[_id_key];
						if (cached_obj) {
							res_array[_id_key] = cached_obj;
							continue;
						}
					}

					if (fseek(hFile, _id, SEEK_SET))
						continue;
					var res = GetOne(null, true, _id);
					if (res) {
						var o = variableunpack(res);
						if (o != null) {
							o['$'] = _id;
							if (notify_one)
								notify_one(o, notify_data);
							else
								res_array[length res_array]  = o;
							if (do_cache)
								cache[_id_key] = o;
						}
					}
				}
			}
			return res_array;
		} else {
			if (InvalidId(id))
				return null;

			if (do_cache) {
				var cache_key = "" + id;
				cached_obj = cache[cache_key];
				if (cached_obj)
					return cached_obj;
			}

			//if (!this.Seek(id))
			if (fseek(hFile, id, SEEK_SET))
				return null;
			res = GetOne(null, true, id);
			if (res) {
				o = variableunpack(res);
				if (o) {
					o['$'] = id;

					if (do_cache)
						cache[cache_key] = o;
				}
				return o;
			}
			return null;
		}
	}

	override Scan;
	Scan(callback, var userdata = null) {
		fseek(hFile, HEADER_SIZE + MAX_STRUCTURE_SIZE, SEEK_SET);
		while (var obj = this.GetOne(var id, false)) {
			var o = variableunpack(obj);
			if (o) {
				o['$'] = id;
				if (callback(o, id, userdata))
					break;
			}
		}
	}

	override _EmptyBlock;
	protected _EmptyBlock() {
		var empty_block = "";

		var block_size = record_size + 1;
		for (var i = 0; i < block_size; i++)
			empty_block += "\x00";

		return empty_block;
	}

	override _DeleteChain;
	protected _DeleteChain(offset) {
		if (offset <= 0)
			return false;

		fseek(hFile, offset, SEEK_SET);
		this.Write(this._EmptyBlock());

		return true;
	}

	override _Delete;
	protected _Delete(id, strict = false, update_index = true) {
		//if (!this.Seek(id))
		if (InvalidId(id))
			return false;

		if (id <= 0)
			return false;

		if (fseek(hFile, id, SEEK_SET))
			return false;


		var obj = GetOne(null, true, id);
		if (!obj)
			return false;

		try {
			if ((Indexes) && (update_index))
				this.RemoveIndexes(variableunpack(obj), id);
		} catch (var exc) {
			console.error(LOG_THIS, "Exception: $exc");
			return false;
		}

		if (Journal)
			Journal(obj, this.name, id, 3);

		this._DeleteChain(id);
		if (cache) {
			if (IsSet(cache, "" + id))
				cache = new [];
		}
		return true;
	}

	override Update;
	Update(o, var id, update_index = true, var oid = null, getoid = false) {
		oid = null;
		if (fseek(hFile, id, SEEK_SET))
			return false;
		var keys = GetKeys(o);
		if (keys) {
			// nothing to update
			if ((length keys == 1) && (keys[0] == '$'))
				return true;
			var res = GetOne(null, true, id);
			if (res) {
				var old = variableunpack(res);
				if (old) {
					var[] new_values;
					var[] changed;
					for (var i = 0; i < length keys; i++) {
						var k = keys[i];
						if ((k) && (k != '$')) {
							// add to array
							var val = o[k];
							if (k[0] == "+") {
								k++;
								if (SetKey(old, k, val, var first_key, var prec_value, true)) {
									changed[k] = prec_value;
									new_values[k] = val;
								}
							} else {
								if (SetKey(old, k, val, first_key, prec_value)) {
									changed[k] = prec_value;
									new_values[/*first_key*/k] = val;
								}
							}
						}
					}
					if (getoid)
						oid = old['$oid'];
					// nothing changed
					if (!changed)
						return true;
					if (update_index)
						update_index = this.RemoveIndexesIfChanged(changed, id, old);

					if (fseek(hFile, id, SEEK_SET))
						return false;
					this._Store(old, update_index, id, new_values);
					return true;
				}
			}
		}
		return false;
	}

	override FetchByIndex;
	FetchByIndex(addr, start = 0, len = -1) {
		var[] result;
		for (var i = 0; i < length addr; i++) {
			var offset = addr[i] + HEADER_SIZE + MAX_STRUCTURE_SIZE;
			fseek(hFile, offset, SEEK_SET);
			var obj = this.GetOne(var id, true, offset);
			if (obj) {
				var o = variableunpack(obj);
				if (o) {
					o['$'] = id;
					result[length result] = o;
				}
			}
		}
		return result;
	}

	filterobject(obj) {
		var c = new [];
		for (var j = 0; j < length keys; j++) {
			var k = keys[j];
			if (k)
				c[k] = obj[k];
		}
		return c;
	}

	override _FastStoreMulti;
	public _FastStoreMulti(arr, update_index = true, do_flush = true, virtual_store_field = null) {
		var[] ids;
		for (var i = 0; i < length arr; i++) {
			var obj = arr[i];
			if ((obj) && (IsSet(obj, '$')))
				throw "Cannot call _FastStoreMulti on already stored objects";
			if (virtual_store_field) {
				var id = obj[virtual_store_field];
				if (id > 0)
					ids[i] = id;
			} else {
				var c = this.filterobject(obj);
				var data = variablepack(this.description, c);
				arr[i] = c;
				if (data) {
					id = -1;
					this.WriteBlock(data, id);
					ids[i] = id;
				}
			}
		}
		if (update_index) {
			for (i = 0; i < length arr; i++) {
				id = ids[i];
				if (id > 0)
					this.UpdateIndex(arr[i], id);
			}
		}
		if (do_flush)
			this.Flush();
	}


	finalize() {
		BinFile::finalize();
	}
}

class FixedStorageHelper {
	static Create(filename, mode="r+b", structure = null, use_index = true) {
		if (BM25_MAX_WORDLEN) {
			var file = new FixedStorage(filename, mode, use_index);
			file.SetStructure(structure);
			return file;
		}
		return new BinFile(filename, mode, BM25_MODULO_SIZE, use_index);
	}
}
