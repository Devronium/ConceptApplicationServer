import standard.C.io
import standard.lib.str
import standard.lib.whisper
import standard.C.time
import standard.lang.serialize
import standard.lib.samplerate
import standard.math.rand

include Worker.con

class WhisperTTSHelper {
	var modelName;

	WhisperTTSHelper(model_name) {
		this.modelName = model_name;
	}

	static tts(text, model, out_path, extra_params = "") {
		text = StrReplace(text, "\\", "\\\\");
		text = StrReplace(text, "\"", "\\\"");
		if (extra_params)
			extra_params = " " + extra_params;
		return _system("tts --text \"$text\" --model_name \"$model\" --out_path \"$out_path\"$extra_params");
	}

	speak(text, out_path) {
		return this.tts(text, modelName, out_path);
	}
}

class WhisperMessage {
	var id;
	var stream_id;
	var buffer;

	WhisperMessage(id, buffer = "", stream_id = 0) {
		this.id = id;
		this.buffer = buffer;
		this.stream_id = stream_id;
	}
}

class WhisperWorker {
	WhisperWorker(data) {
		var arr = UnBinarizeObject(data);
		var handle = arr[0];
		var id = arr[1];

		console.log(LOG_THIS, "created worker $id");
		while (true) {
			if (Worker::Pending(var buffer, 1000)) {
				var obj = UnBinarizeObject(buffer);
				if (obj) {
					if (obj.id < 0)
						break;

					obj.buffer = WhisperDecode(handle, obj.buffer);
					Worker::Result(BinarizeObject(obj));
				}
			}
		}
		console.log(LOG_THIS, "removed worker");
	}
}

class WhisperSpeechStream {
	protected var audio_buffer = "";
	protected var _started;
	protected var _start_voice;
	protected var _end_voice;
	protected var _audio_len;
	protected var _owner;
	protected var _worker_id;
	protected var _worker;
	protected var _buffer_offset;
	protected var _last_text = "";
	protected var _pending = false;

	public var BufferTimeout = 1000;
	public var MinBufferSize = 24000;

	var stream_id;
	var _handle;

	WhisperSpeechStream(object owner) {
		this._owner = owner;
		this._handle = true;
		this.stream_id = RandomInteger(0, 0x10000000);
	}

	feed(var buffer) {
		if (!_started)
			_started = microseconds();
		audio_buffer += buffer;
		_audio_len += length buffer;

		var level_val = level(buffer);
		if (_start_voice) {
			if (level_val < 0.01) {
				if (!_end_voice)
					_end_voice = microseconds();
			} else
			if (level_val > 0.0031)
				_end_voice = 0;
		} else
		if (level_val >= 0.1) {
			_start_voice = microseconds();
			_end_voice = 0;
		}
	}

	decode() {
		if (!_started)
			return "";

		if (!_worker)
			_worker = _owner.findWorker(_worker_id);
		if (!_worker)
			throw "WhisperSpeechStream: No available workers";

		if ((!_pending) && (audio_buffer) && (_buffer_offset < length audio_buffer) && (((_end_voice) && ((microseconds() - _end_voice) >= 1000000)) || ((_audio_len > MinBufferSize) || (((microseconds() - _started) / 1000) >= BufferTimeout)))) {
			_worker.AddData(BinarizeObject(new WhisperMessage(_worker_id, audio_buffer, stream_id)));
			_pending = true;
			_started = microseconds();

			audio_buffer = "";
			_buffer_offset = 0;
			_audio_len = 0;

			_start_voice = 0;
			_end_voice = 0;
		}

		_worker.GetResult(var data);
		if (data) {
			var obj = UnBinarizeObject(data);
			if ((obj) && (obj.stream_id == stream_id)) {
				_last_text = obj.buffer;
				_pending = false;
			}
		}
		return _last_text;
	}

	finish() {
		audio_buffer = "";
		_audio_len = 0;
		_started = 0;
		_buffer_offset = 0;
		_start_voice = 0;
		_end_voice = 0;
		return "";
	}

	close() {
		audio_buffer = "";
		_audio_len = 0;
		_started = 0;
		_buffer_offset = 0;
		_start_voice = 0;
		_end_voice = 0;
		this._handle = false;
		this._owner.freeWorker(_worker_id);
	}

	finalize() {
		if (this._owner)
			this._owner.freeWorker(_worker_id);
		this._handle = false;
		_started = 0;
	}
}

class WhisperSpeech {
	var _handle;

	var modelSampleRate = 16000;
	var maxWorkers = 0;

	var[] workers;
	var[] worker_busy;

	protected var _round_robin;

	WhisperSpeech(string language, model = "tiny", threads_per_worker = 1, whisper_parent = null, offline = false) {
		if (typeof whisper_parent == "class")
			whisper_parent = whisper_parent._handle;

		_handle = WhisperCreate(model, language, false, threads_per_worker, offline, whisper_parent);
		modelSampleRate = WhisperSampleRate();
	}

	freeWorker(id) {
		if ((id < 0) || (id >= length worker_busy))
			return;

		if (worker_busy[id] > 0)
			worker_busy[id] --;
	}

	findWorker(var id = -1) {
		id = -1;

		if (!this._handle)
			throw "Whisper context is not created";
		for (var i = 0; i < length worker_busy; i ++) {
			if (!worker_busy[i]) {
				worker_busy[i] = 1;
				id = i;
				return workers[i];
			}
		}

		var worker;

		if ((maxWorkers > 0) && (length workers >= maxWorkers)) {
			worker = workers[_round_robin];
			worker_busy[_round_robin] ++;
			id = _round_robin;
			_round_robin ++;
			return worker;
		}
		
		worker = new Worker("WhisperWorker", BinarizeObject([this._handle, length workers]));
		// length workers instead of length worker_busy (should be the same)
		worker_busy[length workers] = true;
		id = length workers;
		workers[length workers] = worker;

		return worker;
	}

	close() {
		if (!_handle)
			return;
		if (this.workers) {
			var msg = BinarizeObject(new WhisperMessage(-1));
			for (var i = 0; i < length workers; i ++) {
				workers[i].AddData(msg, 1);
				workers[i].Join();
			}
		}
		if (_handle)
			WhisperFree(_handle);
	}

	finalize() {
		this.close();
	}
}
