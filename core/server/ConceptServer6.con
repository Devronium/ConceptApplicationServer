#!/usr/local/bin/concept -chdir

include H2Server.con
include WebSocket.con
include Worker.con
include DUKJS.con
include JSFramework.con

import standard.lang.cli

define LOG_LEVEL		LOG_INFO
define WS_SESSION_RESTORE	true
define CONCEPT_STRICT_EXECUTE	false
define SERVER_NAME		"cas"
define SERVER_SOFTWARE		"Concept Application Server (TLSe,ws/wss/http/https/cgi1.1/http2/ess/async)"
define USE_DB_SERVICE		true
define DEFAULT_CGI_WORKERS	2
define JS_CGI_DONE_TIMEOUT	30
define JS_MAX_TIMEOUT		1200
define JS_FRAMEWORK		"/js/"
define CGI_MAX_RETRY_SECONDS	30
define INI_CACHE_TIMEOUT_S	30
define PIPE_READ_CPU_TIME_US	2000
define MAX_RECV_BUFFER		0xFFFF
define IDLE_SLEEP_MS		10
define IDLE_SLEEP_THRESHOLD	200
define IDLE_SLEEP_MS2		50

// 128k pipe read buffer
define PIPE_MAX_STDOUT_BUFFER	0x20000
// 2Mb stdout buffer
define CGI_MAX_STDOUT_BUFFER	0x200000
// 8Mb stdout buffer for http/2
define H2_MAX_STDOUT_BUFFER	0x800000
// 2Mb limit file read buffer
define H2_MAX_FILE_BUFFER	0x200000
// 128k file buffer for http 1.1
define H1_MAX_FILE_BUFFER	0x20000

class ConceptCGIChildBase {
	var owner;
	var h2;
	var stream;
	var h2headers;
	var Socket;
	var pid;
	var std_in_buffer = "";
	var std_out_buffer = "";
	var is_post;
	var last_err_time;
	var reqid;

	static ParseHeaders(h2headers, buffer) {
		var arr = StrSplit(buffer, "\n");
		for (var i = 0; i < length arr; i++) {
			var e = arr[i];
			if (e) {
				var pos = Pos(e, ":");
				if (pos > 0) {
					var k = ToLower(trim(SubStr(e, 0, pos - 1)));
					var val = trim(SubStr(e, pos));
					h2headers[k] = val;
				}
			}
		}
	}

	Join() {
		if (pid > 0) {
			if (ExecuteIsRunning(pid))
				kill(__PID(pid), SIGKILL);

			ExecuteJoin(pid);
			pid = 0;
		}
	}

	H2Close() {
		if ((h2) && (stream)) {
			Join();
			h2.UserData--;
			var exc;
			try {
				if (stream.Status == 2)
					stream.Write(h2, "", true);
				delete h2;
				delete stream;
				delete Socket;
			} catch (exc) {
				console.warn(LOG_THIS, "ConceptCGIChild/HTTP/2 Socket close error: $exc");
			}
		}
	}
}

class JSCode extends JSFramework {
	public var path = "";
	protected var framework_path = "";
	protected var[] loaded;

	require_lib(lib) {
		if (loaded[lib])
			return true;
		if (this.require(lib)) {
			loaded[lib] = true;
			return true;
		}
		var libname = "ECMABRIDGE_" + StrReplace(lib, ".", "_");
		var code = ReadFile(framework_path + lib + ".js.con");
		if (!code)
			return false;
		if (IncludeCode(code))
			return false;
		var obj = CreateObject2(libname, js);
		if (obj) {
			js.script(ReadFile(framework_path + lib + ".js"), lib + ".js");
			loaded[lib] = true;
			return true;
		}
		return false;
	}

	jsinclude(filename) {
		try {
			if ((path) && (FileExists(path + filename)))
				js.script(ReadFile(path + filename), filename);
			else
			if ((path) && (FileExists(path + filename + ".ess")))
				js.script(ReadFile(path + filename + ".ess"), filename + ".ess");
			else
			if ((path) && (FileExists(path + filename + ".js")))
				js.script(ReadFile(path + filename + ".js"), filename + ".js");
			else
			if (FileExists(framework_path + filename))
				js.script(ReadFile(framework_path + filename), filename);
			else
			if (FileExists(framework_path + filename + ".ess"))
				js.script(ReadFile(framework_path + filename + ".ess"), filename);
			else
			if (FileExists(framework_path + filename + ".js"))
				js.script(ReadFile(framework_path + filename + ".js"), filename);
			else
				return ["message" => "Cannot include file $filename", "name" => "IncludeError"];
		} catch (var exc) {
			console.warn(LOG_THIS, exc);
			return exc;
		}
		return null;
	}

	logdata(data) {
		console.log(LOG_THIS, data);
	}

	JSCode(use_path, error_delegate = null, jspath = "") {
		path = use_path;
		framework_path = jspath;
		if (!error_delegate) {
			error_delegate = function(js, message, struct) {
				console.error(LOG_THIS, message);
				console.error(LOG_THIS, struct);
			};
		}
		js = new JS(error_delegate);
		super(js, use_path);

		js.wrap(this.require_lib, "require");
		js.wrap(this.jsinclude, "__cjs_include");
		js.wrap(this.logdata, "log");
		js.script("function include(filename) { var err = __cjs_include(filename); if (err) throw err; }; var con = { 'require': require, 'include': include, 'log': log, 'loop': [ ], 'schedule': function(e) { if (typeof e == 'function') con.loop.push(e); } }; function onidle() { for (var i = 0; i < con.loop.length; i++) { var e = con.loop[i]; if (e) { try { e(); } catch (exc) { critical(exc); } } } }\n");
	}

	run(var code, filename = "code.js") {
		js.timeout(JS_MAX_TIMEOUT);
		return js.script(code, filename);
	}
}

class ConceptAsyncChild extends ConceptCGIChildBase {
	var running;
	var print_started = false;
	var header_started = false;
	var write_headers = false;
	var last_idle_call = 0;
	var timeout = 0;
	var sessionid = "";
	var sessionpath;
	var is_url_encoded = true;
	var url_buffer = "";
	var boundary;
	var content_length = -1;

	GetPath(filename) {
		var directory = http_directory(filename);
		if ((!ON_MSWINDOWS) && (filename) && (filename[0] == "/") && (directory[0] != "/"))
			return "/" + directory;

		return directory;
	}

	ParseQueryString(var qstring) {
		var get_query = [ ];
		if (qstring) {
			var arr = StrSplit(qstring, "&");
			for (var i = 0; i < length arr; i++) {
				var e = arr[i];
				if (e) {
					var pos = Pos(e, "=");
					if (pos > 0) {
						var k = URIDecode(SubStr(e, 0, pos - 1));
						var val = URIDecode(SubStr(e, pos));
						if (IsSet(get_query, k)) {
							var prev = get_query[k];
							if (typeof prev == "array")
								prev[length prev] = val;
							else
								get_query[k] = [prev, val];
						} else
							get_query[k] = val;
					}
				}
			}
		}
		return get_query;
	}

	dovalue(cookies, str, check_session_cookie = true) {
		var val = trim(str);
		var pos = Pos(val, "=");
		if (pos > 0) {
			var name = trim(SubStr(val, 0, pos - 1));			
			if (name) {
				var cookie_val = trim(SubStr(val, pos));
				if (check_session_cookie)  {
					if (name == "_ess")
						sessionid = cookie_val;
				} else
				if (length cookie_val >= 2) {
					if ((cookie_val[0] == '"') && (cookie_val[length cookie_val - 1] == '"'))
						cookie_val = SubStr(cookie_val, 1, length cookie_val - 2);
				}
				cookies[name] = cookie_val;
			}
		}
	}

	docookie(cookies, cookie) {
		if (typeof cookie == "string") {
			var data = StrSplit(cookie, ";");
			for (var i = 0; i < length data; i++)
				dovalue(cookies, data[i]);
		}
	}

	parsepart(var e) {
		var pos = Pos(e, "\r\n\r\n");
		if (pos <= 0)
			return null;
		var header = SubStr(e, 0, pos - 1);
		var data = SubStr(e, pos + 3);
		var parameters = StrSplit(header, ";");
		var[] keys;
		if (parameters) {
			for (var i = 1; i < length parameters; i++) {
				dovalue(keys, parameters[i], false);
			}
		}
		keys["data"] = data;
		return keys;
	}

	parsemultipart(var data) {
		if (!boundary)
			return null;

		var arr = StrSplit(data, "\r\n--" + boundary);
		var[] parts;
		for (var i = 0; i < length arr; i++) {
			var e = arr[i];
			if (length e < 10) {
				e = trim(e);
				// end of data ?
				if (e == "--")
					break;
			}
			if (e) {
				var part = parsepart(e);
				if (part) {
					var key = length parts;
					if (IsSet(part, "name")) {
						key = part["name"];
						if ((length part == 2) && (IsSet(part, "data")))
							part = part["data"];
					}
					parts[key] = part;
				}
			}
		}
		return parts;
	}

	sessionfilename(session_id) {
		if ((Pos(session_id, ".") > 0) || (Pos(session_id, "/") > 0) || (Pos(session_id, "\\") > 0))
			session_id = "dummy";
		return sessionpath + "/" + sessionid + ".ess";
	}

	writesession(sessiondata, session_id) {
		return WriteFile(BinarizeObject(sessiondata), this.sessionfilename(session_id));
	}

	readsession(session_id) {
		var data = ReadFile(this.sessionfilename(session_id));
		if (data)
			return UnBinarizeObject(data);
		return null;
	}

	removesession(session_id) {
		_unlink(this.sessionfilename(session_id));
	}

	syncsession(sessiondata) {
		if (sessionid) {
			try {
				if (typeof sessiondata == "array") {
					var info = sessiondata["session"];
					if (typeof info == "array") {
						var id = info["id"];	
						if (id == sessionid) {
							if (this.writesession(sessiondata, sessionid))
								return;
						}
					}
				}
			} catch (var exc) {
				console.error(LOG_THIS, exc);
			}
			this.removesession(sessionid);
		}
	}

	print(var buffer) {
		// is closed ?
		if ((!h2) && (!Socket))
			return;
		timeout = time() + JS_CGI_DONE_TIMEOUT;
		if ((!header_started) && (!h2)) {
			std_out_buffer += "HTTP/1.1 200 OK\r\nServer: " + SERVER_NAME + "\r\n";
			header_started = true;
		}
		if (!print_started) {
			if (h2)
				write_headers = true;
			else
				std_out_buffer += "\r\n";
		}
		if (typeof buffer == "array")
			buffer = this.obj_to_string(buffer, true);
		print_started = true;
		if (length std_out_buffer > H2_MAX_STDOUT_BUFFER) {
			console.warn(LOG_THIS, "CGI stdout buffer overflow");
			return;
		}
		std_out_buffer += buffer;
	}

	critical(exc) {
		console.error(LOG_THIS, exc);
		this.print("Uncaught error:\n");
		this.print(exc);
		this.done();		
	}

	space(key, len) {
		while (length key < len)
			key += " ";
		return key;
	}

	obj_to_string(obj, level = 0, var backref = null, prec_level_str = "", new_line = "\n") {
		var output = "";
		if (typeof obj == "array") {
			if (level <= 1)
				backref = new [];
			backref["" + ClsPtr(obj)] = true;
			var level_str = "";
			for (var i = 0; i < level ; i++)
				level_str += "  ";
			var keys = GetKeys(obj);
			var max_len = 0;
			var is_static = true;
			for (i = 0; i < length keys; i++) {
				var key = keys[i];
				if ((key) && (length key > max_len)) {
					max_len = length key;
					is_static = false;
				} else {
					var val = obj[i];
					if ((typeof val != "string") && (typeof val != "numeric"))
						is_static = false;
				}
			}
			var is_object = max_len;
			if (level) {
				if (is_object) {
					output += "{";
				} else
					output += "[";
			}
			if (is_static) {
				output += " ";
				level_str = "";
				prec_level_str = "";
			} else
				output += "\n";
			for (i = 0; i < length obj; i++) {
				key = keys[i];
				val = obj[i];
				output += "$level_str";
				if (typeof key == "string")
					output += this.space(key, max_len) + ": ";

				if (typeof val == "array") {
					var backref_ptr = ""+ClsPtr(val);
					if (backref[backref_ptr]) {
						output += "(reference to already printed object)";
						if (i < length obj - 1)
							output += ",";
						output += new_line;
					} else {
						backref[backref_ptr] = true;
						output += obj_to_string(val, level + 1, backref, level_str);
					}
				} else {
					output += val;
					if (is_static)
						output += " ";
					else
						output += new_line;
				}
			}
			if (level) {
				if (is_object)
					output += "$prec_level_str}" + new_line;
				else
					output += "$prec_level_str]" + new_line;
			}
			return output;
		}
		return "" + obj;
	}

	header(key, val) {
		timeout = time() + JS_CGI_DONE_TIMEOUT;
		if ((typeof key != "string") || (!key))
			return false;

		if (print_started)
			return false;

		if (h2) {
			key = ToLower(key);
			if (key == "set-cookie") {
				var cookie = h2headers[key];
				if (cookie) {
					if (typeof cookie == "array")
						val = cookie + val;
					else
					if (typeof val == "array")
						val = val + cookie;
					else
						val = [val, cookie];
				}
			}
			h2headers[key] = val;
			return true;
		}
		if (!header_started) {
			if (key != ":status") {
				std_out_buffer += "HTTP/1.1 200 OK\r\nServer: " + SERVER_NAME + "\r\n";
			} else {
				std_out_buffer += "HTTP/1.1 $val\r\nServer: " + SERVER_NAME + "\r\n";
				header_started = true;
				return true;
			}
		}
		if (typeof val == "array") {
			for (var i = 0; i < length val; i++)
				std_out_buffer += "$key: ${val[i]}\r\n";
		} else
			std_out_buffer += "$key: $val\r\n";
		header_started = true;
		return true;
	}

	basedone() {
		timeout = time() + JS_CGI_DONE_TIMEOUT;
		if ((h2) && (!print_started))
			write_headers = true;
		running = false;
	}

	baseclosesocket() {
		if ((h2) && (stream)) {
			try {
				stream.Close(h2);
			} catch (var exc) {
				console.debug(LOG_THIS, "${@class}/HTTP/2 Socket close error: $exc");
			}
		} else
		if (Socket) {
			try {
				SetNonBlocking(Socket.Socket, true);
				Socket.Close(/* true */);
			} catch (exc) {
				console.warn(LOG_THIS, "ConceptJSChild/Socket close error: $exc");
			}
			delete Socket;
		}
		try {
			delete h2;
		} catch (exc) {
		}
		try {
			delete stream;
		} catch (exc) {
		}
		try {
			delete Socket;
		} catch (exc) {
		}
		std_out_buffer = "";
		std_in_buffer = "";
	}

	ConceptAsyncChild(owner, Socket, buffer, h2 = null, stream = null, default_h2_header = null) {
		this.owner = owner;
		this.Socket = Socket;
		this.std_in_buffer = buffer;
		this.h2 = h2;
		this.stream = stream;
		this.h2headers = default_h2_header;
		this.is_post = true;
		this.sessionpath = _getenv("sessionpath");
		if (!this.sessionpath)
			this.sessionpath = _getenv("tmp");
		if (!this.sessionpath)
			this.sessionpath = _getenv("temp");
		if (!this.sessionpath)
			this.sessionpath = "/tmp";
		SocketSetBlocking(Socket.Socket, false);
		if (h2) {
			h2.MaxOutputBuffer = H2_MAX_STDOUT_BUFFER;
			h2.MaxFileBuffer = H2_MAX_FILE_BUFFER;
		}
	}

	jsheaders(js, headers, arr_data = null) {
		var[] cookies;
		if (!headers)
			return [ ];
		if (IsSet(headers, "cookie")) {
			var cookie_list = headers["cookie"];
			if (typeof cookie_list == "array") {
				for (var i = 0; i < length cookie_list; i++)
					docookie(cookies, cookie_list[i]);
			} else
				docookie(cookies, cookie_list);
		}
		if (IsSet(headers, "content-type")) {
			var header = "" + headers["content-type"];
			var header_lo = ToLower(header);
			var parameters = StrSplit(header_lo, ";");
			var content_type = trim("" + parameters[0]);
			if (content_type != "application/x-www-form-urlencoded") {
				is_url_encoded = false;
				if (content_type == "multipart/form-data") {
					var pos = Pos(header_lo, "boundary=");
					if (pos > 0) {
						var boundary = StrSplit(SubStr(header, pos + 8), ";")[0];
						if (boundary) {
							this.boundary = trim(boundary);
							if (js)
								js.variable("boundary", boundary);
							else
								arr_data["boundary"] = boundary;
						}
					}
				}
			}
		}
		if (IsSet(headers, "content-length")) {
			this.content_length = value headers["content-length"];
			if (js)
				js.variable("contentLength", this.content_length);
			else
				arr_data["contentLength"] = this.content_length;
		}
		if (js)
			js.variable("cookies", cookies);
		else
			arr_data["cookies"] = cookies;
		return headers;
	}

	baseiterate(var ops, can_write = true) {
		try {
			if (stream) {
				if (stream.HasData()) {
					var buf = stream.Read();
					if (this.is_post)
						this.post(buf);
					ops++;
				}
			} else
			if (Socket.HasData) {
				buf = Socket.Read(MAX_RECV_BUFFER);
				if (!buf) {
					this.reset();
					return true;
				}
				if (this.is_post)
					this.post(buf);
				ops ++;
			}
		} catch (var exc) {
			// socket closed
			this.reset();
			return true;
		}
		if (((std_out_buffer) || (write_headers)) && (can_write)) {
			if (stream) {
				var stream_write = true;
				try {
					if (h2headers) {
						stream.Response(h2, h2headers);
						h2headers = null;
					}
					if ((stream_write) && (std_out_buffer)) {
						var close_stream = false;
						if ((!running) && (stream.AtomicWriteSize(length std_out_buffer) == length std_out_buffer))
							close_stream = true;

						var res = stream.SafeWrite(h2, std_out_buffer, close_stream);
						if (res > 0) {
							std_out_buffer = SubStr(std_out_buffer, res);
							ops ++;
						}
					}
				} catch (exc) {
					this.reset();
					return true;
				}
			} else
			if (Socket) {
				try {
					res = Socket.Write(std_out_buffer);
					if (res > 0) {
						std_out_buffer = SubStr(std_out_buffer, res);
						ops ++;
						if (length std_out_buffer > CGI_MAX_STDOUT_BUFFER) {
							console.warn(LOG_THIS, "CGI stdout buffer overflow");
							return true;
						}
						last_err_time = 0;
					}
				} catch (exc) {
					// EAGAIN ?
					var err = SocketErrno();
					if ((err != 11) && (err != 35) && (err != 10035)) {
						this.reset();
						return true;
					}

					if ((last_err_time) && (time() - last_err_time >= CGI_MAX_RETRY_SECONDS)) {
						console.warn(LOG_THIS, "CGI write congestion");
						this.reset();
						return true;
					}
					last_err_time = time();
				}
			}
			if (!std_out_buffer)
				this.notify_buffer();
		}
		if ((!std_out_buffer) && (!running)) {
			H2Close();
			this.reset();
			return true;
		}
		return false;
	}

	usesession(expires = 2592000, path = "/", domain = "", secure = false, httponly = true) {
		var sessiondata;
		if (sessionid)
			sessiondata = this.readsession(sessionid);
		if (sessiondata) {
			var info = sessiondata["session"];
			if (info) {
				var is_expired = info["expires"];
				if (time() > is_expired) {
					sessiondata = null;
					this.removesession(sessionid);
				}
			}
		}
		if (!sessiondata) {
			sessionid = sha256(CryptoRandom(80));
			var expires_when = time() + expires;
			sessiondata = ["session" => ["id" => sessionid, "expires" => expires_when, "created" => time()]];
			var cookie = "_ess=${sessionid}; Max-Age=" + expires;
			if (path)
				cookie += "; Path=$path";
			if (domain)
				cookie += "; Domain=$domain";
			if (secure)
				cookie += "; Secure";
			if (httponly)
				cookie += "; HttpOnly";
			this.header("Set-Cookie", cookie);
			this.writesession(sessiondata, sessionid);
		}
		return sessiondata;
	}
}


class ConceptJSChild extends ConceptAsyncChild {
	var js;

	ConceptJSChild(owner, framework, method, Socket, env, buffer, h2 = null, stream = null, default_h2_header = null, headers = null) {
		super(owner, Socket, buffer, h2, stream, default_h2_header);
		var app = env["SCRIPT_FILENAME"];

		js = new JSCode(this.GetPath(app), null, framework);
		running = true;
		js.js.wrap(this.print, "print");
		js.js.wrap(this.header, "header");
		js.js.wrap(this.jsusesession, "usesession");
		js.js.wrap(this.done, "done");
		js.js.wrap(this.critical, "critical");
		js.js.wrap(this.ParseQueryString, "urlparameters");
		js.js.wrap(this.parsemultipart, "multipart");
		js.js.variable("request", env);
		if (stream)
			js.js.variable("headers", jsheaders(js.js, stream.Headers));
		else
		if (headers)
			js.js.variable("headers", jsheaders(js.js, headers));

		js.js.variable("GET", this.ParseQueryString(env["QUERY_STRING"]));
		var filecontents = ReadFile(app);
		if (filecontents) {
			try {
				if (buffer)
					this.parsepostdata(buffer);
				js.run("try { "+ filecontents + " } catch (exc) { critical(exc); }", app);
				if (buffer)
					this.post(buffer, false);
			} catch (var exc) {
				this.critical(exc);
			}
		} else
			this.done();
		timeout = time() + JS_CGI_DONE_TIMEOUT;
	}

	jsusesession(expires = 2592000, path = "/", domain = "", secure = false, httponly = true) {
		var sessiondata = this.usesession(expires, path, domain, secure, httponly);
		js.js.variable("session", sessiondata);
		return sessiondata;
	}

	reset() {
		if (js) {
			// important to avoid memory leak (wrap mantains references!)
			js.detach();
			js.js = null;
			js = null;
		}
		if (owner)
			owner.ClearCache(this);
	}

	done() {
		if ((js) && (js.js))
			this.syncsession(js.js.script("this.session"));
		this.basedone();
	}

	Close() {
		Join();
		baseclosesocket();
		if (js)
			this.reset();
	}

	parsepostdata(var data) {
		if (is_url_encoded) {
			url_buffer += data;
			var parsed = ParseQueryString(trim(url_buffer));
			js.js.variable("POST", parsed);
			js.js.call("onpost", [parsed]);
			if (length url_buffer > MAX_RECV_BUFFER)
				url_buffer = "";
		}
	}

	post(var data, checkpostdata = true) {
		if ((js) && (data)) {
			timeout = time() + JS_CGI_DONE_TIMEOUT;
			if (checkpostdata)
				this.parsepostdata(data);
			js.js.BinaryMode = true;
			js.js.call("ondata", [data]);
			js.js.BinaryMode = false;
		}
	}

	notify_buffer() {
		if (js)
			js.js.call("onoutput", [length std_out_buffer]);
	}

	Iterate(var ops, can_write = true) {
		// timed out
		if (time() > timeout) {
			if (js.js.call("ontimedout", [ ])) {
				timeout = time() + JS_CGI_DONE_TIMEOUT;
			} else {
				std_out_buffer += "\nJSScript timeout out\nDid you forget to call done()?\n";
				running = false;
			}
		}

		if (!running)
			this.reset();

		if (this.baseiterate(ops, can_write))
			return true;

		if ((js) && ((!ops) || (microseconds() - last_idle_call > 1000000))) {
			last_idle_call = microseconds();
			js.js.call("onidle", [ ]);
		}
		return false;
	}

	IterateEventLoop(socket, loop, is_write) {
		if (is_write < 0) {
			this.reset();
		} else {
			if (owner)
				owner.IterateAsyncWorkers(null);
			if (this.Iterate(null, is_write)) {
				this.reset();
				return LOOP_EVENT_REMOVE;
			}
		}
	}
}

class ConceptCASChild extends ConceptAsyncChild {
	var worker;

	ConceptCASChild(owner, worker, err_buffer, method, Socket, env, buffer, h2 = null, stream = null, default_h2_header = null, headers = null) {
		super(owner, Socket, buffer, h2, stream, default_h2_header);

		worker.idx++;
		this.reqid = "" + worker.idx + "." + sha1(CryptoRandom(32));

		var[] env_data;
		env_data["env"] = env;
		if (stream)
			env_data["headers"] = this.jsheaders(null, stream.Headers, env_data);
		else
		if (headers)
			env_data["headers"] = this.jsheaders(null, headers, env_data);
		env_data["GET"] = this.ParseQueryString(env["QUERY_STRING"]);

		if (err_buffer) {
			this.critical(err_buffer);
		} else {
			this.worker = worker;
			running = true;
			if (buffer) {
				this.parsepostdata(buffer, env_data);
				this.post(buffer, false);
			}
			this.remotenotify("new", env_data, -1);
		}

		timeout = time() + JS_CGI_DONE_TIMEOUT;
	}

	reset() {
		this.remotenotify("done", null, -1);
		worker = null;
		if (owner)
			owner.ClearCache(this);
	}

	remotenotify(action, data = null, priority = 0) {
		if (worker) {
			var arr = ["q" => reqid, "do" => action, "_" => microseconds()];
			if (data)
				arr["data"] = data;
			worker.CacheData(arr, priority);
		}
	}

	done() {
		this.basedone();
		this.remotenotify("done");
		worker = null;
	}

	Close() {
		Join();
		baseclosesocket();
		if (worker)
			this.reset();
	}

	parsepostdata(var data, env_data = null) {
		if (is_url_encoded) {
			url_buffer += data;
			var parsed = ParseQueryString(trim(url_buffer));
			this.remotenotify("post", parsed);
			if (length url_buffer > MAX_RECV_BUFFER)
				url_buffer = "";
			if (env_data)
				env_data["POST"] = parsed;
		}
	}

	post(var data, checkpostdata = true) {
		if ((worker) && (data)) {
			timeout = time() + JS_CGI_DONE_TIMEOUT;
			if (checkpostdata)
				this.parsepostdata(data);
			this.remotenotify("data", data);
		}
	}

	notify_buffer() {
		this.remotenotify("output", "" + length std_out_buffer, -1);
	}

	onmessage(data) {
		if (!data)
			return;
		var todo = data["do"];
		if (todo) {
			switch (todo) {
				case "print":
					this.print(data["data"]);
					break;
				case "done":
					this.done();
					break;
				case "header":
					var val = data["data"];
					if (val)
						this.header(val["key"], val["value"]);
					break;
				default:
					this.critical("Unknown method: $todo\n");
			}
		}
	}

	Iterate(var ops, can_write = true) {
		// timed out
		if (time() > timeout) {
			this.remotenotify("timedout");
			std_out_buffer += "\nCASScript timeout out\nDid you forget to call done()?\n";
			running = false;
		}
		if (!running)
			this.reset();

		return this.baseiterate(ops, can_write);
	}

	finalize() {
		baseclosesocket();
	}

	IterateEventLoop(socket, loop, is_write) {
		if (is_write < 0) {
			this.reset();
		} else {
			if (owner)
				owner.IterateAsyncWorkers(null);
			if (this.Iterate(null, is_write)) {
				this.reset();
				return LOOP_EVENT_REMOVE;
			}
		}
	}
}

class ConceptCGIChild extends ConceptCGIChildBase {
	var std_out;
	var std_in;
	var last_pipe_err_time;
	var last_pipe_err_time_read;
	var is_tls;

	ConceptCGIChild(owner, method, Socket, std_out, std_in, pid, buffer, h2 = null, stream = null, default_h2_header = null) {
		this.owner = owner;
		this.is_post = true;//(method != "GET");
		this.std_out = 	std_out;
		this.std_in = std_in;
		this.Socket = Socket;
		this.pid = pid;
		this.std_in_buffer = buffer;
		this.h2 = h2;
		this.stream = stream;
		this.h2headers = default_h2_header;

		SetNonBlocking(std_out, true);
		SetNonBlocking(std_in, true);
		SocketSetBlocking(Socket.Socket, false);

		if (h2) {
			is_tls = true;
			h2.MaxOutputBuffer = H2_MAX_STDOUT_BUFFER;
			h2.MaxFileBuffer = H2_MAX_FILE_BUFFER;
		} else
		if (classof Socket == "TLSESocket")
			is_tls = true;
	}

	Close() {
		Join();
		std_in_buffer = "";
		std_out_buffer = "";
		if ((h2) && (stream)) {
			try {
				stream.Close(h2);
				delete h2;
				delete stream;
				delete Socket;
			} catch (var exc) {
				console.warn(LOG_THIS, "ConceptCGIChild/HTTP/2 Socket close error: $exc");
			}
		} else
		if (Socket) {
			try {
				Socket.Close(true);
				delete Socket;
			} catch (exc) {
				console.warn(LOG_THIS, "ConceptCGIChild/Socket close error: $exc");
			}
		}

		if (std_out > 0) {
			close(std_out);
			std_out = 0;
		}
		if (std_in > 0) {
			close(std_in);
			std_in = 0;
		}
	}

	Iterate(var ops, can_write = true) {
		var running = ExecuteIsRunning(pid);
		if (running) {
			try {
				if (stream) {
					if (stream.HasData()) {
						var buf = stream.Read();
						if (this.is_post)
							std_in_buffer += buf;
						ops++;
					}
				} else
				if (Socket.HasData) {
					buf = Socket.Read(MAX_RECV_BUFFER);
					if (!buf)
						return true;
					if (this.is_post)
						std_in_buffer += buf;
					ops ++;
				}
			} catch (var exc) {
				// socket closed
				return true;
			}

			if ((std_in) && (std_in_buffer)) {
				var res = write(std_in, std_in_buffer);
				if (res > 0) {
					ops ++;
					std_in_buffer = SubStr(std_in_buffer, res);
					last_pipe_err_time = 0;
				}
				if (res <= 0) {
					var pipe_err = _errno();
					if ((pipe_err != 11) && (pipe_err != 35) && (pipe_err != 28) && (pipe_err != 22)) {
						console.error(LOG_THIS, "CGI pipe write error: $pipe_err");
						return true;
					}
					if ((last_pipe_err_time) && (time() - last_pipe_err_time >= CGI_MAX_RETRY_SECONDS)) {
						console.warn(LOG_THIS, "CGI write congestion");
						return true;
					}
					if (!last_pipe_err_time)
						last_pipe_err_time = time();
				}
			}
		}
		if ((std_out) && (can_write)) {
			// pipesocket code (splice/sendfile/TransmitFile)
			var err = -2;
			if (!is_tls) {
				err = pipesocket(std_out, Socket.Socket, MAX_RECV_BUFFER);
				if (err != -2) {
					// pipesocket supported
					if (err < 0) {
						pipe_err = _errno();
						if (!pipe_err)
							pipe_err = SocketErrno();
						if ((pipe_err != 11) && (pipe_err != 35) && (pipe_err != 28) && (pipe_err != 22) && (pipe_err != 10035) && (err)) {
							console.debug(LOG_THIS, "CGI pipe read error: $pipe_err");
							return true;
						}
						if ((last_pipe_err_time_read) && (time() - last_pipe_err_time_read >= CGI_MAX_RETRY_SECONDS)) {
							console.debug(LOG_THIS, "CGI pipe congestion");
							return true;
						}
						if (!last_pipe_err_time_read)
							last_pipe_err_time_read = time();
					} else
						last_pipe_err_time_read = 0;
				}
			}
			// end of pipesocket code
			if ((err == -2) && (length std_out_buffer < PIPE_MAX_STDOUT_BUFFER)) {
				var s = microseconds();
				var bytes_read = 0;
				do {
					res = read(std_out, var buffer, MAX_RECV_BUFFER);
					if (res > 0) {
						bytes_read += res;
						std_out_buffer += buffer;
						ops ++;
						last_pipe_err_time_read = 0;
						// CPU time
						if ((microseconds() - s > PIPE_READ_CPU_TIME_US) || (bytes_read >= MAX_RECV_BUFFER))
							break;
					}
				} while (res > 0);
				// read returns 0 if pipe closed
				if (res <= 0) {
					pipe_err = _errno();
					if ((pipe_err != 11) && (pipe_err != 35) && (pipe_err != 28) && (pipe_err != 22) && (res)) {
						console.debug(LOG_THIS, "CGI pipe read error: $pipe_err");
						return true;
					}
					if ((last_pipe_err_time_read) && (time() - last_pipe_err_time_read >= CGI_MAX_RETRY_SECONDS)) {
						console.warn(LOG_THIS, "CGI pipe congestion");
						return true;
					}
					if (!last_pipe_err_time_read)
						last_pipe_err_time_read = time();
				}
			}
		}
		if (std_out_buffer) {
			if (stream) {
				var stream_write = true;
				try {
					if (h2headers) {
						var header_pos = Pos(std_out_buffer, "\r\n\r\n");
						if (header_pos > 0) {
							this.ParseHeaders(h2headers, SubStr(std_out_buffer, 0, header_pos));
							stream.Response(h2, h2headers);
							h2headers = null;
							std_out_buffer = SubStr(std_out_buffer, header_pos + 3);
						} else {
							if (!running) {
								// just dump the output ... no header was received
								stream.Response(h2, h2headers);
								h2headers = null;
							} else {
								// read 64k bytes, no header found
								if (length std_out_buffer >= MAX_RECV_BUFFER)
									return true;
								stream_write = false;
							}
						}
					}
					if (stream_write) {
						var close_stream = false;
						if ((!running) && (stream.AtomicWriteSize(length std_out_buffer) == length std_out_buffer))
							close_stream = true;
						res = stream.SafeWrite(h2, std_out_buffer, close_stream);
						if (res > 0) {
							std_out_buffer = SubStr(std_out_buffer, res);
							ops ++;
						}
					}
				} catch (exc) {
					return true;
				}
			} else
			if (Socket) {
				try {
					res = Socket.Write(std_out_buffer);
					if (res > 0) {
						std_out_buffer = SubStr(std_out_buffer, res);
						ops ++;
						if (length std_out_buffer > CGI_MAX_STDOUT_BUFFER) {
							console.info(LOG_THIS, "CGI stdout buffer overflow");
							return true;
						}
						last_err_time = 0;
					}
				} catch (exc) {
					// EAGAIN ?
					err = SocketErrno();
					if ((err != 11) && (err != 35) && (err != 10035))
						return true;

					if ((last_err_time) && (time() - last_err_time >= CGI_MAX_RETRY_SECONDS)) {
						console.warn(LOG_THIS, "CGI write congestion");
						return true;
					}
					if (!last_err_time)
						last_err_time = time();
				}
			}
		}
		if ((!std_out_buffer) && (!running)) {
			H2Close();
			return true;
		}
		return false;
	}

	IterateEventLoop(socket, loop, is_write) {
		if (is_write < 0)
			this.Close();
		else
		if (this.Iterate(null, is_write))
			return LOOP_EVENT_REMOVE;
	}

	static CreatePipes(var std_out_r, var std_out_w, var std_in_r, var std_in_w) {
		if (/*socketpair*/pipe(std_out_r, std_out_w)) {
			return -1;
		}
		if (/*socketpair*/pipe(std_in_r, std_in_w)) {
			close(std_out_r);
			close(std_out_w);
			return -1;
		}
		return 0;
	}

	finalize() {
		Close();
	}
}

class ContainerWorker extends Worker {
	var timestamp;
	var app;
	var idx;
	var[] cache;

	GetPath(filename) {
		var directory = http_directory(filename);
		if ((!ON_MSWINDOWS) && (filename) && (filename[0] == "/") && (directory[0] != "/"))
			return "/" + directory;

		return directory;
	}

	ContainerWorker(sharedcontext, app, var err) {
		super("web", this.GetPath(app), sharedcontext, app, err);
		this.timestamp = filelast_mod(app);
	}

	modified(timestamp) {
		return (this.timestamp != timestamp);
	}

	CacheData(data, priority) {
		if (priority < 0)
			cache = [data] + cache;
		else
			cache[length cache] = data;
	}

	SendCached() {
		if (cache) {
			this.AddData(BinarizeObject(cache));
			cache = new [];
		}
	}

	ClearCache() {
		cache = new [];
	}
}

class CGIAsyncWorker {
	static Create(cgiworkers, app, sharedcontext = null, var err = null) {
		var worker = cgiworkers[app];
		if (worker) {
			if (worker.modified(_filelast_mod(app))) {
				worker.AddData(BinarizeObject([["q" => "0", "do" => "drop"]]), -1);
				console.info(LOG_THIS, "$app changed, refreshing worker ...");
				worker.ClearCache();
				worker.Join();
				console.info(LOG_THIS, "done");
			} else
				return worker;
		}

		worker = new ContainerWorker(sharedcontext, app, err);
		if (err) {
			worker.Join();
			return worker;
		}
		cgiworkers[app] = worker;
		return worker;
	}
}

class IniCache {
	public var IniFile;
	protected var[] inicache;
	protected var inicachetimeout;

	public var ConceptClient=".ConceptClient.js";

	IniGetPath(category, key, default_value = "") {
		var cachekey = "$key[$category]";
		if (time() > inicachetimeout) {
			inicachetimeout = time() + INI_CACHE_TIMEOUT_S;
			inicache = new [];
		} else {
			var cache = inicache[cachekey];
			if (cache)
				return cache;
		}
		var res = trim(IniGet(IniFile, category, key, default_value));
		if (res[0] == ".")
			res = getcwd() + "/" + res;
		inicache[cachekey] = res;
		return res;
	}

	IniKey(category, key, default_value = "") {
		var cachekey = "$key[$category]";
		if (time() > inicachetimeout) {
			inicachetimeout = time() + INI_CACHE_TIMEOUT_S;
			inicache = new [];
		} else {
			var cache = inicache[cachekey];
			if (cache)
				return cache;
		}
		var res = trim(IniGet(IniFile, category, key, default_value));
		inicache[cachekey] = res;
		return res;
	}
}

class ConceptBaseWorker {
	protected var[] cgiworkers;
	protected var[] childcache;
	protected var cacheholders;

	UpdateChildCache(children) {
		var[] new_cache;
		for (var i = 0; i < length children; i++){ 
			var cgi = children[i];
			if ((cgi) && (cgi.reqid))
				new_cache[cgi.reqid] = cgi;
		}
		childcache = new_cache;
		cacheholders = 0;
	}

	ClearCache(child) {
		if ((child) && (child.reqid)) {
			if (IsSet(childcache, child.reqid)) {
				childcache[child.reqid] = null;
				cacheholders ++;
			}
		}
	}

	IterateAsyncWorkers(children) {
		if (cacheholders > 100)
			this.UpdateChildCache(children ?? childcache);

		var workers = cgiworkers;
		if (!workers)
			return 0;

		var ops = 0;
		var removed_workers = 0;
		for (var i = 0; i < length workers; i++) {
			var worker = workers[i];
			if (worker) {
				var worker_get = worker.GetResult(var data_arr);
				if ((data_arr) && (worker_get > 0)) {
					data_arr = UnBinarizeObject(data_arr);
					for (var j = 0; j < length data_arr; j++) {
						var data = data_arr[j];
						if (data) {
							ops++;
							var request = data["q"];
							if ((request) && (typeof request == "string")) {
								var child = childcache[request];
								if (child)
									child.onmessage(data);
							} else
							if (data["do"] == "drop") {
								ops++;
								worker.ClearCache();
								worker.Join();
								workers[i] = null;
								removed_workers ++;
							}
						}
					}
				} else
				if (worker_get) {
					ops++;
					worker.ClearCache();
					worker.Join();
					workers[i] = null;
					removed_workers ++;
				}
				worker.SendCached();
			}
		}
		if (removed_workers) {
			var new_workers = new [];
			for (i = 0; i < length workers; i++) {
				worker = workers[i];	
				if (worker)
					new_workers[length new_workers] = worker;
			}
			cgiworkers = new_workers;
		}
		return ops;
	}
}

class WDataContainer {
pragma used
	var socket;
	var app;
	var headers;
	var tls;
	var query;
	var snippet;
	var method;
	var hostname;
	var path;
	var port;
	var cgihandler;
	var root;
	var javascript;

	WDataContainer(socket, app, var headers, var query, var snippet, method, hostname, path, port, cgihandler, root, javascript = false) {
		this.socket = socket.Socket;
		this.app = app;
		this.headers = headers;
		this.query = query;
		this.snippet = snippet;
		this.method = method;
		this.hostname = hostname;
		this.path = path;
		this.port = port;
		this.cgihandler = cgihandler;
		this.root = root;
		this.javascript = javascript;
		if (classof socket == "TLSESocket") {
			tls = socket.Save();
			socket.Done();
		}
		socket.Socket = -1;
	}
}

class ConceptWorker extends ConceptBaseWorker {
pragma used
	protected var WorkerName;
	protected var[] Children;
	protected var Placeholders;
	protected var Framework = "";

	CreateEnv(Socket, job, scriptname = "javascript") {
		var info = Socket.Info;
		var address = info["address"];
		var port = info["port"];

		var headers = job.headers;
		var env = [
				"DOCUMENT_ROOT": job.root,
				"GATEWAY_INTERFACE": "CGI/1.1",
				"HTTP_COOKIE": headers["cookie"] ?? "",
				"HTTP_HOST": job.hostname,
				"HTTP_USER_AGENT": headers["user-agent"] ?? "",
				"PATH_INFO": job.path,
				"PATH_TRANSLATED": job.app,
				"QUERY_STRING": job.query,
				"REMOTE_ADDR": address,
				"REMOTE_HOST": address,
				"REMOTE_PORT": port,
				"REMOTE_USER": "",
				"REQUEST_METHOD": job.method,
				"REQUEST_URI": job.path,
				"SCRIPT_FILENAME":  job.app,
				"SCRIPT_NAME": scriptname,
				"SERVER_ADMIN": "",
				"SERVER_NAME": job.hostname,
				"SERVER_PORT": job.port,
				"SERVER_PROTOCOL": "HTTP/1.1",
				"SERVER_SOFTWARE":  SERVER_SOFTWARE,
				"REDIRECT_STATUS": 200,
				"REDIRECT_STATUS": "CGI",
				"CONTENT_LENGTH": headers["content-length"] ?? "",
				"CONTENT_TYPE": headers["content-type"] ?? "",
				"HTTP_ACCEPT_LANGUAGE": headers["accept-language"] ?? "",
				"HTTP_ACCEPT_ENCODING": headers["accept-encoding"] ?? "",
				"HTTP_REFERER": headers["referer"] ?? ""
		];
		if (classof Socket == "TLSESocket") {
			env["HTTPS"] = "on";
			env["HTTPS_CIPHER"] = Socket.CipherName;
		}
		return env;
	}

	CreateJavascript(Socket, job) {
		var env = this.CreateEnv(Socket, job);
		return new ConceptJSChild(null, this.Framework, job.method, Socket, env, job.snippet, null, null, null, job.headers);
	}

	CreateCAS(Socket, job) {
		var env = this.CreateEnv(Socket, job, "conceptasync");
		var cgi = new ConceptCASChild(null, CGIAsyncWorker::Create(this.cgiworkers, job.app, null, var err), err, job.method, Socket, env, job.snippet, null, null, null, job.headers);
		if (cgi.reqid)
			this.childcache[cgi.reqid] = cgi;
		return cgi;
	}

	Create(Socket, job) {
		if (job.javascript == 2)
			return CreateCAS(Socket, job);
		if (job.javascript)
			return CreateJavascript(Socket, job);


		if (ConceptCGIChild::CreatePipes(var std_out_r, var std_out_w, var std_in_r, var std_in_w))
			return null;

		var cgi_handler_path = job.cgihandler;

		var info = Socket.Info;
		var address = info["address"];
		var port = info["port"];
		var headers = job.headers;
		var env = [
				"DOCUMENT_ROOT=" + job.root,
				"GATEWAY_INTERFACE=CGI/1.1",
				"HTTP_COOKIE=" + (headers["cookie"] ?? ""),
				"HTTP_HOST=" + job.hostname,
				"HTTP_USER_AGENT=" + (headers["user-agent"] ?? ""),
				"PATH_INFO=" + job.path,
				"PATH_TRANSLATED=" + job.app,
				"QUERY_STRING=" + job.query,
				"REMOTE_ADDR=" + address,
				"REMOTE_HOST=" + address,
				"REMOTE_PORT=" + port,
				"REMOTE_USER=",
				"REQUEST_METHOD=" + job.method,
				"REQUEST_URI=" + job.path,
				"SCRIPT_FILENAME=" + job.app,
				"SCRIPT_NAME=" + cgi_handler_path,
				"SERVER_ADMIN=",
				"SERVER_NAME=" + job.hostname,
				"SERVER_PORT=" + job.port,
				"SERVER_PROTOCOL=HTTP/1.1",
				"SERVER_SOFTWARE=" + SERVER_SOFTWARE,
				"REDIRECT_STATUS=200",
				"REDIRECT_STATUS=CGI",
				"CONTENT_LENGTH=" + (headers["content-length"] ?? ""),
				"CONTENT_TYPE=" + (headers["content-type"] ?? ""),
				"HTTP_ACCEPT_LANGUAGE=" + (headers["accept-language"] ?? ""),
				"HTTP_ACCEPT_ENCODING=" + (headers["accept-encoding"] ?? ""),
				"HTTP_REFERER=" + (headers["referer"] ?? "")
		];
		if (classof Socket == "TLSESocket") {
			env[length env] = "HTTPS=on";
			env[length env] = "HTTPS_CIPHER=" + Socket.CipherName;
		}

		var pid = ExecuteProcess(cgi_handler_path, "", [job.app], env, false, std_out_w, std_in_r);

		close(std_out_w);
		close(std_in_r);

		if (pid <= 0) {
			close(std_out_r);
			close(std_in_w);
			return null;
		}
		return new ConceptCGIChild(null, job.method, Socket, std_out_r, std_in_w, pid, job.snippet);
	}

	AddChild(child) {
		if (Placeholders > 0) {
			for (var i = 0; i < length Children; i++) {
				if (!Children[i]) {
					Children[i] = child;
					Placeholders--;
					return;
				}
			}
		}
		Children[length Children] = child;
	}

	Clean() {
		if (Placeholders < 10)
			return;

		var new_children = new [];
		var children = this.Children;
		this.Children = new_children;
		if (Placeholders == length children) {
			Placeholders = 0;
			return;
		}

		for (var i = 0; i < length children; i++) {
			var child = children[i];
			if (child)
				new_children[length new_children] = child;
		}
		Placeholders = 0;
	}

	Iterate() {
		var children = this.Children;
		var res = 0;
		for (var i = 0; i < length children; i++) {
			var child = children[i];
			if (child) {
				if (child.Iterate(res)) {
					child.Close();
					children[i] = null;
					this.ClearCache(child);
					Placeholders ++;
				}
			}
		}
		this.IterateAsyncWorkers(children);
		if (Placeholders >= 50)
			this.Clean();
		return res;
	}

	static RealPath(path) {
		var res = "";
		var arr = StrSplit(path, "/");
		for (var i = length arr - 1; i >= 0; i--) {
			var e = arr[i];
			if (e == "..") {
				i--;
			} else {
				if (res)
					res = arr[i] + "/" + res;
				else
					res = arr[i];
			}
		}
		return res;
	}

	static IniGetPath(inifile, category, key, default_value = "") {
		var res = trim(IniGet(inifile, category, key, default_value));
		if (res[0] == ".")
			return getcwd() + "/" + res;
		return res;
	}

	Loop(var empty_iterations, var sleep_value) {
		var work_count = 0;
		if (Worker::PendingAll(var data, sleep_value, 100)) {
			for (var i = 0; i < length data; i++) {
				work_count++;
				var job = UnBinarizeObject(data[i]);
				if (job) {
					if (Pos(job.app, ".."))
						job.app = this.RealPath(StrReplace(job.app, "\\", "/"));
					var Socket;
					try {
						if (job.tls) {
							Socket = new TLSESocket(job.socket);
							Socket.Restore(job.tls);
						} else
							Socket = new TCPSocket(job.socket);
						var child = this.Create(Socket, job);
						if (child) {
							if (!job.javascript)
								Socket.Write("HTTP/1.1 200 OK\r\nServer: " + SERVER_NAME + "\r\n");
							AddChild(child);
						} else {
							Socket.Write("HTTP/1.1 503 Service unavailable\r\nServer: " + SERVER_NAME + "\r\nContent-Type: text/html\r\n\r\n<html><head><title>HTTP 503 Service unavailable</title></head><body><h1>HTTP 503 Service unavailable</h1><br/></body></html>");
							Socket.Close(true);
						}
					} catch (var exc) {
						console.debug(LOG_THIS, "Exc: $exc");
						delete Socket;
					}
				}
			}
		}
		work_count += this.Iterate();
		if (work_count) {
			empty_iterations = 0;
			sleep_value = 0;
		} else {
			empty_iterations++;
			if (empty_iterations > IDLE_SLEEP_THRESHOLD)
				sleep_value = IDLE_SLEEP_MS2;
			else
				sleep_value = IDLE_SLEEP_MS;
		}
	}

	ConceptWorker(n) {
		n = UnBinarizeObject(n);
		WorkerName = n[0];
		Framework = this.IniGetPath(n[1], "Paths", "Include") + JS_FRAMEWORK;
		var empty_iterations;
		var sleep_value;
		while (true)
			Loop(empty_iterations, sleep_value);
	}
}

class ConceptChild {
	protected var Socket;
	protected var Owner;
	private var Key = "";
	public var PID;
	public var DirectPipe=-1;

	public var Session = "";
	public var APID;
	public var Hash;

	public var PipeIn = -1;
	public var PipeOut = -1;
	public var Parent = -1;
	
	public var ContextIn = -1;
	public var ContextOut = -1;

	private var APIDBuf = "";
	private var MaxBuffer = 0;

	public var HostID = "";
	public var UsingHost = -1;
	public var UsingPID = -1;
	public var ChildCount = 0;

	public var Timestamp;
	public var MaxChilds = 0;
	public var TLS;

	protected var apidbuf = "";
	protected var apid_err;
	protected var processed_buffer = "";

	protected var Running;
	protected var disconnected = false;
	protected var max_iap;

	var ip;

	ConceptChild(owner, socket, tls_data, session = "") {
		this.Owner = owner;
		this.Socket = new TCPSocket(socket);
		this.TLS = tls_data;
		this.Session = session ?? "";
		max_iap = value this.Owner.IniKey("Server", "MaxInterAppMessageBuffer", "1024");
		Owner.ClientCount ++;
	}

	Invalidate(p) {
		this.HostID = "";
		console.error(LOG_THIS, "Process crashed (error: ${_errno()}, pipe: $p)");
		if (this.ContextOut>0)
			close(this.ContextOut);

		this.ContextOut = -1;
		return -1;
	}

	Send(var data) {
		if ((this.MaxBuffer <= 0) || (length APIDBuf + length data <= this.MaxBuffer)) {
			APIDBuf+=data;
			return true;
		}
		return false;
	}

	RemoveChild(app_id, ip) {
		var client = this.Owner.GetConnection(app_id);
		if (client) {
			this.ChildCount--;
			// don't accept any more connections
			if (this.ChildCount <= 0)
				this.HostID = "";

			if (client==this) {
				return true;
			} else {
				this.Owner.Connections[""+app_id] = null;
				this.Owner.PlaceHolders++;
				client.PID = -3;
				// return true;
			}
		} else
			console.warn(LOG_THIS, "$ip:Invalid APID: $app_id");
		return false;
	}

	AddChild(pr2, shared_key, pipein1, pipeout2, direct_pipe, pid=null) {
		if (write(pr2, tobin(this.APID, 32)) != 4)
			return this.Invalidate(pr2);

		if (write(pr2, tobin(this.Parent, 32)) != 4)
			return this.Invalidate(pr2);
		if (pid)
			DescriptorWrite(pr2, Socket.Socket, pid);
		else
			DescriptorWrite(pr2, Socket.Socket);

		var d1 = Duplicate(pipein1, pid);
		var d2 = Duplicate(pipeout2, pid);
		var d3 = Duplicate(direct_pipe, pid);

		// problems on windows
		if ((d1 < 0) || (d2 < 0) || (d3 < 0)) {
			d1 = -1;
			d2 = -1;
			d3 = -1;
			if (this.DirectPipe>0)
				close(this.DirectPipe);
		}
		DescriptorWrite(pr2, d1);
		DescriptorWrite(pr2, d2);
		DescriptorWrite(pr2, d3);

		if (shared_key) {
			if (write(pr2, tobin(length shared_key, 32)) != 4)
				return this.Invalidate(pr2);
			if (write(pr2, shared_key) != length shared_key)
				return this.Invalidate(pr2);
		} else {
			if (write(pr2, tobin(0, 32)) != 4)
				return this.Invalidate(pr2);

			var shared_key2=this.Key;
			if (write(pr2, tobin(length shared_key2, 32)) != 4)
				return this.Invalidate(pr2);
			if (shared_key2) {
				if (write(pr2, shared_key2) < 0)
					return this.Invalidate(pr2);
			}
		}
		return 0;
	}

	RunApplication(headers, fname, multiple_host = true) {
		if (fname == "/")
			fname="";

		var shared_key = "";
		if (!fname)
			fname = "start.con";

		var arguments = headers[":query"] ?? "";
		var hash_base = "";
		var server_name = "";

		ip = "unknown";
		var port = -1;

		var info = Socket.Info;
		if (info) {
			ip=info["address"];
			port=info["port"];
		}

		if (!FileExists(fname))
			throw "File '$fname' does not exists\n";

		if (CONCEPT_STRICT_EXECUTE) {
			if (!FileExists(fname + ".accel"))
				throw "File '$fname' has no compiled version\n";
		}

		if (!this.APID) {
			Owner.APID++;
			if (Owner.APID > 0x7FFFFFFF)
				Owner.APID = 1;
			this.APID = Owner.APID;
		}

		var log_str="$fname";
		if (arguments)
			log_str+="("+arguments+")";
		if (server_name)
			console.log(LOG_THIS, "$ip: Using server ${server_name}, APID: "+this.APID);
		console.info(LOG_THIS, "$ip:Run $log_str");


		var cwd = getcwd();
		var shared_pool = value Owner.IniKey("Server", "UseSharedMemoryPool", "0");
		var inc_dir = this.Owner.IniGetPath("Paths", "Include") + "/";
		var lib_dir = this.Owner.IniGetPath("Paths", "Library") + "/";
		var safe_run = this.Owner.IniGetPath("Paths", "SafeMode", "runsafe");

		var direct_pipe1=-1;
		var direct_pipe2=-1;

		if (DirectPipe==-1) {
			if (socketpair(direct_pipe1, direct_pipe2)) {
				console.warn(LOG_THIS, "$ip:Error creating direct pipe (${_errno()}), APID: "+this.APID);
			} else {
				DirectPipe=direct_pipe2;
				if (SetNonBlocking(direct_pipe2, true))
					console.warn(LOG_THIS, "$ip:Cannot set non-blocking pipe (${_errno()}), APID: "+this.APID);
			}
		}
		var pipein1=-1;
		var pipein2=-1;

		var pipeout1=-1;
		var pipeout2=-1;

		if (this.PipeOut == -1) {
			if (pipe(pipein1, pipein2)) {
				console.error(LOG_THIS, "$ip:Error creating in pipe (${_errno()}), APID: "+this.APID);
			} else {
				this.PipeOut = pipein2;
				if (SetNonBlocking(pipein2, true))
					console.error(LOG_THIS, "$ip:Cannot set non-blocking pipe (pipe in error: ${_errno()}), APID: "+this.APID);
			}
		}

		if (this.PipeIn == -1) {
			if (pipe(pipeout1, pipeout2))
				console.error(LOG_THIS, "$ip:Error creating out pipe (${_errno()}), APID: "+this.APID);
			else {
				this.PipeIn = pipeout1;
				if (SetNonBlocking(pipeout1, true))
					console.error(LOG_THIS, "$ip:Cannot set non-blocking pipe (pipe out error: ${_errno()}), APID: "+this.APID);
			}
		}

		var hostapp = null;
		var baseid = fname;
		var hostid = baseid;
		var debug = false;
		if (arguments) {
			if ((Pos(arguments, "parent=") == 1) || (Pos(arguments, "&parent=") > 1)) {
				var arg_p_arr = StrSplit(arguments, "parent=");
				if (arg_p_arr)
					this.Parent = value arg_p_arr[length arg_p_arr - 1];

				if ((Pos(arguments, "debug=") == 1) || (Pos(arguments, "&debug=") > 1)) {
					arg_p_arr = StrSplit(arguments, "debug=");
					if (arg_p_arr) {
						debug = value arg_p_arr[length arg_p_arr - 1];
						if (debug)
							multiple_host = false;
					}
				}
			}
		}

		if (multiple_host) {
			multiple_host = value IniGet(baseid + ".manifest", "Application", "Workers", "0");

			if (multiple_host == 1)
				multiple_host = 100;

			this.MaxChilds = multiple_host;
		}

		if (TLS) {
			shared_key = "----SSL DATA----" + TLS;
			TLS = "";
		}

		SocketSetBlocking(Socket.Socket, true);

		var server_root = Owner.IniGetPath("Paths", "ServerRoot", "");
		var host_root = headers[":root"] ?? server_root;
		this.Running = true;
		if ((debug) || (!multiple_host)) {
			var shared_hex = StringToHex(shared_key);
			this.PID = ExecuteProcess(safe_run, fname,
					// parameters
					["Direct pipe"	=> ""+direct_pipe1,
					 "Pipe in"	=> ""+pipein1,
					 "Pipe out"	=> ""+pipeout2,
					 "APID"		=> ""+this.APID,
					 "Parent"	=> ""+this.Parent,
					 "Filename"	=> fname,
					 "Socket"	=> ""+Socket.Socket,
					 "Include dir"	=> inc_dir,
					 "Library dir"	=> lib_dir,
					 "Public key"	=> StringToHex(this.Key),
					 "Private key"	=> shared_hex,
					 "Shared secret"=> shared_hex,
					 "Arguments"	=> arguments
					],

					// environment
					["CONCEPT_FILENAME=$fname",
					 "CONCEPT_HOSTROOT=$host_root",
					 "CONCEPT_SERVERNAME=$server_name",
					 "CONCEPT_INCLUDE=$inc_dir",
					 "CONCEPT_LIBRARY=$lib_dir",
					 "CONCEPT_ROOT=$server_root/",
					 "CONCEPT_DEBUG=$debug",
					 "CONCEPT_UseSharedMemoryPool=$shared_pool",
					 "CONCEPT_TLS=${this.TLS}",
					 "REMOTE_IP=$ip",
					 "REMOTE_PORT=$port",
					 "CONCEPT_WSPROTO=1",
					 "DRM_KEY=${this.Key}",
					 "CONCEPT_SERVERPATH="+cwd,
					 "CONCEPT_INIPATH=${Owner.IniFile}",
					 "CONCEPT_LOGFILE=${Owner.IniGetPath("Paths", "LogFile", "")}"
					],

					// don't wait
					false
			);
		} else {
			hostapp = this.Owner.GetHost(hostid);
		}

		if (hostapp) {
			hostapp.ChildCount++;
			this.UsingHost = hostapp.APID;
			this.UsingPID = hostapp.PID;

			if (AddChild(hostapp.ContextOut, shared_key, pipein1, pipeout2, direct_pipe1, hostapp.PID)) {
				hostapp.ChildCount--;
				hostapp.HostID = "";
				this.UsingHost = -1;
				this.PID = -1;
				return;
			}
			this.PID = -2;
		} else
		if (this.PID <= 0) {
			var pr1, pr2;
			var pw1, pw2;

			if (socketpair(pr1, pr2))
				console.warn(LOG_THIS, "$ip:Error creating in context socket pair (${_errno()}), APID: "+this.APID);
			if (socketpair(pw1, pw2))
				console.warn(LOG_THIS, "$ip:Error creating in context socket pair (${_errno()}), APID: "+this.APID);

			// leave it blocking !
			//if (SetNonBlocking(pr2, true))
			//	console.warn(LOG_THIS, "$ip:Cannot set non-blocking context (pipe out error: ${_errno()}), APID: "+this.APID);

			if (SetNonBlocking(pw1, true))
				console.warn(LOG_THIS, "$ip:Cannot set non-blocking context (pipe out error: ${_errno()}), APID: "+this.APID);

			if ((pr1 > 0) && (pw2 > 0)) {
				this.HostID = hostid;
				this.PID = ExecuteProcess(safe_run, host_root, [fname, inc_dir, lib_dir, "" + pr1, "" + pw2], 
					// environment
					["CONCEPT_FILENAME=$fname",
					 "CONCEPT_HOSTROOT=$host_root",
					 "CONCEPT_SERVERNAME=$server_name",
					 "CONCEPT_INCLUDE=$inc_dir",
					 "CONCEPT_LIBRARY=$lib_dir",
					 "CONCEPT_ROOT=$server_root/",
					 "CONCEPT_DEBUG=$debug",
					 "CONCEPT_UseSharedMemoryPool=$shared_pool",
					 "CONCEPT_TLS=${this.TLS}",
					 "REMOTE_IP=$ip",
					 "REMOTE_PORT=$port",
					 "CONCEPT_WSPROTO=1",
					 "DRM_KEY=${this.Key}",
					 "CONCEPT_SERVERPATH="+cwd,
					 "CONCEPT_INIPATH=${Owner.IniFile}",
					 "CONCEPT_LOGFILE=${Owner.IniGetPath("Paths", "LogFile", "")}"
					],

					// don't wait
					false
				);
				this.UsingPID = this.PID;
				this.ChildCount = 1;
				AddChild(pr2, shared_key, pipein1, pipeout2, direct_pipe1, this.UsingPID);

				close(pr1);
				close(pw2);

				this.ContextIn = pw1;
				this.ContextOut = pr2;

				this.Timestamp = time();
			}
		}

		if (((this.PID > 0) || (this.PID == -2)) && (this.APID > 0)) {
			Owner.Connections["" + this.APID] = this;
			this.Hash = Murmur(hash_base);
		}

		if (direct_pipe1 != -1)
			close(direct_pipe1);

		if (pipein1 != -1)
			close(pipein1);

		if (pipeout2 != -1)
			close(pipeout2);

		if (this.PID == -2) {
			console.info(LOG_THIS, "$ip:New child connection for $hostid");
		} else
		if (this.PID < 0) {
			console.warn(LOG_THIS, "$ip:Error creating child process");
			throw "Error creating child process";
		}
	}

	Iterate() {
		var apid = this.APID;
		var pipein = this.PipeIn;
		var pipeout = this.PipeOut;

		if ((this.ContextIn > 0) && (!disconnected)) {
			var r = read(this.ContextIn, var apidbuf2, 4);
			if (r > 0) {
				this.Owner.Iterations++;
				apidbuf += apidbuf2;
				if (length apidbuf>=4) {
					var app_id = tonumber(SubStr(apidbuf, 0, 4), 32);
					apidbuf = SubStr(apidbuf, 4, length apidbuf - 4);
					if (RemoveChild(app_id, ip)) {
						disconnected = true;
						pipein = -1;
						this.Disconnect("clean");
					}
					if (this.ChildCount <= 0) {
						this.HostID = "";
						// no children, unload from memory
						write(this.ContextOut, tobin(-1, 32));
					}
				}
			}
		}
		if (pipein > 0)  {
			while ((!apid_err) && (read(pipein, var buf, 0xFF) > 0)) {
				this.Owner.Iterations++;
				processed_buffer = this.Owner.ProcessMessage(apid, this.Hash, processed_buffer + buf, apid_err);
				if ((max_iap) && (length processed_buffer > max_iap))
					processed_buffer="";
			}
			var buf_out=this.APIDBuf;
			if (buf_out) {
				var len;
				if (length buf_out > 1024)
					len = write(pipeout, SubStr(buf_out, 0, 1024));
				else
					len = write(pipeout, buf_out);
				if (len>0)
					this.APIDBuf = SubStr(this.APIDBuf, len, length this.APIDBuf);
			}
		}
		if (this.Running) {
			if (this.PID > 0) {
				if (!ExecuteIsRunning(this.PID))
					this.Done();
			} else
			if (disconnected)
				this.Done();
		}
	}

	Done() {
		this.Running = false;
		var apid = this.APID;
		var pipein = this.PipeIn;
		if (this.Parent > 0)
			this.Owner.ProcessMessage(apid, this.Hash, tobin(this.Parent, 32) + tobin(-6, 32) + tobin(4, 32) + "done", apid_err);

		if (this.HostID)
			Owner.CloseChildren(apid);

		if (apid > 0) {
			RemoveChild(apid, ip);
			Owner.Connections["" + apid] = null;
			Owner.PlaceHolders ++;
		}

		if (this.PID > 0) {
			if (pipein > 0) {
				while (read(pipein, var buf, 0xFF) > 0) {
					processed_buffer = this.Owner.ProcessMessage(apid, this.Hash, processed_buffer + buf, apid_err);
					if (apid_err)
						break;
				}
			}
			var code = ExecuteJoin(this.PID);
			if (code)
				console.info(LOG_THIS, "$ip:$apid done (error code: $code)");
			else			
				console.info(LOG_THIS, "$ip:$apid done");
		} else
			console.info(LOG_THIS, "$ip:$apid Done (child)");
	}

	Disconnect(reason = "") {
		if (this.DirectPipe > 0) {
			close(this.DirectPipe);
			this.DirectPipe = -1;
		}
		if (this.PipeIn > 0) {
			close(this.PipeIn);
			this.PipeIn = -1;
		}
		if (this.PipeOut > 0) {
			close(this.PipeOut);
			this.PipeOut = -1;
		}

		if (this.Socket) {
			if (reason)
				reason = " " + reason;
			console.info(LOG_THIS, "$ip:Disconnected(${this.Socket.Socket}, ${this.APID}$reason)");
			SocketSetBlocking(this.Socket.Socket, false);
			this.Socket.Close(true);
		}
	}

	finalize() {
		Owner.ClientCount--;
		console.trace(LOG_THIS, "${Owner.ClientCount} active client(s)");
		Owner.Clean();
	}
}

class ConceptAppWorker extends IniCache {
	public var ClientCount = 0;
	public var[] Connections;
	public var PlaceHolders;
	public var Iterations;
	public var APID;

	public GetHost(host) {
		var clients=this.Connections;
		var len=length clients;
		for (var i=0;i<len;i++) {
			var c=clients[i];
			if ((c) && (c.HostID == host) && (c.ChildCount < c.MaxChilds) && (c.ChildCount >= 0))
				return c;
		}
		return null;
	}

	public CloseChildren(apid) {
		var clients = this.Connections;
		var len = length clients;
		for (var i = 0; i < len; i++) {
			var c = clients[i];
			if ((c) && (c.UsingHost == apid))
				c.PID = -3;
		}
	}

	public GetConnection(apid) {
		var key=""+apid;
		if (IsSet(this.Connections, key))
			return this.Connections[key];
		return null;
	}

	public GetSession(session) {
		var clients = this.Connections;
		var len = length clients;
		for (var i = 0; i < len; i ++) {
			var c = clients[i];
			if ((c) && (c.Session == session))
				return c;
		}
		return null;
	}

	RouteMessage(source_apid, hash, apid, msg_id, msg, var err) {
		if (apid>0) {
			var connection=this.GetConnection(apid);
			if (connection) {
				this.Iterations++;
				var buf=tobin(source_apid, 32)+tobin(msg_id, 32)+tobin(length msg, 32)+msg;
				connection.Send(buf);
			} else {
				console.warn(LOG_THIS, "Unknown APID: $apid (message sent by $source_apid)");
				err = true;
			}
		} else {
			this.Iterations++;
			buf=tobin(source_apid, 32)+tobin(msg_id, 32)+tobin(length msg, 32)+msg;

			var clients=this.Connections;
			var len=length clients;
			for (var i=0;i<len;i++) {
				connection=clients[i];
				if ((connection) && (connection.APID!=source_apid) && (connection.Hash==hash))
					connection.Send(buf);
			}
		}
	}

	ProcessMessage(apid, hash, var buf, var err) {
		err = false;
		while ((true) && (!err)) {
			var lbuf = length buf;
			if (lbuf >= 12) {
				var target_apid=tonumber(buf[0]+buf[1]+buf[2]+buf[3], 32);
				var msg_id=tonumber(buf[4]+buf[5]+buf[6]+buf[7], 32);
				var len=tonumber(buf[8]+buf[9]+buf[10]+buf[11], 32);
				if (lbuf >= len + 12) {
					var msg = SubStr(buf, 12, len);
					buf = SubStr(buf, 12 + len, lbuf);
					this.RouteMessage(apid, hash, target_apid, msg_id, msg, err);
				} else
					break;
			} else
				break;
		}
		return buf;
	}

	public Clean() {
		if (this.PlaceHolders >= 50) {
			this.PlaceHolders = 0;
			var clients = this.Connections;
			var len = length clients;
			var res = new [];
			var cleaned = 0;
			for (var i = 0;i < len;i ++) {
				var c = clients[i];
				if (c)
					res["" + c.APID] = c;
				else
					cleaned ++;
			}
			if (cleaned) {
				console.trace(LOG_THIS, "$cleaned placeholders cleaned");
				this.Connections = res;
			}
		}
	}

	Iterate() {
		this.Iterations = 0;
		for (var i = 0; i < length this.Connections; i ++) {
			var child = this.Connections[i];
			if (child) {
				try {
					child.Iterate();
				} catch (var exc) {
					console.warn(LOG_THIS, exc);
					child.Done();
					this.Connections[i] = null;
				}
			}
		}
		this.Clean();
		return this.Iterations;
	}

	GetCookie(key, cookie_str) {
		var arr = StrSplit(cookie_str, ";");
		for (var i = 0; i < length arr; i++) {
			var k = arr[i];
			var a2 = StrSplit(k, "=");
			if ((a2) && (length a2 == 2)) {
				if (trim(a2[0]) == key)
					return trim(a2[1]);
			}
		}
		return "";
	}

	Restore(child, tls, socket) {
		if ((child) && (child.DirectPipe > 0)) {
			var size = DescriptorWrite(child.DirectPipe, this.Socket.Socket, child.UsingPID);
			if (size > 0) {
				var buf = "";
				var tls_buf = "";
				if (tls)
					tls_buf = tls;
				buf = pack("U32", length tls_buf) + tls_buf;

				while (buf) {
					var written = write(child.DirectPipe, buf);
					if (written <= 0) {
						console.warn(LOG_THIS, "Error in DirectPipe write");
						return false;
					}

					buf = SubStr(buf, written);
				}
				child.Socket = new TCPSocket(socket);
				return true;
			}
		}
		return false;
	}

	ConceptAppWorker(ini_file) {
		this.IniFile = ini_file;
		var sleep_value = 50;
		while (true) {
			var child;
			if (Worker::PendingAll(var data, sleep_value, 100)) {
				for (var i = 0; i < length data; i++) {
					var job = UnBinarizeObject(data[i]);
					if (job) {
						switch (job["job"]) {
							case 1:
								try {
									var headers = job["headers"];
									var socket = job["socket"];
									if ((WS_SESSION_RESTORE) && (headers) && (job["tls"])) {
										var sec_websocket_protocol = headers["sec-websocket-protocol"];
										if ((sec_websocket_protocol) && (sec_websocket_protocol == "restore")) {
											var cookies = headers["cookie"];
											if (cookies) {
												var session_to_restore = "";
												var cookie = this.GetCookie("_s", cookies);
												if (cookie)
													session_to_restore = cookie;

												if (session_to_restore) {
													child = this.GetSession(session_to_restore);
													if ((child) && (child.DirectPipe > 0)) {
														this.Restore(child, job["tls_data"], socket);
														console.log(LOG_THIS, "session $session_to_restore restored");
													} else {
														console.log(LOG_THIS, "invalid session to restore: $session_to_restore");
														SocketSetBlocking(socket, false);
														SocketClose(socket, true);
													}
													continue;
												}
											}
										}
									}
									child = new ConceptChild(this, socket, job["tls_data"], job["session"]);
									child.RunApplication(headers, job["filename"]);
									Connections[length Connections] = child;
								} catch (var exc) {
									console.error(LOG_THIS, exc);
								}
								break;
							default:
								console.error(LOG_THIS, "unknown job type: " + job["job"]);
						}
					}
					i ++;
				}
			}
			if (this.Iterate())
				sleep_value = 5;
			else
				sleep_value = 50;
		}
	}
}

class ConceptH2Worker extends ConceptBaseWorker {
pragma used
	protected var CGIPlaceholders;
	protected var Framework;

	GetHeader(key, headers) {
		if ((!headers) || (!IsSet(headers, key)))
			return "";
		var val = headers[key];
		if (typeof val == "array") {
			var res = "";
			for (var i = 0; i < length val; i++) {
				if (res)
					res += ";";
				res += val[i];
			}
			return res;
		}
		return val;
	}

	CreateEnv(Socket, stream, method, root, path, app, query, hostname, local_port, default_header, scriptname = "javascript") {
		var info = Socket.Info;
		var address = info["address"];
		var port = info["port"];
		var headers = stream.Headers;

		var env = [
				"DOCUMENT_ROOT": root,
				"GATEWAY_INTERFACE": "CGI/1.1",
				"HTTP_COOKIE": this.GetHeader("cookie", headers),
				"HTTP_HOST": hostname,
				"HTTP_USER_AGENT": this.GetHeader("user-agent", headers),
				"PATH_INFO": path,
				"PATH_TRANSLATED": app,
				"QUERY_STRING": query,
				"REMOTE_ADDR": address,
				"REMOTE_HOST": address,
				"REMOTE_PORT": port,
				"REMOTE_USER": "",
				"REQUEST_METHOD": method,
				"REQUEST_URI": path,
				"SCRIPT_FILENAME":  app,
				"SCRIPT_NAME": scriptname,
				"SERVER_ADMIN": "",
				"SERVER_NAME": hostname,
				"SERVER_PORT": local_port,
				"SERVER_PROTOCOL": "HTTP/2.0",
				"SERVER_SOFTWARE":  SERVER_SOFTWARE,
				"REDIRECT_STATUS": 200,
				"REDIRECT_STATUS": "CGI",
				"CONTENT_LENGTH": this.GetHeader("content-length", headers),
				"CONTENT_TYPE": this.GetHeader("content-type", headers),
				"HTTP_ACCEPT_LANGUAGE": this.GetHeader("accept-language", headers),
				"HTTP_ACCEPT_ENCODING": this.GetHeader("accept-encoding", headers),
				"HTTP_REFERER": this.GetHeader("referer", headers)
		];
		if (classof Socket == "TLSESocket") {
			env["HTTPS"] = "on";
			env["HTTPS_CIPHER"] = Socket.CipherName;
		}
		return env;
	}

	CreateJavascript(Socket, h2, stream, method, root, path, app, query, hostname, local_port, default_header) {
		var env = CreateEnv(Socket, stream, method, root, path, app, query, hostname, local_port, default_header);
		return new ConceptJSChild(this, this.Framework, method, Socket, env, "", h2, stream, default_header);
	}

	CreateCAS(Socket, h2, stream, method, root, path, app, query, hostname, local_port, default_header) {
		var env = CreateEnv(Socket, stream, method, root, path, app, query, hostname, local_port, default_header, "conceptasync");
		var cgi = new ConceptCASChild(this, CGIAsyncWorker::Create(this.cgiworkers, app, null, var err), err, method, Socket, env, "", h2, stream, default_header);
		if (cgi.reqid)
			this.childcache[cgi.reqid] = cgi;
		return cgi;
	}

	CreateCGI(h2, stream, cgi_handler_path, root, path, app, query, hostname, local_port, javascript, default_header) {
		var cgi;
		var headers = stream.Headers;
		var Socket = h2.GetSocket();

		if (javascript == 2) {
			cgi = this.CreateCAS(Socket, h2, stream, this.GetHeader(":method", headers) ?? "GET", root, path, app, query, hostname, local_port, default_header);
			h2.UserData++;
			return cgi;
		} else
		if (javascript) {
			cgi = this.CreateJavascript(Socket, h2, stream, this.GetHeader(":method", headers) ?? "GET", root, path, app, query, hostname, local_port, default_header);
			h2.UserData++;
			return cgi;
		}

		if (ConceptCGIChild::CreatePipes(var std_out_r, var std_out_w, var std_in_r, var std_in_w))
			return null;

		var info = Socket.Info;
		var address = info["address"];
		var port = info["port"];
		var method = this.GetHeader(":method", headers) ?? "GET";
		var env = [
				"DOCUMENT_ROOT=" + root,
				"GATEWAY_INTERFACE=CGI/1.1",
				"HTTP_COOKIE=" + this.GetHeader("cookie", headers),
				"HTTP_HOST=" + hostname,
				"HTTP_USER_AGENT=" + this.GetHeader("user-agent", headers),
				"PATH_INFO=" + path,
				"PATH_TRANSLATED=" + app,
				"QUERY_STRING=" + query,
				"REMOTE_ADDR=" + address,
				"REMOTE_HOST=" + address,
				"REMOTE_PORT=" + port,
				"REMOTE_USER=",
				"REQUEST_METHOD=" + method,
				"REQUEST_URI=" + path,
				"SCRIPT_FILENAME=" + app,
				"SCRIPT_NAME=" + cgi_handler_path,
				"SERVER_ADMIN=",
				"SERVER_NAME=" + hostname,
				"SERVER_PORT=" + local_port,
				"SERVER_PROTOCOL=HTTP/2.0",
				"SERVER_SOFTWARE=" + SERVER_SOFTWARE,
				"REDIRECT_STATUS=200",
				"REDIRECT_STATUS=CGI",
				"CONTENT_LENGTH=" + this.GetHeader("content-length", headers),
				"CONTENT_TYPE=" + this.GetHeader("content-type", headers),
				"HTTP_ACCEPT_LANGUAGE=" + this.GetHeader("accept-language", headers),
				"HTTP_ACCEPT_ENCODING=" + this.GetHeader("accept-encoding", headers),
				"HTTP_REFERER=" + this.GetHeader("referer", headers)
		];

		if (classof Socket == "TLSESocket") {
			env[length env] = "HTTPS=on";
			env[length env] = "HTTPS_CIPHER=" + Socket.CipherName;
		}

		var pid = ExecuteProcess(cgi_handler_path, "", [app], env, false, std_out_w, std_in_r);

		close(std_out_w);
		close(std_in_r);

		if (pid <= 0) {
			close(std_out_r);
			close(std_in_w);
			return null;
		}

		cgi = new ConceptCGIChild(this, method, Socket, std_out_r, std_in_w, pid, "", h2, stream);
		if (cgi) {
			cgi.h2headers = default_header;
			h2.UserData++;
		}
		return cgi;
	}

	ConceptH2Worker(owner) {
		Framework = owner.IniGetPath("Paths", "Include") + JS_FRAMEWORK;
	}
}

class ConceptServer extends IniCache {
	var httpserver;
	var ClientCount;
	var appworker;
	var h2worker;
	var LogRequests = true;
	var[] Workers;
	var TargetWorker = 0;
	var port;
	var tlsport;
	var cgi;
	var[] cgiother;

	get_root_by_host(host) {
		return this.IniKey("Paths", "HostRoot($host)", "");
	}

	function log_request(http_version, tls, method, headers, socket, extra = "") {
		if (!headers)
			return;
		socket = socket.Socket;
		var info = socket.Info;
		if (extra)
			extra = " " + extra;
		if (tls)
			console.info(info[0], info[1], "hs${http_version} $method ${headers[":path"]}$extra");
		else
			console.info(info[0], info[1], "h$http_version $method ${headers[":path"]}$extra");
	}

	GenerateSession(string seed = "") {
		var common = sha256(CryptoRandom(80));
		if (seed)
			return SubStr(seed, 0, length seed - length common) + common;
		return sha1(""+NumberToHex(ClsPtr(this))+"#"+CryptoRandom(80)) + "-" + common;
	}

	static WorkerCount(workers_count) {
		var cgi_workers = _floor(sysconf(_SC_NPROCESSORS_ONLN) / 2);
		if (cgi_workers > workers_count)
			workers_count = cgi_workers;
		return workers_count;
	}

	ChooseWorker() {
		if (Workers) {
			if (TargetWorker >= length Workers)
				TargetWorker = 0;
			return Workers[TargetWorker++];
		}
		return null;
	}

	getPort(tls = false) {
		if (tls)
			return this.tlsport;
		return this.port;
	}

	ConceptServer(ini_file) {
		this.IniFile = ini_file;

		var user = this.IniKey("Server", "User", "concept");
		var pwd  = this.IniKey("Server", "UserPassword", "");

		if (!SetCurrentUser(user, pwd))
			console.warn(LOG_THIS, "cannot change user to $user");
		pwd = "";

		var log_file = this.IniGetPath("Paths", "LogFile", "");
		if (log_file)
			console.use_file(log_file);

		var max_connections = value this.IniKey("Server", "MaxConnections", "1024");
		var max_fd = max_connections * 5 + 10;
		if (setrlimit(RLIMIT_NOFILE, max_fd)) {
			// try to set it as super user
			if (setrlimit(RLIMIT_NOFILE, max_fd, max_fd))
				console.warn(LOG_THIS, "cannot set the maximum connection count to $max_fd");
		}

		this.cgi = this.IniGetPath("Paths", "CGIHandler", "conceptcgi");
		var cgi_other = this.IniKey("Paths", "OtherCGI", "");
		if (cgi_other) {
			var arr = StrSplit(cgi_other, ";");
			for (var i = 0; i < length arr; i++) {
				var e = StrSplit("" + arr[i], "=");
				var type = trim(e[0]);
				var val = trim(e[1]);
				if ((length e == 2) && (type) && (val))
					this.cgiother[type] = val;
			}
		}

		h2worker = new ConceptH2Worker(this);
		appworker = new Worker("ConceptAppWorker", ini_file);

		var workers_count = this.WorkerCount(DEFAULT_CGI_WORKERS);
		console.info(LOG_THIS, "Initializing $workers_count CGI workers");

		for (i = 0; i < workers_count; i++)
			Workers[i] = new Worker("ConceptWorker", BinarizeObject(["Worker${i+1}", ini_file]));

		port = value this.IniKey("Server", "WebPort", "2680");
		tlsport = value this.IniKey("Server", "SecureWebPort", "2681");
		httpserver = new H2Server(this.IniGetPath("Paths", "ServerRoot", ""), get_root_by_host, this.IniKey("Server", "WebSocketCertificate", ""), this.IniKey("Server", "WebSocketPrivateKey", ""), port, tlsport, value this.IniKey("Server", "MaxAge", "604800"), value this.IniKey("Server", "MaxInitialIDLE", "10"), max_connections, this.IniKey("Server", "Interface", ""));
		httpserver.TLSOnly = value this.IniKey("Server", "WebTLSOnly", "0");
		httpserver.CommonRoot = this.IniGetPath("Paths", "ConceptClient", "./ConceptClient.js");

		// cleaning service
		httpserver.getLoop().schedule(function(loop) {
			h2worker.IterateAsyncWorkers(null);
		}, 500);

		httpserver.OnRequest = function(loop, http_version, tls, method, var filename, headers, socket, stream, var data, pending_buffer) {
			if (this.LogRequests)
				this.log_request(http_version, tls, method, headers, socket);
			var content_type = httpserver.mimeType(filename);
			switch (content_type) {
				case "application/concept":
					if ((http_version == 1) && (ToLower("" + headers["upgrade"]) == "websocket")) {
						var key = headers["sec-websocket-key"];
						if (key) {
							var ret_key = WebSocket::AcceptKey(key);
							if (ret_key) {
								var origin = headers["origin"] ?? "";
								var extra_header = "";
								if (origin)
									extra_header = "Access-Control-Allow-Credentials: true\r\nAccess-Control-Allow-Headers: content-type\r\nAccess-Control-Allow-Headers: authorization\r\nAccess-Control-Allow-Headers: x-websocket-extensions\r\nAccess-Control-Allow-Headers: x-websocket-version\r\nAccess-Control-Allow-Headers: x-websocket-protocol\r\nAccess-Control-Allow-Origin: $origin\r\n";
								var session = "";
								var sec_proto = headers["sec-websocket-protocol"];
								if ((!sec_proto) || (sec_proto != "restore")) {
									session = this.GenerateSession();
									var expires = StrReplace(StrReplace(asctime(time() + 259200), "\r", ""), "\n", "")+" GMT";
									extra_header += "Set-Cookie: _s=$session;Expires=$expires\r\n";
								}
								httpserver.upgradeWebsocket(socket, ret_key, extra_header);
								// is an application !!!
								var tls_data = "";
								if (tls)
									tls_data = socket.Socket.Save();
								appworker.AddData(BinarizeObject(["job" => 1, "tls" => tls, "socket" => socket.Socket.Socket, "tls_data" => tls_data, "filename" => filename, "headers" => headers, "session" => session]));
								return REQUEST_DETACH;	
							}
						}
					}
					data = ReadFile(http_directory(filename) + "@index.html");
					if (!data)
						data = httpserver.readCommon("index.html");
					if (tls)
						data = StrReplace(data, "{PROTOCOL}", "wss");
					else
						data = StrReplace(data, "{PROTOCOL}", "ws");
					data = StrReplace(data, "{HOST}", headers["host"] ?? headers[":authority"]);
					var app = headers[":app"] ?? headers[":path"];
					var query = httpserver.getQuery(headers);
					if (query)
						app += "?" + query;
					data = StrReplace(data, "{APP}", app);
					filename = "index.html";
					return;
				case "application/concept-async-page":
					if (http_version == 2) {
						var cgi_child = h2worker.CreateCGI(socket, stream, "", headers[":root"] ?? "", headers[":path"], filename, query, headers["host"] ?? "", this.port, 2, httpserver.defaultHeaders(http_version));
						if (cgi_child) {
							httpserver.addEvent(cgi_child.IterateEventLoop);
							return REQUEST_HANDLED;
						} else
							return REQUEST_CGI_ERROR;
					} else {
						var worker = this.ChooseWorker();
						worker.AddData(BinarizeObject(new WDataContainer(socket.Socket, filename, headers, httpserver.getQuery(headers), pending_buffer, headers[":method"], headers["host"] ?? "", headers[":path"], this.getPort(tls), "", headers[":root"], 2)));
					}
					return REQUEST_DETACH;
				case "application/concept-server-page":
					if (http_version == 2) {
						cgi_child = h2worker.CreateCGI(socket, stream, this.cgi, headers[":root"] ?? "", headers[":path"], filename, query, headers["host"] ?? "", this.port, 0, httpserver.defaultHeaders(http_version));
						if (cgi_child) {
							httpserver.addEvent(cgi_child.IterateEventLoop);
							return REQUEST_HANDLED;
						} else
							return REQUEST_CGI_ERROR;
					} else {
						worker = this.ChooseWorker();
						worker.AddData(BinarizeObject(new WDataContainer(socket.Socket, filename, headers, httpserver.getQuery(headers), pending_buffer, headers[":method"], headers["host"] ?? "", headers[":path"], this.getPort(tls), this.cgi, headers[":root"], false)));
					}
					return REQUEST_DETACH;
				case "application/javascript-server-page":
					if (http_version == 2) {
						cgi_child = h2worker.CreateCGI(socket, stream, "", headers[":root"] ?? "", headers[":path"], filename, query, headers["host"] ?? "", this.port, 1, httpserver.defaultHeaders(http_version));
						if (cgi_child) {
							httpserver.addEvent(cgi_child.IterateEventLoop);
							return REQUEST_HANDLED;
						} else
							return REQUEST_CGI_ERROR;
					} else {
						worker = this.ChooseWorker();
						worker.AddData(BinarizeObject(new WDataContainer(socket.Socket, filename, headers, httpserver.getQuery(headers), pending_buffer, headers[":method"], headers["host"] ?? "", headers[":path"], this.getPort(tls), "", headers[":root"], 1)));
					}
					return REQUEST_DETACH;
				case "application/concept-private":
					// drop request
					this.log_request(http_version, tls, method, headers, socket, "silently dropped");
					return REQUEST_STOP;
				default:
					if ((this.cgiother) && (IsSet(this.cgiother, content_type))) {
						if (http_version == 2) {
							cgi_child = h2worker.CreateCGI(socket, stream, this.Owner.cgiother[content_type], headers[":root"] ?? "", headers[":path"], filename, query, headers["host"] ?? "", this.port, 1, httpserver.defaultHeaders(http_version));
							if (cgi_child) {
								httpserver.addEvent(cgi_child.IterateEventLoop);
								return REQUEST_HANDLED;
							} else
								return REQUEST_CGI_ERROR;
						} else {
							worker = this.ChooseWorker();
							worker.AddData(BinarizeObject(new WDataContainer(socket.Socket, filename, headers, httpserver.getQuery(headers), "", headers[":method"], headers[":host"] ?? "", headers[":path"], this.getPort(tls), this.Owner.cgiother[content_type], headers[":root"], false)));
							return REQUEST_DETACH;
						}
					}
			}
		};
		httpserver.OnEmptyRequest = function(path) {
			if (FileExists(path + "start.con"))
				return "start.con";
			if (FileExists(path + "index.cas"))
				return "index.cas";
			if (FileExists(path + "index.csp"))
				return "index.csp";
			return "index.html";
		};
		httpserver.useStatistics(function(data) {
			console.info(LOG_THIS, "${data["events"]} events, ${data["sockets"]} sockets, ${data["iotimeoutobjects"]} I/O timeout");
		}, 60000);
	}

	Run() {
		httpserver.LogHTTPErrors = this.LogRequests;
		httpserver.run();
	}

	Stop() {
		httpserver.stop();
	}
}

class ConceptPingWorker {
	ConceptPingWorker(data) {
		data = UnBinarizeObject(data);
		var ping = data[0];
		var timeout = data[1] * 1000;
		console.info(LOG_THIS, "Initializing ping worker, command: $ping, interval: ${timeout}ms");
		while (true) {
			var err = _system(ping);
			if (err)
				console.error(LOG_THIS, "Error $err executing $ping");
			Sleep(timeout);
		}
	}
}

class Main {
	Main() {
		console.level(LOG_LEVEL);

		var ini_file = "/usr/local/etc/concept.ini";
		if (!FileExists(ini_file))
			ini_file = "/usr/etc/concept.ini";
		if (!FileExists(ini_file))
			ini_file = "/etc/concept.ini";
		if (!FileExists(ini_file))
			ini_file = "concept.ini";

		var server = new ConceptServer(ini_file);
		if (USE_DB_SERVICE) {
			if (ExecuteProcess("concept", ".", ["TinDB.con"], [ ], false) < 0) {
				if (ExecuteProcess(getcwd() + "/concept", ".", ["TinDB.con"], [ ], false) < 0)
					if (ExecuteProcess("/usr/local/bin/concept", ".", ["TinDB.con"], [ ], false) < 0)
						console.error(LOG_THIS, "Error running database service");
			}
		}

		var ping = trim(IniGet(ini_file, "Watchdog", "Command", ""));
		var timeout;
		if (ping) {
			timeout = value IniGet(ini_file, "Watchdog", "Interval", "30");
			if (timeout < 1)
				timeout = 1;

			new Worker("ConceptPingWorker", BinarizeObject([ping, timeout]));
		}
		server.LogRequests = true;
		server.Run();
	}
}
