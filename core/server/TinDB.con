#!/usr/local/bin/concept
include Worker.con
include TinBase.con
include TCPSocket.con
include UNIXSocket.con
import standard.lib.cripto
import standard.math.rand
import standard.lang.cli
import standard.C.time

define TIN_DEBUG	false
define TIN_FORCESYNC	true
define READ_BUFFER	0xFFFF

// 256M packet
define MAX_OP_SIZE	0xFFFFFFF

define ERR_DB		-1
define ERR_DB_S		"Invalid db"
define ERR_COLLECTION	-2
define ERR_COLLECTION_S	"Invalid collection"
define ERR_INTERNAL	-3
define ERR_IO		-4
define ERR_IO_S		"Server I/O error"
define ERR_LOGIN	-5
define ERR_LOGIN_S	"Login required"
define ERR_USER_PASS	-6
define ERR_USER_PASS_S	"Invalid username or password"
define ERR_IN_CODE	-7
define ERR_NO_MEMBER_S	"No such function"
define ERR_CODE_RIGHTS	-8
define ERR_CODE_RIGHTS_S"Server code is disabled for this user"
define ERR_NOT_UNIQUE	-9
define ERR_NOT_UNIQUE_S	"Not unique"
define ERR_AGGREGATION	-10
define ERR_AGGREGATION_S"Invalid aggregation"

define NOTIFY_MORE_DATA	1

define MAX_CACHED_QUERIES	128
define MAX_CACHE_OBJECT_LEN	50000
// max 8M per object
define MAX_CACHE_OBJECT_SIZE	8388608

define BUSY_FSYNC_LIMIT	 	10000

// fsync every 5 seconds
define BUSY_FSYNC_TIMEOUT	5

class Triggers {
	var OnDelete;
	var OnInsert;
	var OnUpdate;
}

class SocketIOBase {
	static SendBuffer(socket, var to_send) {
		var offset = 0;
		do {
			var res = SocketWrite(socket, to_send, false, "", 0, false, offset);
			if (res <= 0)
				return res;
			offset += res;
		} while (offset < length to_send);
		return offset;
	}

	Send(socket, io = 0) {
		var to_send = BinarizeObject(this);
		to_send = ToSize(length to_send) + to_send;
		if (io) {
			AddWorkerData(io, BinarizeObject([socket, to_send, null, true]));
			return length to_send;
		}
		return SendBuffer(socket, to_send);
	}
}

class Q {
pragma used
	var q = "";
	var o = "Q";
	var d = "";
	var c = "";
	var f = null;

	var[] p;
	var[] x;

	var r;
	var io;
	var worker;
	var socket;
	var ctx_key;
	var aindex;
	var origp;
	var data;
	var child;
	var child_data;
}


class R extends SocketIOBase {
pragma used
	var id = -1;
	var q = "";
	var e = false;
	var et = "";
	var[] p;
}

class ConnectionContext {
	var buffer = "";
	var challenge = "";
	var auth = false;
	var code = true;
	var key;
	var subjects;
	var socket;

	ConnectionContext(socket) {
		this.socket = socket;
		this.key = RandomInteger(1, 0xFFFFFFF);
	}

	AddSubject(subject) {
		if (!subjects)
			subjects = new [];

		subjects[subject] = subject;
	}

	RemoveSubject(subject) {
		if ((subjects) && (IsSet(subjects, subject))) {
			var keys = GetKeys(subjects);
			var new_subjects = new [];
			for (var i = 0; i < length subjects; i++) {
				var k = keys[i];
				if ((k) && (k != subject))
					new_subjects[k] = k;
			}
			if (new_subjects)
				subjects = new_subjects;
			else
				subjects = null;
		}
	}

	HasSubject(subject) {
		if (subjects)
			return (IsSet(subjects, subject) && (subjects[subject]));

		return false;
	}
}

class QueryWorker {
pragma used
	var[] sockets;
	var[] buffers;
	var[] other_workers;
	var WorkerID;

	RemoveSocket(sock) {
		var res = new [];
		var buffers = this.buffers;
		var buf = new [];
		var sockets = this.sockets;
		var keys = GetKeys(buffers);
		var sock_key = "" + sock;
		for (var i = 0; i < length sockets; i++) {
			var s = sockets[i];
			if ((s) && (s != sock))
				res[length res] = s;
			var k = keys[i];
			if ((k) && (k != sock_key))
				buf[k] = buffers[k];
		}
		SocketClose(sock);
		this.sockets = res;
		this.buffers = buf;
	}

	RandomString(len) {
		var res = "";
		while (length res < len) {
			var c = RandomInteger(33, 126);
			if ((c != '\r') && (c != '\n') && (c != ';'))
				res += chr(c);
		}
		return res;
	}

	static WriterWorker(d, c, suggest_worker) {
		var key = "*" + d + "/" + c;
		return value Worker::GetSet(key, "worker", "" + suggest_worker);
	}

	static CacheKey(obj) {
		return sha1(BinarizeObject([obj.o, obj.f, obj.p, obj.x["start"], obj.x["len"], obj.x["descending"]]));
	}

	static InvalidateCache(d, c) {
		var key = "/" + d + "/" + c;
		Worker::Remove(key);
	}

	static Cache(obj, r) {
		var key = "/" + obj.d + "/" + obj.c;
		var cache_key = QueryWorker::CacheKey(obj);
		if (length r < MAX_CACHE_OBJECT_LEN) {
			var cache_obj = BinarizeObject(r);
			if (length cache_obj > MAX_CACHE_OBJECT_SIZE) {
				// don't cache large objects
				return;
			}
			if (Worker::Set(key, cache_key, cache_obj) > MAX_CACHED_QUERIES) {
				QueryWorker::InvalidateCache(obj.d, obj.c);
				Worker::Set(key, cache_key, cache_obj);
			}
		} else {
			Worker::Remove(key, cache_key);
		}
	}

	static CacheHit(obj, sock, current_worker) {
		var data;
		if ((obj.o == "Q") && ((!obj.x) || (!obj.x["map"])) && (obj.c) && (obj.d)) {
			var key = "/" + obj.d + "/" + obj.c;
			if (key) {
				data = Worker::Get(key, QueryWorker::CacheKey(obj));
				if (data) {
					var data_obj = UnBinarizeObject(data);
					if (data_obj) {
						var r = new R();
						r.q = obj.q;
						r.p = data_obj;
						if ((!obj.io) || (obj.io != current_worker))
							r.Send(sock, obj.io);
						else
							r.Send(sock);
						return true;
					}
				}
			}
		}
		return false;
	}

	Dispatch(ctx, sock, t, var next_worker, var next_a_worker, var next_idle_worker, storage_dbs, storage_workers, aggregation_workers, idle_workers, obj, current_worker, var buf, storage_dbs_w) {
		var priority = 0;
		if (obj.x) {
			var p2 = obj.x["priority"];
			if ((p2) && (typeof p2 == "numeric"))
				priority = p2;
		}
		switch (obj.o) {
			case "H":
				if (!ctx.code) {
					var r = new R();
					r.q = obj.q;
					r.e = ERR_CODE_RIGHTS;
					r.et = ERR_CODE_RIGHTS_S;
					r.Send(sock);
					break;
				}
			case "A":
			case "Q":
			case "S":
			case "I":
			case "D":
			case "X":
			case "Y":
			case ".":
			case "*":
			case "R":
			case "L":
			case "W":
			case "U":
				if ((!ctx) || (ctx.auth)) {
					if (typeof obj.c != "string")
						obj.c = "";
					if ((!obj.d) || (typeof obj.d != "string") || (Pos(obj.d, "/") > 0) || (Pos(obj.d, "\\") > 0)) {
						r = new R();
						r.e = ERR_DB;
						r.et = ERR_DB_S;
						if ((!obj.io) || (obj.io != current_worker))
							r.Send(sock, obj.io);
						else
							r.Send(sock);
					} else
					if ((obj.c) && ((Pos(obj.c, "/") > 0) || (Pos(obj.c, "\\") > 0))) {
						r = new R();
						r.e = ERR_DB;
						r.et = ERR_DB_S;
						if ((!obj.io) || (obj.io != current_worker))
							r.Send(sock, obj.io);
						else
							r.Send(sock);
					} else {
						var storage;
						var ctx_key = obj.ctx_key;
						if (!ctx_key) {
							ctx_key = ctx.key;
							obj.ctx_key = ctx.key;
						}
						if (CacheHit(obj, sock, current_worker))
							return;

						if (obj.o == "W") {
							storage = obj.worker;
							if (!storage) {
								storage = aggregation_workers[next_a_worker++];
								if (next_a_worker >= length aggregation_workers)
									next_a_worker = 0;
							}
							if (obj.socket <= 0) {
								obj.socket = sock;
								obj.io = current_worker;
							}
							if (!obj.r)
								obj.r = new R();
						} else
						if ((obj.o == "I") || (obj.o == "D") || (obj.o == "R") || (obj.o == "U")) {
							var storage_key = "" + obj.d + "/" + obj.c;
							storage = storage_dbs_w[storage_key];
							if (!storage) {
								storage = WriterWorker(obj.d, obj.c, storage_workers[next_worker++]);
								if (next_worker >= length storage_workers)
									next_worker = 0;
								storage_dbs_w[storage_key] = storage;
							}
						} else
						if (priority < 0) {
							// idle priority
							storage = idle_workers[next_idle_worker++];
							if (next_idle_worker >= length idle_workers)
								next_idle_worker = 0;
						} else {
							storage_key = "" + obj.d + "/" + obj.c;
							storage = storage_dbs[storage_key];
							if (!storage) {
								storage = storage_workers[next_worker++];
								if (next_worker >= length storage_workers)
									next_worker = 0;
								storage_dbs[storage_key] = storage;
							}
						}
						AddWorkerData(storage, BinarizeObject([sock, obj, current_worker, ctx_key]), priority);
					}
				} else {
					r = new R();
					r.q = obj.q;
					if (ctx.challenge) {
						if (obj.o == "A") {
							var username = obj.p["u"];
							var digest = obj.p["d"];
							var db = obj.p["db"];
							try {
								t.Lock();
								var user = t.Query(["username" => username])[0];
								t.Unlock();
								if (user) {
									var d2 = sha256(username + ":" + ctx.challenge + ":" + user["password"]);
									var user_db = user["db"];
									var db_valid = false;
									if (user_db) {
										if (typeof user_db == "array") {
											for (var db_i = 0; db_i < length user_db; db_i++) {
												var u_db = user_db[db_i];
												if ((u_db) && (typeof u_db == "string") && (u_db == user_db)) {
													db_valid = true;
													break;
												}
											}
										} else
										if (user_db == db)
											db_valid = true;
									} else
										db_valid = true;
									if ((user) && (d2 == digest) && (db_valid)) {
										ctx.auth = true;
										if (IsSet(user, "code"))
											ctx.code = (user["code"] == 1);
										r.id = 0;
										r.p["ok"] = true;
										r.Send(sock);
									}
								}
							} catch (var exc) {
								t.ReleaseLock();
								echo "Exception: $exc\n";
							}
						}
						if (!ctx.auth) {
							r.e = ERR_USER_PASS;
							r.et = ERR_USER_PASS_S;
							r.Send(sock);
							RemoveSocket(sock);
							buf = "";
						}
					} else {
						ctx.challenge = RandomString(48);
						r.e = ERR_LOGIN;
						r.et = ERR_LOGIN_S;
						r.p["c"] = ctx.challenge;
						r.p["m"] = "sha256";
						r.Send(sock);
					}
				}
				break;
			case "+":
				// no response for add/remove subject
				if ((obj.p) && (typeof obj.p == "string"))
					ctx.AddSubject(obj.p);
				break;
			case "-":
				// no response for add/remove subject
				if ((obj.p) && (typeof obj.p == "string"))
					ctx.RemoveSubject(obj.p);
				break;
			case "!":
				if ((obj.p) && (typeof obj.p == "array") && (obj.p["w"]))
					this.Notify(obj.p["w"], obj.p["o"], true, sock);
				break;
			case "G":
				r = new R();
				r.q = obj.q;
				try {
					var inc = 1;
					if ((obj.p) && (IsSet(obj.p, "i")))
						inc = obj.p["i"];

					r.p = TinBase::Generator(obj.d, obj.p["g"], inc);
				} catch (exc) {
					r.e = ERR_IO;
					r.et = ERR_IO_S;
					echo "Exception: $exc\n";
				}
				r.Send(sock);
				break;
		}
	}

	Notify(string subject, message, all_workers = false, socket = -1) {
		var notification = ["w" => subject, "o" => message];
		var r;
		for (var i = 0; i < length buffers; i++) {
			var ctx = buffers[i];
			if ((ctx) && (ctx.socket != socket) && (ctx.HasSubject(subject))) {
				if (!r) {
					// recycle r
					r = new R();
					r.q = "!";
					r.p = notification;
				}
				r.Send(ctx.socket);
			}
		}
		if (all_workers) {
			for (i = 0; i < length other_workers; i++) {
				var worker = other_workers[i];
				if (worker)
					AddWorkerData(worker, BinarizeObject([-7, subject, message]));
			}
		}
	}

	Execute(var data, var sleep_value, var t, var next_worker, var next_a_worker, var next_idle_worker, var storage_dbs, var storage_workers, var aggregation_workers, var idle_workers, var current_worker, var storage_dbs_w) {
		var timeout = 2;
		if (data) {
			timeout = 0;
			var job = UnBinarizeObject(data);
			var socket = job[0];
			var remote_obj = job[1];
			if (socket > 0) {
				if (job[3]) {
					// is postback
					var socket_key = "" + socket;
					// check if socket is still valid
					if (IsSet(buffers, socket_key)) {
						var len = SocketIOBase::SendBuffer(socket, remote_obj);
						if (len != length remote_obj) {
							// connection was dropped
							RemoveSocket(socket);
						}
					}
				} else {
					var post_key = remote_obj;//job[1];
					if (post_key) {
						var sock_key = "" + socket;
						if (IsSet(buffers, sock_key)) {
							var post_back_ctx = buffers[sock_key];
							if ((post_back_ctx) && (post_back_ctx.key == post_key)) {
								var post_back_r = job[2];
								post_back_r.Send(socket);
								delete post_back_r;
								delete job;
							}
						}
					} else {
						sockets[length sockets] = socket;
						buffers["" + socket] = new ConnectionContext(socket);
					}
				}
			} else
			if (socket == -7) {
				this.Notify(job[1], job[2]);
			} else
			if (remote_obj) {
				if ((remote_obj) && (classof remote_obj == "Q") && (remote_obj.o) && ((remote_obj.o == "W") || (remote_obj.o == "Q")))
					Dispatch(null, -1, null, next_worker, next_a_worker, next_idle_worker, storage_dbs, storage_workers, aggregation_workers, idle_workers, remote_obj, current_worker, "", storage_dbs_w);
			}
			remote_obj = null;
			job = null;
		}
		if ((SocketPoll(sockets, var outsockets, timeout)) && (outsockets)) {
			for (var i = 0; i < length outsockets; i++) {
				var sock = outsockets[i];
				var buffer = "";
				var buf2 = "";
				var obj = null;
				var res = SocketRead(sock, buffer, READ_BUFFER);
				if (res > 0) {
					var ctx = buffers["" + sock];
					var buf = ctx.buffer + buffer;
					// deserialize
					while (buf) {
						var to_read = FromSize(buf, var bytes);
						if (to_read <= MAX_OP_SIZE) {
							if ((to_read > 0) && (to_read <= length buf - bytes)) {
								buf2 = SubStr(buf, bytes, to_read);
								buf = SubStr(buf, to_read + bytes);
								obj = UnBinarizeObject(buf2);
 								if ((obj) && (classof obj == "Q") && (obj.o))
									Dispatch(ctx, sock, t, next_worker, next_a_worker, next_idle_worker, storage_dbs, storage_workers, aggregation_workers, idle_workers, obj, current_worker, buf, storage_dbs_w);
							} else {
								ctx.buffer = buf;
								break;
							}
							ctx.buffer = buf;
						} else {
							// drop socket ... packet to large
							RemoveSocket(sock);
							break;
						}
					}
				} else
					RemoveSocket(sock);
			}
			return;
		}
		if (sockets) {
			sleep_value = 2; // Sleep(2);
		} else
			sleep_value = 5; // Sleep(5);
	}

	QueryWorker(n) {
		n = UnBinarizeObject(n);
		WorkerID = n[0];
		var storage_workers = n[1];
		var idle_workers =  n[2];
		var[] storage_dbs;
		var[] storage_dbs_w;
		var next_worker = 0;
		var next_a_worker = 0;
		var next_idle_worker = 0;

		var AccessDB = new TinBase("sys");
		AccessDB.Mode = "rb";
		var t = AccessDB["users"];
		t.Open();
		var current_worker = CurrentWorker();

		while (!Worker::Pending(var aggregation_data))
			Sleep(5);

		var ref_data = UnBinarizeObject(aggregation_data);
		var aggregation_workers = ref_data[0];
		var all_query_workers = ref_data[1];
		if (all_query_workers) {
			for (var j = 0; j < length all_query_workers; j++) {
				var q_worker = all_query_workers[j];
				if ((q_worker) && (q_worker != current_worker))
					other_workers[length other_workers] = q_worker;
			}
		}
		var sleep_value = 0;
		var data;
		while (true) {
			data = "";
			Worker::Pending(data, sleep_value);
			Execute(data, sleep_value, t, next_worker, next_a_worker, next_idle_worker, storage_dbs, storage_workers, aggregation_workers, idle_workers, current_worker, storage_dbs_w);
		}
	}
}

class StorageWorker {
pragma used
	var[] managed_dbs;
	var[] objects;
	var[] members;
	var[] _triggers;
	var non_flushed_writes = 0;
	var last_flush = 0;
	var[] other_workers;
	var counter;
	var workerid;

	GetDelegate(dbobject, db, name, var objects, var members, r = null) {
		var arr = StrSplit(name, ".");
		var member;
		if (length arr == 2) {
			var classname = arr[0];
			var mname = arr[1];
			var key = "$db.$classname";		
			var key_mname = "$key.$mname";
			member = members[key_mname];
			if (!member) {
				var handler = objects[key];
				if (!handler) {
					handler = CreateObject2(classname, dbobject);
					if (handler)
						objects[key] = handler;
				}
				if (handler) {
					if (!GetMember(handler, mname, member, true))
						member = null;
				}
			}

			if ((r) && (!member)) {
				r.e = ERR_IN_CODE;
				r.et = ERR_NO_MEMBER_S;
			}
		}
		return member;
	}

	Flush(flush_index = true) {
		non_flushed_writes = 0;
		last_flush = time();
		for (var i = 0; i < length managed_dbs; i++) {
			var db = managed_dbs[i];
			if (db) {
				try {
					db.Flush(flush_index);
				} catch (var exc) {
					echo "Flush error: $exc\n";
				}
			}
		}
	}

	ResetDBS(all_workers = false) {
		if (!all_workers)
			echo "\t * Resetting storage worker #${CurrentWorker()}\n";
		else
			echo "Resetting storage worker #${CurrentWorker()}\n";
		for (var i = 0; i < length managed_dbs; i++) {
			var db = managed_dbs[i];
			if (db)
				db.Reset();
		}
		if (all_workers) {
			echo "\tresetting child workers ...\n";
			for (i = 0; i < length other_workers; i++) {
				var worker = other_workers[i];
				if (worker)
					AddWorkerData(worker, BinarizeObject([-8]));
			}
		}
	}

	Execute(var data) {
		var key;
		var trigger;
		data = UnBinarizeObject(data);

		if ((length data == 1) && (data[0] == -8)) {
			ResetDBS();
			return;
		}
		var socket = data[0];
		var obj = data[1];
		var target_worker = data[2];
		var target_key = data[3];
		var priority = 0;
		var r = new R();
		if (obj) {
			r.q = obj.q;
			if (obj.x)
				priority = obj.x["priority"];
		}
		if ((obj) && (obj.d)) {
			try {
				var db = managed_dbs[obj.d];
				if (!db) {
					if ((Pos(obj.d, "/") > 0) || (Pos(obj.d, "\\") > 0))
						throw "DB name error";
					db = new TinBase(obj.d);
					if (TIN_DEBUG)
						db.DebugPath = obj.d + "/";
					managed_dbs[obj.d] = db;
					var code = db.ReadHandler();
					if (code) {
						var load_err = IncludeCode(code);
						if (load_err) {
							echo "Stored handler loading error:\n$load_err\n";
							load_err = "";
						}
						code = "";
						var t2 = db.ReadTriggers();
						if (typeof t2 == "array")
							_triggers = t2;
					}
				}
				if ((obj.c) && ((Pos(obj.c, "/") > 0) || (Pos(obj.c, "\\") > 0)))
					throw "Collection name error";

				var multi_insert = false;
				switch (obj.o) {
					case "Q":
						var t = db[obj.c];
						if (t) {
							if ((obj.f) && (typeof obj.f != "array"))
								obj.f = null;
							if (typeof obj.p != "array")
								obj.p = [ ];
							var map = false;
							if ((obj.x) && (obj.x["map"]))
								map = true;
							t.Lock();
							if ((!map) || (obj.worker)) {
								r.p = t.Query(obj.p, obj.f, obj.x["descending"], obj.x["start"], obj.x["len"]);
								QueryWorker::Cache(obj, r.p);
							} else
							if ((target_worker) && (target_key)) {
								r.p = null;
								t.Query(obj.p, obj.f, obj.x["descending"], obj.x["start"], obj.x["len"], function(o, data) {
									if (o) {
										var obj = data[0];
										var r = new R();
										r.q = obj.q;
										r.p = o;
										r.id = o['$'];
										r.e = NOTIFY_MORE_DATA;
										AddWorkerData(data[1], BinarizeObject([data[2], data[3], r]), data[4]);
									}
								}, [obj, target_worker, socket, target_key, priority]);
							} else {
								r.p = null;
								t.Query(obj.p, obj.f, obj.x["descending"], obj.x["start"], obj.x["len"], function(o, data) {
									if (o) {
										var obj = data[0];
										var r = new R();
										r.q = obj.q;
										r.p = o;
										r.id = o['$'];
										r.e = NOTIFY_MORE_DATA;
										r.Send(data[1], obj.io);
									}
								}, [obj, socket]);
							}
							t.Unlock();
							r.id = 0;
						}
						break;
					case "D":
						t = db[obj.c];
						if (t) {
							if ((obj.f) && (typeof obj.f != "array"))
								obj.f = null;
							if (typeof obj.p != "array")
								obj.p = [ ];
							t.Lock();
							var items = t.Query(obj.p, obj.f, obj.x["descending"], obj.x["start"], obj.x["len"]);
							t.Unlock();
							if (items) {
								t.Lock(true);
								t.Delete(items);
								t.Unlock(true);
								QueryWorker::InvalidateCache(obj.d, obj.c);
								non_flushed_writes += length items;
								obj.p = items;
								trigger = _triggers["${obj.d}.${obj.c}"];
								if ((trigger) && (trigger.OnDelete)) {
									var deleg = this.GetDelegate(db, obj.d, trigger.OnDelete, objects, members);
									if (deleg) {
										try {
											r.p['$trigger'] = deleg(t, items);
										} catch (var deleg_exception) {
											echo "Uncaught delegate exception: $deleg_exception\n";
										}
									}
								}
							}
							r.p['$count'] = length items;
							// force flush/fsync for delete operations
							t.FlushDB(false);
						}
						break;
					case "I":
						if ((obj.c) && (typeof obj.p == "array")) {
							t = db[obj.c];
							if (obj.x["multi"])
								multi_insert = true;
							var id = -1;
							if (t) {
								var unique_fields = obj.x["unique"];
								trigger = _triggers["${obj.d}.${obj.c}"];
								t.Reopen();
								t.Lock(true);
								if (multi_insert) {
									id = new [];
									t.SetIndexLock(2);
									for (var i = 0; i < length obj.p; i++) {
										var o = obj.p[i];
										if (typeof o == "array") {
											if ((unique_fields) && (!t.IsUnique(o, unique_fields))) {
												r.e = ERR_NOT_UNIQUE;
												r.et = ERR_NOT_UNIQUE_S;
												break;
											}
											if ((IsSet(o, '$oid')) && (!o['$oid']))
												o['$oid'] = this.oid();
											try {
												var id2 = t.Store(obj.p[i]);
											} catch (var store_exc) {
												echo "Store error: $store_exc\n";
											}
											non_flushed_writes++;
											id[length id] = id2;
											o['$'] = id2;
											if ((trigger) && (trigger.OnInsert)) {
												deleg = this.GetDelegate(db, obj.d, trigger.OnInsert, objects, members);
												if (deleg) {
													try {
														deleg(t, o);
													} catch (deleg_exception) {
														echo "Uncaught delegate exception: $deleg_exception\n";
													}
												}
											}
										}
									}
									t.SetIndexLock(false);
									r.id = id;
								} else {
									if ((unique_fields) && (!t.IsUnique(obj.p, unique_fields))) {
										r.e = ERR_NOT_UNIQUE;
										r.et = ERR_NOT_UNIQUE_S;
									} else
									if ((IsSet(obj.p, '$')) && (obj.p['$'] > 0)) {
										id = value obj.p['$'];
										if (!t.Update(obj.p, id, true, var old_bin, var new_bin))
											id = -1;
										else
										if (old_bin) {
											old_bin['$'] = id;
											obj.p = [old_bin, new_bin, obj.p];
											obj.o = "U";
											//obj.o = "I";
											//obj.p = new_bin;
											//do_index = true;
										}
										non_flushed_writes++;
										if ((trigger) && (trigger.OnUpdate)) {
											deleg = this.GetDelegate(db, obj.d, trigger.OnUpdate, objects, members);
											if (deleg) {
												try {
													r.p['$trigger'] = deleg(t, obj.p);
												} catch (deleg_exception) {
													echo "Uncaught delegate exception: $deleg_exception\n";
												}
											}
										}
									} else {
										if ((typeof obj.p == "array") && (IsSet(obj.p , '$oid')) && (!obj.p['$oid']))
											obj.p['$oid'] = this.oid();
										id = t.Store(obj.p);
										non_flushed_writes++;
										if ((trigger) && (trigger.OnInsert)) {
											deleg = this.GetDelegate(db, obj.d, trigger.OnInsert, objects, members);
											if (deleg) {
												try {
													r.p['$trigger'] = deleg(t, obj.p);
												} catch (deleg_exception) {
													echo "Uncaught delegate exception: $deleg_exception\n";
												}
											}
										}
									}
									r.id = id;
									if (id > 0)
										obj.p['$'] = id;
								}
								QueryWorker::InvalidateCache(obj.d, obj.c);
								if (TIN_FORCESYNC)
									t.FlushDB(false);
								else
									t.Flush();
								t.Unlock(true);
								// t.Flush();
							} else {
								r.e = ERR_IO;
								r.et = ERR_IO_S;
							}
						} else {
							r.e = ERR_COLLECTION;
							r.et = ERR_COLLECTION_S;
						}
						break;
					case "U":
						t = db[obj.c];
						if (t) {
							if (typeof obj.f == "array") {
								if (typeof obj.p != "array")
									obj.p = [ ];
								t.Lock(true);
								r.p = null;
								unique_fields = obj.x["unique"];
								var update_data = [GetKeys(obj.f), obj.f, t, unique_fields];
								t.Query(obj.p, null, obj.x["descending"], obj.x["start"], obj.x["len"], function(o, data) {
									if (o) {
										var keys = data[0];
										var vals = data[1];
										var t = data[2];
										var unique_fields = data[3];
										var changed = false;
										for (var i = 0; i < length keys; i++) {
											var k = keys[i];
											if (k) {
												var val = vals[k];
												var o_k = o[k];
												if ((typeof o_k != typeof val) || (o_k != val)) {
													o[k] = val;
													changed = true;
												}
											}
										}
										if (changed) {
											if ((unique_fields) && (!t.IsUnique(o, unique_fields))) {
												// not unique
												data[5]++;
											} else {
												var filepos = t.Tell();
												try {
													t.Store(o);
													data[4]++;
												} catch (var exc) {
													echo "Error in update: $exc\n";
												}
												t.Seek(filepos);
											}
										}
									}
								}, update_data);
								if (update_data[2])
									QueryWorker::InvalidateCache(obj.d, obj.c);
								if (unique_fields)
									r.p = ["\$updated" => update_data[4], "\$notunique" => update_data[5]];
								else
									r.p = ["\$updated" => update_data[4]];
								t.Unlock(true);
							}
						}
						r.id = 0;
						break;
					case "X":
						r.id = 0;
						t = db[obj.c];
						if ((obj.p) && (typeof obj.p == "array")) {
							t.Lock();
							var created_indexes = t.EnsureIndexes(obj.p);
							t.Unlock();
							if (created_indexes) {
								QueryWorker::InvalidateCache(obj.d, obj.c);
								this.ResetDBS(true);
							}
							non_flushed_writes++;
						}
						break;
					case "Y":
						r.id = 0;
						t = db[obj.c];
						if (typeof obj.p == "array") {
							var lang = "en";
							if ((obj.x) && (obj.x["lang"]))
								lang = obj.x["lang"];
							echo "Full text index requested (building index) ...\n";
							var start_time = microseconds();
							t.Lock();
							var index_exists = t.EnsureFullTextIndex(obj.p, lang);
							t.Unlock();
							var end_time = microseconds() - start_time;
							if (index_exists) {
								echo "Index exists (${end_time/1000}ms)\n";
							} else {
								echo "Full text index created in ${end_time/1000}ms\n";
								QueryWorker::InvalidateCache(obj.d, obj.c);
								this.ResetDBS(true);
							}
							non_flushed_writes++;
						}
						break;
					case "S":
						t = db[obj.c];
						if (t) {
							if ((obj.f) && (typeof obj.f != "array"))
								obj.f = null;
							var searchstring = "";
							if (typeof obj.p == "array")
								searchstring = obj.p[0];
							r.p = t.Search(searchstring, obj.f, obj.x["start"], obj.x["len"]);
							r.id = 0;
						}
						break;
					case "H":
						var remove = obj.p["remove"];
						code = obj.p["code"];
						if (remove) {
							if (typeof remove != "array") {
								RemoveClass(remove);
							} else {
								for (i = 0; i < length remove; i++)
									RemoveClass(remove[i]);
							}
							objects = new [];
							members = new [];
						}
						if (code) {
							var err = IncludeCode(code);
							if (err) {
								r.e = ERR_IN_CODE;
								r.et = err;
							} else {
								db.StoreHandler(code);
							}
						}
						break;
					case ".":
						code = obj.p["code"];
						var member = null;
						if (code) {
							var arr = StrSplit(code, ".");
							if (length arr == 2) {
								var classname = arr[0];
								var mname = arr[1];
								key = "${obj.d}.$classname";
								var key_mname = "$key.$mname";
								member = members[key_mname];
								if (!member) {
									var handler = objects[key];
									if (!handler) {
										handler = CreateObject2(classname, db);
										if (handler)
											objects[key] = handler;
									}
									if (handler) {
										if (!GetMember(handler, mname, member, true))
											member = null;
									}
								}
								if (member) {
									var parameters = obj.p["params"];
									try {
										if (parameters)
											r.p = member(parameters);
										else
											r.p = member();
									} catch (deleg_exception) {
										echo "Uncaught delegate exception: $deleg_exception\n";
									}
								} else {
									r.e = ERR_IN_CODE;
									r.et = ERR_NO_MEMBER_S;
								}
							}
						}
						break;
					case "*":
						if ((obj.c) && (typeof obj.p == "array")) {
							key = "${obj.d}.${obj.c}";
							trigger = _triggers[key];
							if (!trigger) {
								trigger = new Triggers();
								_triggers[key] = trigger;
							}
							// insert
							// update
							// delete
							if (IsSet(obj.p, "insert")) {
								trigger.OnInsert = obj.p["insert"];
								if (!this.GetDelegate(db, obj.d, trigger.OnInsert, objects, members, r)) {
									trigger.OnInsert = null;
									break;
								}
							}
							if (IsSet(obj.p, "update")) {
								trigger.OnUpdate = obj.p["update"];
								if (!this.GetDelegate(db, obj.d, trigger.OnUpdate, objects, members, r)) {
									trigger.OnUpdate = null;
									break;
								}
							}
							if (IsSet(obj.p, "delete")) {
								trigger.OnDelete = obj.p["delete"];
								if (!this.GetDelegate(db, obj.d, trigger.OnDelete, objects, members, r)) {
									trigger.OnDelete = null;
									break;
								}
							}
							db.StoreTriggers(_triggers);
						} else {
							r.e = ERR_COLLECTION;
							r.et = ERR_COLLECTION_S;
						}
						break;
					case "R":
						if (obj.c) {
							t = db[obj.c];
							if (t) {
								try {
									t.Drop();
									db.Reset();
								} catch (var exc_drop) {
									echo "Remove error: $exc_drop\n";
									r.e = ERR_COLLECTION;
									r.et = ERR_COLLECTION_S;
								}
								QueryWorker::InvalidateCache(obj.d, obj.c);
								this.ResetDBS(true);
							}
						} else {
							r.e = ERR_COLLECTION;
							r.et = ERR_COLLECTION_S;
						}
						break;
					case "L":
						if ((obj.c) && (typeof obj.p == "array")) {
							t = db[obj.c];
							var hash = "sha256";
							var username = "username";
							var field = "password";
							var challenge = "";
							var sum = "";
							if (obj.x["f"])
								hash = ToLower("" + obj.x["f"]);

							if (obj.x["pass_field"])
								field = obj.x["pass_field"];

							if (obj.x["user_field"])
								username = obj.x["user_field"];

							if (obj.x["challenge"])
								challenge = obj.x["challenge"];

							if (obj.x["hash"])
								sum = obj.x["hash"];

							if ((t) && (field) && (username)) {
								if (obj.f) {
									obj.f[username] = username;
									obj.f[field] = field;
								}
								t.Lock();
								var user_arr = t.Query(obj.p, obj.f, false, 0, 1);
								t.Unlock();
								var user = null;
								if (user_arr)
									user = user_arr[0];
								if (user) {
									var d2 = "";
									switch (hash) {
										case "sha256":
											d2 = sha256(user[username] + ":" + challenge + ":" + user[field]);
											break;
										case "sha1":
											d2 = sha1(user[username] + ":" + challenge + ":" + user[field]);
											break;
										case "":
											d2 = user[field];
											break;
									}
									if (d2 == sum) {
										user[field] = "";
										r.p = user;
									} else {
										r.e = ERR_USER_PASS;
										r.et = ERR_USER_PASS_S;
									}
								} else {
									r.e = ERR_USER_PASS;
									r.et = ERR_USER_PASS_S;
								}
							} else {
								r.e = ERR_IO;
								r.et = ERR_IO_S;
							}
						} else {
							r.e = ERR_COLLECTION;
							r.et = ERR_COLLECTION_S;
						}
						break;
				}
			} catch (var exc) {
				if (t)
					t.ReleaseLock();
				r.e = ERR_COLLECTION;
				r.et = exc;
			}
		} else {
			r.e = ERR_DB;
			r.et = ERR_DB_S;
		}

		if ((!obj) || (!obj.x) || (!IsSet(obj.x, 'silent')) || (!obj.x['silent'])) {
			if (obj.worker) {
				obj.r = r;
				AddWorkerData(obj.worker, BinarizeObject([socket, obj, 0, target_key]), priority);
			} else
			if ((target_worker) && (target_key)) {
				AddWorkerData(target_worker, BinarizeObject([socket, target_key, r]), priority);
			} else
				r.Send(socket, obj.io);
		}
	}

	oid() {
		if (counter >= 0xFFFF)
			counter = 0;
		return TinDBOid::create(1, workerid, counter++);
	}

	StorageWorker(n) {
		while (!Worker::Pending(var storage_data))
			Sleep(5);
		var all_workers = UnBinarizeObject(storage_data);
		var current_worker = CurrentWorker();
		counter = RandomInteger(0, 0xFFF0);

		if (all_workers) {
			for (var j = 0; j < length all_workers; j++) {
				var worker = all_workers[j];
				if ((worker) && (worker != current_worker))
					other_workers[length other_workers] = worker;
				else
				if (worker)
					workerid = j;

			}
		}

		var data;
		while (true) {
			data = "";
			var qsize = Worker::Pending(data, -1);
			if (qsize) {
				try {
					Execute(data);
				} catch (var exc) {
					echo "Storage worker exception: $exc\n";
				}
				data = "";
				if ((non_flushed_writes) && ((non_flushed_writes > BUSY_FSYNC_LIMIT) || ((time() - last_flush) >= BUSY_FSYNC_TIMEOUT)))
					this.Flush();
				else
				if ((non_flushed_writes) && (qsize == 1))
					this.Flush();
			}
		}
	}
}

class QueryAggregator {
	var QueryWorkers;
	var QueryWorkerIndex = 0;

	PopulateValues(arr, key) {
		var[] values;
		if ((arr) && (key)) {
			var[] keys;
			for (var i = 0; i < length arr; i++) {
				var e = arr[i];
				if ((e) && (IsSet(e, key))) {
					var v = e[key];
					if (typeof v == "string")
						keys[v] = v;
					else
					if (typeof v == "numeric") {
						v = "" + v;
						keys[v] = v;
					}
				}
			}
			for (i = 0; i < length keys; i++)
				values[i] = keys[i];
		}	
		return values;
	}

	Pairs(elements, pairs) {
		var[] pairs_tree;
		var keys = GetKeys(pairs);
		var[] tree_counts;
		for (var i = 0; i < length elements; i++) {
			var e = elements[i];
			if (e) {
				for (var j = 0; j < length keys; j++) {
					var k = keys[j];
					if (k) {
						var sorted_pairs = pairs_tree[k];
						var counts;
						if (sorted_pairs) {
							counts = tree_counts[k];
						} else {
							sorted_pairs = new [];
							pairs_tree[k] = sorted_pairs;
							counts = new [];
							tree_counts[k] = counts;
						}
						var equiv = pairs[k];
						if ((equiv) && (IsSet(e, equiv))) {
							var v = e[equiv];
							if ((typeof v == "string") || (typeof v == "numeric")) {
								v = "" + v;
								var count = counts[v];
								if (!count) {
									sorted_pairs[v] = e;
								} else
								if (count == 1) {
									sorted_pairs[v] = [sorted_pairs[v], e];
								} else {
									var arr = sorted_pairs[v];
									var key = e['$'];
									if (key)
										arr[key] = e;
									else
										arr[length arr] = e;
								}
								count++;
								counts[v] = count;
							}
						}
					}
				}
			}
		}
		return pairs_tree;
	}

	Filter(e, pairs, keys) {
		for (var i = 0; i < length keys; i++) {
			var k = keys[i];
			if ((k) && (IsSet(e, k))) {
				var v = e[k];	
				if ((typeof v == "string") || (typeof v == "numeric")) {
					v = "" + v;
					var arr = pairs[k];
					if (IsSet(arr, v)) {
						var tmp_key = '$' + k;
						while (e[tmp_key])
							tmp_key = '$' + tmp_key;
						e[tmp_key] = arr[v];
					}
				}
			}
		}
	}

	Execute(var data, recursive_count = 0) {
		var q = UnBinarizeObject(data);
		var obj;
		if (q)
			obj = q[1];
		var priority = 0;
		if (obj) {
			if (obj.x)
				priority = obj.x["priority"];

			var worker = QueryWorkers[QueryWorkerIndex++];
			if (QueryWorkerIndex >= length QueryWorkers)
				QueryWorkerIndex = 0;
			var data_ready = false;
			if (typeof obj.p == "array") {
				var new_obj = new Q;
				new_obj.o = "Q";
				new_obj.q = obj.q;
				new_obj.d = obj.d;
				new_obj.c = obj.c;

				new_obj.socket = obj.socket;
				new_obj.io = obj.io;
				new_obj.worker = CurrentWorker();
				new_obj.ctx_key = obj.ctx_key;
				if (obj.o == "W") {
					new_obj.origp = obj.p;
					new_obj.aindex = 0;
					new_obj.p = obj.p[0];
					new_obj.x = obj.x;
				} else
				if ((obj.r) && (obj.origp)) {
					var p;
					if (obj.child) {
						p = obj.child;
						new_obj.aindex = obj.aindex;
					} else {
						new_obj.aindex = obj.aindex + 1;
						p = obj.origp[new_obj.aindex];
					}

					var qdata;
					var ref_data;
					if (!obj.aindex)
						qdata = obj.r.p;
					else
					if ((obj.data) || (obj.child_data)) {
						qdata = obj.data[0];

						if (obj.child_data) {
							ref_data = obj.child_data[0];
							var pairs = Pairs(obj.r.p, obj.child_data[1]);
 						} else {
							ref_data = qdata;
							pairs = Pairs(obj.r.p, obj.data[1]);
						}

						if ((ref_data) && (pairs)) {

							var pair_keys = GetKeys(pairs);
							for (var i = 0; i < length ref_data; i++) {
								var e = ref_data[i];
								if (e)
									Filter(e, pairs, pair_keys);
							}
						}
					} else
						qdata = new [];

					if (p) {
						var keys = GetKeys(p);
						var k1 = keys[0];
						var k2 = keys[1];
						var has_query = true;
						var translate;
						var child_query = null;
						if ((length p == 3) && (typeof p[2] == "array"))
							child_query = p[2];
						if ((child_query) && (obj.r.p))
							new_obj.child = child_query;

						if ((!k1) && (!k2) && (length p >= 2) && (p[0]) && (typeof p[0] == "string")) {
							k1 = p[0];
							translate = p[1];
							has_query = false;
						}

						if (((length p != 2) && (length p != 3)) || ((!k1) && (!k2)) || ((k1 != '$') && (k2 != '$'))) {
							obj.r = new R();
							obj.r.e = ERR_AGGREGATION;
							obj.r.et = ERR_AGGREGATION_S;
							data_ready = true;
						} else {
							if (k1 == '$') {
								new_obj.c = k2;
								if (has_query) {
									new_obj.p = p[1];
									translate = p[0];
								}
							} else {
								new_obj.c = k1;
								if (has_query) {
									new_obj.p = p[0];
									translate = p[1];
								}
							}
							if (!new_obj.p)
								new_obj.p = new [];
							var translate_clean = new [];
							if (obj.child)
								ref_data = obj.r.p;
							else
								ref_data = qdata;
							if (translate) {
								keys = GetKeys(translate);
								for (i = 0; i < length keys; i++) {
									var k = keys[i];
									if (k) {
										var equivalent_k = translate[equivalent_k];
										if (equivalent_k) {
											var v = PopulateValues(ref_data, k);
											if (v) {
												new_obj.p[equivalent_k] = v;
												translate_clean[k] = equivalent_k;
											}
										}
									}
								}
							}
							if (qdata) {
								new_obj.origp = obj.origp;
								new_obj.data = [qdata, translate_clean];
								if (obj.child)
									new_obj.child_data = [obj.r.p, translate_clean];
							} else
								data_ready = true;
						}
					} else
						data_ready = true;
				} else
					data_ready = true;

				if (!data_ready)
					AddWorkerData(worker, BinarizeObject([-1, new_obj]), priority);
			} else
				data_ready = true;

			if (data_ready) {
				if (!obj.r) {
					obj.r = new R();
					obj.q = obj.q;
				}
				if (obj.data)
					obj.r.p = obj.data[0];
				obj.r.Send(obj.socket, obj.io);
			}
		}
	}

	QueryAggregator(n) {
		n = UnBinarizeObject(n);
		QueryWorkers = n[1];
		var data = "";
		while (true) {
			if (Worker::Pending(data, -1)) {
				try {
					Execute(data);
				} catch (var exc) {
					echo "Storage worker exception: $exc\n";
				}
				data = "";
			}
			// Sleep(5);
		}
	}
}


class TinDB {
	protected var[] QueryWorkers;
	protected var WorkerIndex = 0;
	protected var Socket;
	protected var[] StorageWorkers;
	protected var[] IDLEWorkers;
	protected var[] AggregatorWorkers;

	Rotate(array, right) {
		if ((right <= 0) || (!array) || (length array == 1))
			return array;

		right = length array % right;
		if (!right)
			return array;

		var[] new_arr;
		for (var i = right; i < length array; i++)
			new_arr[length new_arr] = array[i];
		for (i = 0; i < right; i++)
			new_arr[length new_arr] = array[i];
		return new_arr;
	}

	TinDB(workers = 4, storage_workers = 4, idle_workers = 1, aggregator_workers = 2) {
		RandomSeed(unpack("u32", CryptoRandom(4))[0]);
		var[] sworkers;
		var[] qworkers;
		var[] aworkers;
		var[] idleworkers;

		var[] all_storage_workers;
		var context = Worker::SharedContext();
		for (var i = 0; i < storage_workers; i++) {
			StorageWorkers[i] = new Worker("StorageWorker", "", context);
			var w_obj = StorageWorkers[i]._workerobj;
			sworkers[length sworkers] = w_obj;
			all_storage_workers[length all_storage_workers] = w_obj;
			Sleep(100);
		}
		for (i = 0; i < idle_workers; i++) {
			IDLEWorkers[i] = new Worker("StorageWorker", "", context);
			var idle_obj = IDLEWorkers[i]._workerobj;
			idleworkers[length idleworkers] = idle_obj;
			all_storage_workers[length all_storage_workers] = idle_obj;
			Sleep(100);
		}
		for (i = 0; i < workers; i++) {
			QueryWorkers[i] = new Worker("QueryWorker", BinarizeObject(["QW${i+1}", Rotate(sworkers, i), Rotate(idleworkers, i)]), context);
			var q_obj = QueryWorkers[i]._workerobj;
			qworkers[length qworkers] = q_obj;
			Sleep(100);
		}
		for (i = 0; i < aggregator_workers; i++) {
			AggregatorWorkers[i] = new Worker("QueryAggregator", BinarizeObject(["QAW${i+1}", Rotate(qworkers, i)]), context);
			var a_obj = AggregatorWorkers[i]._workerobj;
			aworkers[length aworkers] = a_obj;
			Sleep(100);
		}

		for (i = 0; i < length QueryWorkers; i++)
			AddWorkerData(QueryWorkers[i]._workerobj, BinarizeObject([Rotate(aworkers, i), qworkers]));

		var storage_bin = BinarizeObject(all_storage_workers);
		for (i = 0; i < length all_storage_workers; i++)
			AddWorkerData(all_storage_workers[i], storage_bin);
	}

	static InitializeDatabases() {
		var AccessDB = new TinBase("sys");
		var t = AccessDB["users"];
		t.Lock(true);
		if (!t.EnsureIndex("username"))
			t.Store(["username" => "sysdbadministrator", "password" => sha256("sysdbadministrator"), "db" => ""]);
		t.Unlock(true);
		t.Flush();
		AccessDB.Reset();
	}

	Start(port = 2668, max_connections = 1024, working_directory = "", interface = "") {
		if (working_directory)
			_chdir(working_directory);
		Socket = new TCPSocket();
		if (Socket.Listen(port, max_connections, interface))
			throw "Error initializing TinDB server (port ${port} already in use)";

		while (true) {
			var sock = Socket.Accept(true);
			if (sock > 0) {
				var info = SocketInfo(sock);
				var addr = info["address"];
				if ((addr) && ((addr == "127.0.0.1") || (addr == "::1"))) {
					QueryWorkers[WorkerIndex++].AddData(BinarizeObject([sock]));
					if (WorkerIndex >= length QueryWorkers)
						WorkerIndex = 0;
				} else {
					SocketClose(sock);
				}
			}
		}
	}
}

class Main {
	RealPath(path) {
		var res = "";
		path = StrReplace(path, "\\", "/");
		var arr = StrSplit(path, "/");
		for (var i = length arr - 1; i >= 0; i--) {
			var e = arr[i];
			if (e == "..") {
				i--;
			} else {
				if (res)
					res = arr[i] + "/" + res;
				else
					res = arr[i];
			}
		}
		if (path[0] == "/")
			res = "/" + res;
		return res;
	}

	IniGetPath(ini_file, category, key, default_value = "") {
		var res = trim(IniGet(ini_file, category, key, default_value));
		if (res[0] == ".")
			return getcwd() + "/" + res;
		return res;
	}

	Main() {
		echo "Initializing Tinbase...\n";
		var ini_file = "/usr/local/etc/concept.ini";
		if (!FileExists(ini_file))
			ini_file="/usr/etc/concept.ini";
		if (!FileExists(ini_file))
			ini_file="/etc/concept.ini";
		if (!FileExists(ini_file))
			ini_file=getcwd()+"/concept.ini";

		var user = IniGet(ini_file, "TinDB", "User", "");
		var password = "";
		if (user) {
			password = IniGet(ini_file, "TinDB", "UserPassword", "");
		} else {
			user = IniGet(ini_file, "Server", "User", "");
			password = IniGet(ini_file, "Server", "UserPassword", "");
		}
		if (user) {
			if (!SetCurrentUser(user, password))
				echo "TinDB WARNING: cannot change user to $user\n";
		}
		var root = RealPath(IniGetPath(ini_file, "Paths", "DB", "../db"));
		_mkdir(root);
		if ((!root) || (_chdir(root))) {
			echo "Error initializing DB engine\nCannot chdir to '$root'\n";
			return -1;
		}
		TinDB::InitializeDatabases();
		var db = new TinDB();
		echo "Listening\n";
		db.Start();
	}
}
