#!/usr/local/bin/concept -chdir

include Greenloop.con
include TCPSocket.con
include TLSESocket.con
include UNIXSocket.con
include Serializable.con
include WebSocket.con
include File.con
include Worker.con
include HTTP2.con

import standard.C.io
import standard.C.time
import standard.lib.str
import standard.C.casts
import standard.lib.cripto
import standard.coding.base64

// set to true when in production
// this will allow only compiled files to run (.accel)
define CONCEPT_STRICT_EXECUTE	false

define WS_SESSION_RESTORE	true

define MAX_RECV_BUFFER		0xFFFF
define READ_BUFFER		0x7FFFF
define MAX_WS_HEADER		0xFFF
define MAX_WS_HEADER_BUF	0xFFF
define USE_TLS_PROXY		false
define USE_DB_SERVICE		true
define DEFAULT_CGI_WORKERS	4
define DEFAULT_H2_WORKERS	4
define PIPE_READ_CPU_TIME_US	2000
define MAX_HEADER_PARAMETERS	0xFF
define SERVER_NAME		"CAS5WS"
define SERVER_SOFTWARE		"Concept Application Server (TLSe,ws/wss/http/https/concept/deprecated concepts/cgi1.1/http2)"
define EXTRA_HEADER		"X-Frame-Options: SAMEORIGIN\r\nX-XSS-Protection: 1; mode=block\r\nX-Content-Type-Options: nosniff\r\n"
define H2_EXTRA_HEADER		"strict-transport-security" => "max-age=31536000; includeSubDomains; preload", "x-frame-options" => "SAMEORIGIN", "x-xss-protection" => "1; mode=block", "x-content-type-options" => "nosniff"
define H2_MAX_IDLE_SECONDS	30
define IDLE_SLEEP_MS		10
define IDLE_SLEEP_THRESHOLD	200
define IDLE_SLEEP_MS2		50
define CGI_MAX_RETRY_SECONDS	5
define EAGAIN_TIMEOUT_SECONDS	5

// 128k pipe read buffer
define PIPE_MAX_STDOUT_BUFFER	0x20000
// 2Mb stdout buffer
define CGI_MAX_STDOUT_BUFFER	0x200000
// 8Mb stdout buffer for http/2
define H2_MAX_STDOUT_BUFFER	0x800000
// 2Mb limit file read buffer
define H2_MAX_FILE_BUFFER	0x200000
// 128k file buffer for http 1.1
define H1_MAX_FILE_BUFFER	0x20000

class RewriteContainer {
	var Rewrite;

	RewriteContainer() {
		// ========= rewrite rules ======== //
		// uncomment if needed
		// Rewrite = function(app, var parameters) {
		// 	return app;
		// };
		// ======= end rewrite rules ====== //
	}
}

class H2Container {
pragma used
	var socket;
	var tls = "";

	H2Container(socket) {
		this.socket = socket.Socket;
		if (classof socket == "TLSESocket") {
			tls = socket.Save();
			socket.Done();
		}
		socket.Socket = -1;
	}
}

class WDataContainer {
pragma used
	var socket;
	var app;
	var headers;
	var tls;
	var query;
	var snippet;
	var method;
	var hostname;
	var path;
	var port;
	var cgihandler;
	var root;

	WDataContainer(socket, app, var headers, var query, var snippet, method, hostname, path, port, cgihandler, root) {
		this.socket = socket.Socket;
		this.app = app;
		this.headers = headers;
		this.query = query;
		this.snippet = snippet;
		this.method = method;
		this.hostname = hostname;
		this.path = path;
		this.port = port;
		this.cgihandler = cgihandler;
		this.root = root;
		if (classof socket == "TLSESocket") {
			tls = socket.Save();
			socket.Done();
		}
		socket.Socket = -1;
	}
}

class ConceptChild {
	protected var Socket;
	protected var Owner;

	private var DataLen;
	private var Key="";
	public var ServerName="";
	public var PID;
	private var DirectPipe=-1;

	public var Session="";
	public var APID;
	public var Hash;

	public var PipeIn=-1;
	public var PipeOut=-1;
	public var Parent=-1;
	
	public var ContextIn=-1;
	public var ContextOut=-1;

	private var APIDBuf="";
	private var MaxBuffer=0;

	public var HostID="";
	public var UsingHost=-1;
	public var UsingPID=-1;
	public var ChildCount=0;

	public var IsWebSocket=false;
	public var Timestamp;
	public var MaxChilds=0;
	public var TLS;

	ConceptChild(owner, socket) {
		this.Owner = owner;
		this.Socket = socket;
		Owner.ClientCount++;
	}

	WriteExact(buffer, add_size=false, do_throw=false) {
		var socket = this.Socket;

		var len = length buffer;
		if (add_size) {
			buffer = toubin(htonl(len), 32)+buffer;
			len = length buffer;
		}

		var result = 0;

		while (len > 0) {
			try {
				var written = socket.Write(buffer);
			} catch (var exc) {
				if (do_throw)
					throw "Socket.Write: $exc";
				return -1;
			}
			if (written <= 0) {
				if (do_throw)
					throw "Socket.Write: broken socket";
				return -1;
			}
			result += written;
			len -= written;
			if (len>0)
				buffer = SubStr(buffer, written, len);
		}
		return result;
	}

	WriteExactNoBlocking(buffer, reblock = false) {
		SocketSetBlocking(Socket.Socket, false);
		var written = WriteExact(buffer);
		if (reblock)
			SocketSetBlocking(Socket.Socket, true);
		return written;
	}

	DecryptKey(var private_key, size=16) {
		var key=this.Key;
		if (key) {
			switch (SubStr(private_key, 0, 4)) {
				case 'ecc!':
					key = ECCDecrypt(key, SubStr(private_key, 4), var err);
					if (err)
						echo "ECC error: ${ECCRSAErrorExplain(err)}\n";
					break;
				case 'rsa!':
					key = RSADecrypt(key, SubStr(private_key, 4), err);
					if (err)
						echo "ECC error: ${ECCRSAErrorExplain(err)}\n";
					break;
				case '----':
					key = rsa_decrypt(key, private_key);
					break;
				default:
					key = "";
					break;
			}
		}
		if (length key!=size)
			throw "Invalid key size";

		this.Key=key;
	}

	AnalyzeData(data, var step, var private_key, var public_key, var key_path, allow_debug) {
		switch (step) {
			case 0:
				// protocol negotiation
				if (length data>=4) {
					var buf=data[0]+data[1]+data[2]+data[3];
					var dlen=ntohl(tounumber(buf, 32));
					data=SubStr(data, 4, length data-4);

					if (dlen>=MAX_RECV_BUFFER)
						throw "Invalid key size";

					step++;
					this.DataLen=dlen;
				}
				// no break here
			case 1:
				if (length data>=this.DataLen) {
					var key=SubStr(data, 0, this.DataLen);
					data=SubStr(data, length key, length data - length key);
					this.Key=key;
					step++;
				}
			case 2:
				if (data) {
					do {
						var commands=StrSplit(data, "\r\n", true);
						var len=length commands;
						if (len>1) {
							var command=commands[0];
							var tlen=length command + 2;
							data=SubStr(data, tlen, length data - tlen);
							if (command)
								this.ExecuteCommand(command, private_key, public_key, step, key_path, allow_debug);
						}
					} while (len>1);
				}
				
		}
		return data;
	}

	Restore(var session, var private_key) {
		var child=this.Owner.GetSession(session);
		if (child) {
			DecryptKey(private_key);
			if (child.Key == this.Key) {
				if (child.DirectPipe>0) {
					var size = DescriptorWrite(child.DirectPipe, this.Socket.Socket, child.UsingPID);
					if (size > 0) {
						// no tls key
						// write(child.DirectPipe, "\0\0\0\0");
						var prev_socket = child.Socket;
						child.Socket = this.Socket;
						this.WriteExact("1\r\n", false, true);
						this.Socket = prev_socket;
						return true;
					}	
				}
			}
		}
		this.WriteExact("0\r\n", false, true);
		return false;
	}

	RestoreWS_Step1(var session) {
		var child = this.Owner.GetSession(session);
		if ((child) && (child.DirectPipe > 0))
			return child;
		return null;
	}

	RestoreWS_Step2(child) {
		if ((child) && (child.DirectPipe > 0) && (classof child.Socket == classof this.Socket)) {
			var size = DescriptorWrite(child.DirectPipe, this.Socket.Socket, child.UsingPID);
			if (size > 0) {
				var buf = "";
				var tls_buf = "";
				if ((TLS) && (classof this.Socket == "TLSESocket"))
				 	tls_buf = this.Socket.Save();

				buf = pack("U32", length tls_buf) + tls_buf;

				while (buf) {
					var written = write(child.DirectPipe, buf);
					if (written <= 0) {
						echo "Error in DirectPipe write\n";
						return false;
					}

					buf = SubStr(buf, written);
				}
				var prev_socket = child.Socket;
				child.Socket = this.Socket;
				child.Session = this.Session;
				this.Socket = prev_socket;
				return true;
			}
		}
		return false;
	}

	ExecuteGet(command, param, private_key, var step) {
		switch (ToLower(command)) {
			case "protocol":
				this.WriteExact("Protocol/2.0\r\n", false, true);
				break;
			case "session":
				if (!this.Session)
					this.Session = this.GenerateSession();
				this.WriteExact("${this.Session}\r\n", false, true);
				break;
			case "restore":
				if (param) {
					if (Restore(param, private_key))
						step=-1;
					else
						step=4;
					break;
				}
				// no break if no parameter
			default:
				this.WriteExact("0\r\n", false, true);
				break;
		}
	}

	ExecuteSet(command, val) {
		switch (ToLower(command)) {
			case "servername":
				ServerName=ToLower(val);
				break;
		}
	}

	Invalidate(p) {
		this.HostID = "";
		echo "Process crashed (error: ${_errno()}, pipe: $p)\n";
		//if (this.ContextIn>0)
		//	close(this.ContextIn);
		if (this.ContextOut>0)
			close(this.ContextOut);

		this.ContextOut = -1;
		//this.ContextIn = -1;
		return -1;
	}

	AddChild(pr2, shared_key, pipein1, pipeout2, direct_pipe, pid=null) {
		if (write(pr2, tobin(this.APID, 32)) != 4)
			return this.Invalidate(pr2);

		if (write(pr2, tobin(this.Parent, 32)) != 4)
			return this.Invalidate(pr2);

		if (pid)
			DescriptorWrite(pr2, Socket.Socket, pid);
		else
			DescriptorWrite(pr2, Socket.Socket);

		var d1 = Duplicate(pipein1, pid);
		var d2 = Duplicate(pipeout2, pid);
		var d3 = Duplicate(direct_pipe, pid);

		// problems on windows
		if ((d1 < 0) || (d2 < 0) || (d3 < 0)) {
			d1 = -1;
			d2 = -1;
			d3 = -1;
			if (this.DirectPipe>0)
				close(this.DirectPipe);
		}
		DescriptorWrite(pr2, d1);
		DescriptorWrite(pr2, d2);
		DescriptorWrite(pr2, d3);

		//DescriptorWrite(pr2, pipein1);
		//DescriptorWrite(pr2, pipeout2);
		//DescriptorWrite(pr2, direct_pipe);

		if (shared_key) {
			if (write(pr2, tobin(length shared_key, 32)) != 4)
				return this.Invalidate(pr2);
			if (write(pr2, shared_key) != length shared_key)
				return this.Invalidate(pr2);
		} else {
			if (write(pr2, tobin(0, 32)) != 4)
				return this.Invalidate(pr2);

			var shared_key2=this.Key;
			if (write(pr2, tobin(length shared_key2, 32)) != 4)
				return this.Invalidate(pr2);
			if (shared_key2) {
				if (write(pr2, shared_key2) < 0)
					return this.Invalidate(pr2);
			}
		}
		return 0;
	}

	RunApplication(fname, var step, private_key="", public_key="", shared_key="", debug=false, multiple_host=false, var key_path="") {
		var arguments="";
		var has_arg=Pos(fname, "?");
		if (has_arg>0) {
			arguments=SubStr(fname, has_arg, length fname-has_arg);
			fname=SubStr(fname, 0, has_arg-1);
		}
		if (fname=="/")
			fname="";

		if (!fname)
			fname="start.con";

		var hash_base="";
		fname=this.Owner.NormalizeName(fname, hash_base);

		var ip="unknown";
		var port=-1;

		var info=Socket.Info;
		if (info) {
			ip=info["address"];
			port=info["port"];
		}

		var host_root="";

		var server_root=IniGet(Owner.IniFile, "Paths", "ServerRoot", "");

		if (this.ServerName)
			host_root=IniGet(Owner.IniFile, "Paths", "HostRoot(${this.ServerName})", "");

		if (!host_root)
			host_root=server_root;

		if (!host_root)
			throw "Server has no valid root directory";

		var check_full_path = "$host_root/$fname";
		if (!FileExists(check_full_path))
			throw "File '$check_full_path' does not exists\n";

		if (CONCEPT_STRICT_EXECUTE) {
			if (!FileExists(check_full_path + ".accel"))
				throw "File '$check_full_path' has no compiled version\n";
		}

		if (!this.APID) {
			Owner.APID++;
			if (Owner.APID>0x7FFFFFFF)
				Owner.APID=1;
			this.APID=Owner.APID;
		}

		var log_str="$fname";
		if (arguments)
			log_str+="("+arguments+")";
		if (this.ServerName)
			Owner.Log(ip, "Using server ${this.ServerName}, APID: "+this.APID);
		Owner.Log(ip, "Run $log_str");
		//if (this.Session)
		//	Owner.Log(ip, "Session ${this.Session}");

		var cwd = getcwd();
		var shared_pool = value IniGet(Owner.IniFile, "Server", "UseSharedMemoryPool", "0");
		var inc_dir = this.Owner.IniGetPath("Paths", "Include") + "/";
		var lib_dir = this.Owner.IniGetPath("Paths", "Library") + "/";
		var safe_run = this.Owner.IniGetPath("Paths", "SafeMode", "runsafe");

		var direct_pipe1=-1;
		var direct_pipe2=-1;

		if (DirectPipe==-1) {
			if (socketpair(direct_pipe1, direct_pipe2)) {
				Owner.Log(ip, "Error creating direct pipe (${_errno()}), APID: "+this.APID);
			} else {
				DirectPipe=direct_pipe2;
				if (SetNonBlocking(direct_pipe2, true))
					Owner.Log(ip, "Cannot set non-blocking pipe (${_errno()}), APID: "+this.APID);
			}
		}
		var pipein1=-1;
		var pipein2=-1;

		var pipeout1=-1;
		var pipeout2=-1;

		if (this.PipeOut==-1) {
			if (pipe(pipein1, pipein2))
				Owner.Log(ip, "Error creating in pipe (${_errno()}), APID: "+this.APID);
			else {
				this.PipeOut=pipein2;
				if (SetNonBlocking(pipein2, true))
					Owner.Log(ip, "Cannot set non-blocking pipe (pipe in error: ${_errno()}), APID: "+this.APID);
			}
		}

		if (this.PipeIn==-1) {
			if (pipe(pipeout1, pipeout2))
				Owner.Log(ip, "Error creating out pipe (${_errno()}), APID: "+this.APID);
			else {
				this.PipeIn=pipeout1;
				if (SetNonBlocking(pipeout1, true))
					Owner.Log(ip, "Cannot set non-blocking pipe (pipe out error: ${_errno()}), APID: "+this.APID);
			}
		}

		var hostapp = null;
		var ws = this.IsWebSocket;
		var baseid = "$host_root/$fname";
		var hostid = baseid + ":" + ws;
		if ((ws) && (arguments)) {
			if ((Pos(arguments, "parent=") == 1) || (Pos(arguments, "&parent=") > 1)) {
				var arg_p_arr = StrSplit(arguments, "parent=");
				if (arg_p_arr)
					this.Parent = value arg_p_arr[length arg_p_arr - 1];

				if ((Pos(arguments, "debug=") == 1) || (Pos(arguments, "&debug=") > 1)) {
					arg_p_arr = StrSplit(arguments, "debug=");
					if (arg_p_arr) {
						debug = value arg_p_arr[length arg_p_arr - 1];
						if (debug) {
							private_key="";
							public_key="";
							shared_key="";
							multiple_host=false;
						}
					}
				}
			}
		}

		if (multiple_host) {
			multiple_host = value IniGet(baseid+".manifest", "Application", "Workers", "0");

			if (multiple_host==1)
				multiple_host = 100;

			this.MaxChilds = multiple_host;
		}

		if (this.TLS == 2) {
			private_key="";
			public_key="";
			// padding => > 16 bytes
			shared_key = "----SSL DATA----" + Socket.Save();
		}

		if ((debug) || (!multiple_host)) {
			var shared_hex = StringToHex(shared_key);

			this.PID = ExecuteProcess(safe_run, host_root,
					// parameters
					["Direct pipe"	=> ""+direct_pipe1,
					 "Pipe in"	=> ""+pipein1,
					 "Pipe out"	=> ""+pipeout2,
					 "APID"		=> ""+this.APID,
					 "Parent"	=> ""+this.Parent,
					 "Filename"	=> fname,
					 "Socket"	=> ""+Socket.Socket,
					 "Include dir"	=> inc_dir,
					 "Library dir"	=> lib_dir,
					 "Public key"	=> StringToHex(this.Key),
					 "Private key"	=> shared_hex,
					 "Shared secret"=> shared_hex,
					 "Arguments"	=> arguments
					],

					// environment
					["CONCEPT_FILENAME=$fname",
					 "CONCEPT_HOSTROOT=$host_root",
					 "CONCEPT_SERVERNAME=${this.ServerName}",
					 "CONCEPT_INCLUDE=$inc_dir",
					 "CONCEPT_LIBRARY=$lib_dir",
					 "CONCEPT_ROOT=$server_root/",
					 "CONCEPT_DEBUG=$debug",
					 "CONCEPT_UseSharedMemoryPool=$shared_pool",
					 "CONCEPT_TLS=${this.TLS}",
					 "REMOTE_IP=$ip",
					 "REMOTE_PORT=$port",
					 "CONCEPT_WSPROTO=${this.IsWebSocket}",
					 "DRM_KEY=${this.Key}",
					 "CONCEPT_SERVERPATH="+cwd,
					 "CONCEPT_INIPATH=${Owner.IniFile}",
					 "CONCEPT_CERTIFICATE="+key_path,
					 "CONCEPT_LOGFILE=${Owner.LogFile}"
					],

					// don't wait
					false
			);
		} else {
			hostapp = this.Owner.GetHost(hostid);
		}

		if (hostapp) {
			hostapp.ChildCount++;
			this.UsingHost = hostapp.APID;
			this.UsingPID = hostapp.PID;

			if (AddChild(hostapp.ContextOut, shared_key, pipein1, pipeout2, direct_pipe1, hostapp.PID)) {
				hostapp.ChildCount--;
				hostapp.HostID = "";
				this.UsingHost = -1;
				this.PID = -1;
				step = 5;
				return;
			}
			this.PID = -2;
		} else
		if (this.PID<=0) {
			var pr1, pr2;
			var pw1, pw2;

			if (socketpair(pr1, pr2))
				Owner.Log(ip, "Error creating in context socket pair (${_errno()}), APID: "+this.APID);
			if (socketpair(pw1, pw2))
				Owner.Log(ip, "Error creating in context socket pair (${_errno()}), APID: "+this.APID);

			// leave it blocking !
			//if (SetNonBlocking(pr2, true))
			//	Owner.Log(ip, "Cannot set non-blocking context (pipe out error: ${_errno()}), APID: "+this.APID);

			if (SetNonBlocking(pw1, true))
				Owner.Log(ip, "Cannot set non-blocking context (pipe out error: ${_errno()}), APID: "+this.APID);

			if ((pr1>0) && (pw2>0)) {
				this.HostID=hostid;
				this.PID=ExecuteProcess(safe_run, host_root, [fname, inc_dir, lib_dir, ""+pr1, ""+pw2], 
					// environment
					["CONCEPT_FILENAME=$fname",
					 "CONCEPT_HOSTROOT=$host_root",
					 "CONCEPT_SERVERNAME=${this.ServerName}",
					 "CONCEPT_INCLUDE=$inc_dir",
					 "CONCEPT_LIBRARY=$lib_dir",
					 "CONCEPT_ROOT=$server_root/",
					 "CONCEPT_DEBUG=$debug",
					 "CONCEPT_UseSharedMemoryPool=$shared_pool",
					 "CONCEPT_TLS=${this.TLS}",
					 "REMOTE_IP=$ip",
					 "REMOTE_PORT=$port",
					 "CONCEPT_WSPROTO=${this.IsWebSocket}",
					 "DRM_KEY=${this.Key}",
					 "CONCEPT_SERVERPATH="+cwd,
					 "CONCEPT_INIPATH=${Owner.IniFile}",
					 "CONCEPT_CERTIFICATE="+key_path,
					 "CONCEPT_LOGFILE=${Owner.LogFile}"
					],

					// don't wait
					false
				);
				this.UsingPID = this.PID;
				this.ChildCount=1;
				AddChild(pr2, shared_key, pipein1, pipeout2, direct_pipe1, this.UsingPID);

				close(pr1);
				close(pw2);

				this.ContextIn = pw1;
				this.ContextOut = pr2;

				this.Timestamp = time();
			}
		}

		if (((this.PID>0) || (this.PID==-2)) && (this.APID>0)) {
			Owner.Connections[""+this.APID] = this;
			this.Hash=Murmur(hash_base);
		}

		if (direct_pipe1!=-1)
			close(direct_pipe1);

		if (pipein1!=-1)
			close(pipein1);

		if (pipeout2!=-1)
			close(pipeout2);

		if (this.PID==-2) {
			Owner.Log(ip, "New child connection for $hostid");
		} else
		if (this.PID<0) {
			Owner.Log(ip, "Error creating child process");
			throw "Error creating child process";
		}
		step++;
	}

	ExecuteCommand(command, private_key, public_key, var step, var key_path, allow_debug=true) {
		var arr=StrSplit(command, " ");
		var predicate=ToLower(""+arr[0]);
		switch (predicate) {
			case "get":
				if (arr[1])
					this.ExecuteGet(arr[1], arr[2], private_key, step);
				break;
			case "set":
				if ((arr[1]) && (arr[2]))
					this.ExecuteSet(arr[1], arr[2]);
				break;
			case "getparent":
				this.WriteExact("-1\r\n", false, true);
				break;
			case "runfast":
				var fname=arr[1];
				DecryptKey(private_key);
				this.RunApplication(fname, step, "", "", "", false, true, key_path);
				break;
			case "run":
				fname=arr[1];
				DecryptKey(private_key);
				this.RunApplication(fname, step, private_key, public_key, this.Key, false, true, key_path);
				break;
			case "rundebug":
				fname=arr[1];
				DecryptKey(private_key);
				if (allow_debug)
					this.RunApplication(fname, step, "", "", "", true, false, key_path);
				else {
					throw "Debugging is disabled";
					break;
				}
				break;
			case "pipe":
				var parent=value arr[1];
				if (parent>0)
					this.Parent=parent;
				break;
			case "pipew":
				break;
			case "piper":
				break;
			case "close":
				throw "Socket closed by remote host";
				break;
		}
	}

	Send(var data) {
		if ((this.MaxBuffer <= 0) || (length APIDBuf + length data <= this.MaxBuffer)) {
			APIDBuf+=data;
			return true;
		}
		return false;
	}

	RemoveChild(app_id, ip) {
		var client = this.Owner.GetConnection(app_id);
		if (client) {
			this.ChildCount--;
			// don't accept any more connections
			if (this.ChildCount <= 0)
				this.HostID = "";

			if (client==this) {
				return true;
			} else {
				this.Owner.Connections[""+app_id] = null;
				this.Owner.PlaceHolders++;
				client.PID = -3;
				// return true;
			}
		} else
			Owner.Log(ip, "Invalid APID: $app_id");
		return false;
	}


	IterateService() {
		var pipein1=0;
		var pipein2=0;

		var pipeout1=0;
		var pipeout2=0;

		if (this.PipeOut==-1) {
			if (pipe(pipein1, pipein2))
				Owner.Log("ConceptService", "Error creating in pipe (${_errno()}), APID: "+this.APID);
			else {
				this.PipeOut=pipein2;
				if (SetNonBlocking(pipein2, true))
					Owner.Log("ConceptService", "Cannot set non-blocking pipe (pipe in error: ${_errno()}), APID: "+this.APID);
			}
		}

		if (this.PipeIn==-1) {
			if (pipe(pipeout1, pipeout2))
				Owner.Log("ConceptService", "Error creating out pipe (${_errno()}), APID: "+this.APID);
			else {
				this.PipeIn=pipeout1;
				if (SetNonBlocking(pipeout1, true))
					Owner.Log("ConceptService", "Cannot set non-blocking pipe (pipe out error: ${_errno()}), APID: "+this.APID);
			}
		}

		var max_iap = value IniGet(Owner.IniFile, "Server", "MaxInterAppMessageBuffer", "1024");
		if (max_iap < 0)
			max_iap = 0;

		this.MaxBuffer = max_iap;

		if (!this.APID) {
			Owner.APID++;
			if (Owner.APID>0x7FFFFFFF)
				Owner.APID=1;
			this.APID=Owner.APID;
		}

		var pipein=this.PipeIn;
		var pipeout=this.PipeOut;
		var ref_owner=this.Owner;
		var apid=this.APID;

		Owner.Connections[""+apid] = this;

		var server_root=IniGet(Owner.IniFile, "Paths", "ServiceRoot", "");
		var inc_dir = this.Owner.IniGetPath("Paths", "Include") + "/";
		var lib_dir = this.Owner.IniGetPath("Paths", "Library") + "/";
		var safe_run = this.Owner.IniGetPath("Paths", "SafeMode", "runsafe");
		while (Owner.Running) {
			var pid=ExecuteProcess(safe_run, server_root,
					// parameters
					["Direct pipe"	=> "0",
					 "Pipe in"	=> ""+pipein1,
					 "Pipe out"	=> ""+pipeout2,
					 "APID"		=> ""+apid,
					 "Parent"	=> ""+this.Parent,
					 "Filename"	=> this.ServerName,
					 "Socket"	=> "0",
					 "Include dir"	=> inc_dir,
					 "Library dir"	=> lib_dir,
					 "Public key"	=> "",
					 "Private key"	=> "",
					 "Shared secret"=> "",
					 "Arguments"	=> ""
					], 

					// environment
					["CONCEPT_FILENAME=${this.ServerName}",
					 "CONCEPT_HOSTROOT=$server_root",
					 "CONCEPT_SERVERNAME=localhost",
					 "CONCEPT_INCLUDE=$inc_dir",
					 "CONCEPT_LIBRARY=$lib_dir",
					 "CONCEPT_ROOT=$server_root/",
					 "CONCEPT_DEBUG=0",
					 "CONCEPT_WSPROTO=0",
					 "CONCEPT_UseSharedMemoryPool=0",
					 "REMOTE_IP=0.0.0.0",
					 "CONCEPT_LOGFILE=${Owner.LogFile}",
					 "REMOTE_PORT=0",
					 "DRM_KEY="
					],

					// don't wait
					false
			);

			this.PID=pid;
			if (pid>0) {
				this.APIDBuf="";
				var buf="";
				var processed_buffer="";
				var err = false;
				while (ExecuteIsRunning(pid)) {
					if ((pipein > 0) && (!err)) {
						while (read(pipein, buf, 0xFF) > 0) {
							processed_buffer = ref_owner.ProcessMessage(apid, -1, processed_buffer + buf, err);
							if ((max_iap) && (length processed_buffer > max_iap))
								processed_buffer = "";
							if (err)
								break;
						}
					}
					var buf_out = this.APIDBuf;
					if (buf_out) {
						var len = write(pipeout, buf_out);
						if (len>0)
							this.APIDBuf=SubStr(this.APIDBuf, len, length this.APIDBuf);
					}
				}
				if (pid>0) {
					while (read(pipein, buf, 0xFF) > 0) {
						processed_buffer=ref_owner.ProcessMessage(apid, -1, processed_buffer + buf, err);
						if (err)
							break;
					}
					var code=ExecuteJoin(pid);
					if (code)
						Owner.Log("ConceptServer", "$apid: Done (error code: $code)");
					else
						Owner.Log("ConceptServer", "$apid: Done");
				} else
					Owner.Log("ConceptServer", "$apid: Done (child)");

			}
		}

		if (this.DirectPipe>0)
			close(this.DirectPipe);
		if (this.PipeIn>0)
			close(this.PipeIn);
		if (this.PipeOut>0)
			close(this.PipeOut);
	}

	static CleanApp(var app) {
		var len_filename = length app;
		var skip = 0;
		while (len_filename) {
			len_filename--;
			if (app[len_filename] == ".")
				skip++;
			else
				break;
		}
		if (skip)
			app = SubStr(app, 0, length app - skip);
	}

	static NormalizeFilename(filename, var directory) {
		filename=StrReplace(filename, "\\", "/");
		var arr=StrSplit(filename, "/");
		var len=length arr;
		var res="";
		directory="/";

		var arr2=new [];
		for (var i=len-1;i>=0;i--) {
			var d=arr[i];
			if (d=="..") {
				// jump one directory
				i--;
			} else
			if (d!=".")
				arr2[length arr2]=d;
		}
		len=length arr2;
		for (i=len-1;i>=0;i--) {
			d=arr2[i];
			if (d) {
				if (i)
					directory+=d+"/";
				else
					res=d;
			}
		}
		return res;
	}

	GenerateSession(string seed = "") {
		var common = sha256(CryptoRandom(80));
		if (seed)
			return SubStr(seed, 0, length seed - length common) + common;
		return sha1(""+NumberToHex(ClsPtr(this))+"#"+CryptoRandom(80)) + "-" + common;
	}

	GetCookie(key, cookie_str) {
		var arr = StrSplit(cookie_str, ";");
		for (var i = 0; i < length arr; i++) {
			var k = arr[i];
			var a2 = StrSplit(k, "=");
			if ((a2) && (length a2 == 2)) {
				if (trim(a2[0]) == key)
					return trim(a2[1]);
			}
		}
		return "";
	}

	ParseHeader(header, var ws, var ws_key, var origin, var host, var session_to_restore, var if_modified, var keep_alive, var parent, var debug, var content_length, var protocol, var extension) {
		var len = length header;
		content_length = 0;
		var cache = true;
		if (len > MAX_HEADER_PARAMETERS)
			len = MAX_HEADER_PARAMETERS;
		for (var i=1;i<len;i++) {
			var line=header[i];
			var arr=StrSplit(line, ":", true);
			if (length arr>1) {
				var key=ToLower(arr[0]);
				switch (key) {
					case "upgrade":
						if (Pos(ToLower(arr[1]), "websocket")>0)
							ws=true;
						break;
					case "sec-websocket-key":
						ws_key=trim(arr[1]);
						break;
					case "origin":
						var orig="";
						var len2=length arr;
						for (var j=1;j<len2;j++) {
							if (j>1)
								orig+=":";
							orig+=arr[j];
						}
						origin=trim(orig);
						break;
					case "host":
						len2=length arr;
						for (j=1;j<len2;j++) {
							if (j>1)
								host+=":";
							host+=arr[j];
						}
						if (len>1)
							ServerName = trim(arr[1]);
						else
							ServerName = trim(host);
						break;
					case "referer":
					case "origin":
						if (!this.TLS) {
							if (ToLower(trim(""+StrSplit(""+arr[1], "://")[0])) == "https")
								this.TLS = true;
						}
						break;
					//case "concept-parent":
					//	parent = value arr[1];
					//	break;
					//case "concept-tls":
					//	if (!this.TLS)
					//		this.TLS = value arr[1];
					//	break;
					case "cookie":
						var cookie = this.GetCookie("_s", arr[1]);
						if (cookie)
							session_to_restore = cookie;
						break;
					// case "concept-session":
					// 	orig="";
					// 	len2=length arr;
					// 	for (j=1;j<len2;j++) {
					// 		if (j>1)
					// 			orig+=":";
					// 		orig+=arr[j];
					// 	}
					// 	session_to_restore=trim(orig);
					// 	break;
					case "if-modified-since":
						if (cache)
							if_modified = trim(SubStr(line, 18));
						break;
					case "cache-control":
						if (trim(ToLower("" + arr[1])) == "no-cache") {
							if_modified = "";
							cache = false;
						}
						break;
					case "connection":
						if (ToLower(trim(""+arr[1])) == "keep-alive")
							keep_alive = true;
						else
							keep_alive = false;
						break;
					case "sec-websocket-protocol":
						protocol = trim(ToLower("" + arr[1]));
						var proto_description = StrSplit(protocol, "_", true);
						if (proto_description) {
							parent = value proto_description[0];
							debug = value proto_description[1];
						}
						break;
					case "content-length":
						content_length = value arr[1];
						break;
					case "transfer-encoding":
						if (ToLower("" + value arr[1]) == "chunked")
							content_length = -1;
						break;
					case "sec-websocket-extensions":
						extension=trim(arr[1]);
						break;
				}
			}
		}
	}


	Iterate() {
		var step = 0;
		var exc;
		var socket = this.Socket;
		socket.SetOption(IPPROTO_TCP, TCP_NODELAY, 1);
		socket.SetOption(IPPROTO_IP, IP_TOS, 0x10);
		socket.SetOption(SOL_SOCKET, SO_KEEPALIVE, 1);
		socket.SetOption(SOL_SOCKET, SO_LINGER, 0);

		var max_idle = value IniGet(Owner.IniFile, "Server", "MaxInitialIDLE", "10")*1000000;
		var max_iap = value IniGet(Owner.IniFile, "Server", "MaxInterAppMessageBuffer", "1024");
		if (max_iap < 0)
			max_iap = 0;
		var max_age = value IniGet(Owner.IniFile, "Server", "MaxAge", "604800");
		this.MaxBuffer = max_iap;

		if (max_idle < 1000000)
			max_idle = 1000000;

		var orig_idle = max_idle;
		var keep_alive_header = "Keep-Alive: timeout=${max_idle/1000000}";
		max_idle += microseconds();

		var info=socket.Info;
		var ip="unknown";
		if (info)
			ip=info["address"];
		Owner.Log(ip, "Connected(${socket.Socket})");

		var received_data="";
		var disconnected=false;
		var host="";
		var requests_served = 0;
		// don't use local variable socket after this point
		// this.Socket may be changed if a session restore takes place
		try {
			if (this.TLS == 2) {
				socket.PrepareAcceptTLS();
				socket.MakeExportable();
				var start_time = time();
				while (!socket.HandshakeIterate()) {
					if (time() - start_time > 5) {
						echo "Handshake timeout error";
						throw "Handshake timeout error";
					}
				}
				if (socket.ALPN == "h2") {
					// is HTTP/2
					var h2worker = Owner.ChooseH2Worker();
					if (h2worker) {
						h2worker.AddData(BinarizeObject(new H2Container(socket)));
						// not really an exception, just an ugly goto
						throw null;
					}
				}
			}
			if (this.IsWebSocket) {
				var force_tls = value IniGet(Owner.IniFile, "Server", "WebTLSOnly", "0");
				step = 2;
				var remainder = "";
				while (step <= 2) {
					if ((Socket.HasData) || (remainder)) {
						if (remainder) {
							var data = remainder;
							remainder = "";
						} else
							data = Socket.Read(MAX_WS_HEADER_BUF);

						if (!data)
							throw "Broken socket";

						received_data += data;

						Owner.Iterations++;

						if (length received_data > MAX_RECV_BUFFER)
							throw "Data too big";

						var pos = Pos(received_data, "\r\n\r\n");
						if (pos > 0) {
							//pos--;
							requests_served++;
							Socket.SetOption(SOL_SOCKET, SO_RCVTIMEO, 600000);
							var header = StrSplit(SubStr(received_data, 0, pos), "\r\n");
							// DoWSHeader(StrSplit(received_data, "\r\n"), step);
							var len=length header;
							var ws=false;
							var ws_key="";
							var app="";
							var origin="";
							var session_to_restore="";
							var parent=-1;
							var done=true;
							var if_modified="";
							var keep_alive=false;
							var debug=false;
							var in_content_length=0;
							var protocol="";
							var extension="";
							if (len) {
								var line=StrSplit(header[0], " ");
								if (length line > 1) {
									var method=ToUpper(line[0]);
									app=URIDecode(line[1]);
									CleanApp(app);
									if ((method=="GET") || (method == "POST") || (method == "PUT")) {
										ParseHeader(header, ws, ws_key, origin, host, session_to_restore, if_modified, keep_alive, parent, debug, in_content_length, protocol, extension);
										Owner.Log(ip, "$method $app");
									}
								}
							}
							var content_offset = pos + 4;
							if (in_content_length) {
								if (in_content_length < 0) {
									// content is chunked
									keep_alive = false;
								} else {
									var content_len = length received_data - pos;
									if (content_len > 0) {
										remainder = SubStr(received_data, pos + content_len);
										received_data = SubStr(received_data, 0, pos + content_len);
									}
								}
							} else {
								remainder = SubStr(received_data, content_offset);
								received_data = SubStr(received_data, 0, content_offset);
							}
							var orig_app = app;
							if ((ws) && (ws_key)) {
								if ((!TLS) && (force_tls)) {
									WriteExactNoBlocking(Owner.RedirectHeader(orig_app, ServerName));
									keep_alive = false;
									step=4;
									done=true;
								} else {
									var ret_key=WebSocket::AcceptKey(ws_key);
									if (!app)
										app="start.con";

									var extra_header = "";
									var tstamp = StrReplace(StrReplace(asctime(time()), "\r", ""), "\n", "")+" GMT";

									if (origin)
										extra_header+="Access-Control-Allow-Credentials: true\r\nAccess-Control-Allow-Headers: content-type\r\nAccess-Control-Allow-Headers: authorization\r\nAccess-Control-Allow-Headers: x-websocket-extensions\r\nAccess-Control-Allow-Headers: x-websocket-version\r\nAccess-Control-Allow-Headers: x-websocket-protocol\r\nAccess-Control-Allow-Origin: $origin\r\n";

									// cookie valid for 3 days
									var expires=StrReplace(StrReplace(asctime(time() + 259200), "\r", ""), "\n", "")+" GMT";

									var sess = "";
									var sessChild = null;
									var sessChildError = false;
									// limit session restore to https
									if ((session_to_restore) && (WS_SESSION_RESTORE) && (protocol=="restore")) {
										if (TLS)
											sessChild = RestoreWS_Step1(session_to_restore);
										if (!sessChild)
											sessChildError = true;
									}

									if (sessChildError) {
										var header_response="HTTP/1.1 403 Forbidden\r\nServer: " + SERVER_NAME + "\r\n\r\n";
										WriteExactNoBlocking(header_response);
										keep_alive = false;
										step=4;
										done=true;
									} else {
										if (!sess) {
											sess = this.GenerateSession();
											this.Session = sess;
											if (parent > 0)
												this.Parent = parent;
										}
										extra_header += "Set-Cookie: _s=$sess;Expires=$expires\r\n";
										if (extension) {
											if (Pos(extension, "rtc") > 0)
												extra_header += "Sec-WebSocket-Extensions: rtc\r\n";
										}
										header_response="HTTP/1.1 101 Switching Protocols\r\n${extra_header}Connection: Upgrade\r\nDate: $tstamp\r\nSec-WebSocket-Accept: $ret_key\r\nServer: " + SERVER_NAME + "\r\nUpgrade: websocket\r\n\r\n";
										if (length header_response > MAX_WS_HEADER) {
											step=4;
											done=true;
										} else
										if (WriteExactNoBlocking(header_response, true) == length header_response) {
											if ((sessChild) && (RestoreWS_Step2(sessChild))) {
												step=4;
												keep_alive = false;
												done=true;
											} else {
												this.RunApplication(app, step, "", "", "", debug, true);
												done=true;
											}
											max_idle = microseconds() + orig_idle;
										}
									}
								}
							} else
							if ((method) && ((method=="GET") || (method=="POST"))) {
								tstamp=StrReplace(StrReplace(asctime(time()), "\r", ""), "\n", "")+" GMT";
								var ok = false;
								var err = 404;
								var written = 0;
								if (value IniGet(Owner.IniFile, "Server", "HandleWebResources", "1") == 0) {
									app = "";
									err = 503;
								}
								if (app) {
									var pparam = Pos(app, "?");
									var params = "";
									if (pparam > 0) {
										params = SubStr(app, pparam, length app - pparam);
										app = SubStr(app, 0, pparam - 1);
									}
									var orig_path = app;

									var path = this.NormalizeFilename(app, var directory);
									var client_resource = (directory[0] + directory[1] + directory[2] == "/@/");
									if (client_resource)
										directory = SubStr(directory, 2);
									app = directory + path;
									var rewrite = this.Owner.Rewrite;
									if (rewrite)
										app = rewrite(app, params);

									var ext = ToLower(Ext(app));
									var content_type = "application/octet-stream";
									var invalid_app = false;
									if (IsSet(this.Owner.mimetypes, ext)) {
										content_type = this.Owner.mimetypes[ext];
										if (content_type == "application/concept-private") {
											err = 403;
											invalid_app = true;
										}
									}
									var is_root = false;
									var target_app = "start.con";
									if (content_type == "application/concept") {
										target_app = trim(app);
										app = "/index.html";
										content_type = "text/html";
										is_root = true;
										client_resource = true;

										var host_root = this.Owner.IniGetPath("Paths", "ServerRoot", "");
										if (this.ServerName)
											host_root = this.Owner.IniGetPath("Paths", "HostRoot(${this.ServerName})", host_root);

										var real_app_path = host_root + directory + path;
										invalid_app = !FileExists(real_app_path);
									}

									if (ToLower(app) == "/@/index.html")
										is_root = true;

									var requested_path = app;

									var is_server_page = false;
									var cgi;
									if (content_type == "application/concept-server-page") {
										is_server_page = true;
										cgi = this.Owner.cgi;  
									} else
									if (this.Owner.cgiother) {
										if (IsSet(this.Owner.cgiother, content_type)) {
											is_server_page = true;
											cgi = this.Owner.cgiother[content_type];
										}
									}

									var is_redirect = false;
									if (client_resource) {
										var local_app = "";
										if (is_root) {
											var local_app_index = host_root + directory + "@index.html";
											if (FileExists(local_app_index))
												local_app = local_app_index;
										}
										if (local_app)
											app = local_app;
										else
											app = Owner.ConceptClient + app;
									} else {
										var empty_request = false;
										if (app == "/")
											empty_request = true;
										host_root = this.Owner.IniGetPath("Paths", "ServerRoot", "");
										if (this.ServerName)
											host_root = this.Owner.IniGetPath("Paths", "HostRoot(${this.ServerName})", host_root);
										app = host_root + app;
										if ((app) && (DirectoryExists(app))) {
											empty_request = true;
											if (app[length app - 1] != "/") {
												app += "/";
												// auto redirect if no / is present
												if ((orig_path) && (orig_path[length orig_path - 1] != "/")) {
													is_redirect = Owner.Redirect(orig_path + "/", params);
													keep_alive = false;
													empty_request = false;
												}
											}
										}
										if (empty_request) {
											if (FileExists(app + "start.con")) {
												content_type = "text/html";
												target_app = directory + path + "/start.con";
												local_app_index = host_root + "/" + path + "/@index.html";
												if (FileExists(local_app_index))
													app = local_app_index;
												else
													app = Owner.ConceptClient + "/index.html";
												is_root = true;
											} else
											if (FileExists(app + "index.csp")) {
												content_type = "application/concept-server-page";
												app += "index.csp";
											} else {
												content_type = "text/html";
												app += "index.html";
											}
										}

									}

									var exists;
									if (invalid_app) {
										exists = false;
									} else
									if (is_redirect) {
										exists = true;
									} else {
										exists = FileExists(app);
										if ((!exists) && (path[0] == "@")) {
											app = Owner.ConceptClient + "/" + SubStr(path, 1);
											exists = FileExists(app);
										}
									}

									if (exists) {
										var worker = null;
										if ((is_server_page) && (cgi)) //(content_type == "application/concept-server-page")
											worker = Owner.ChooseWorker();
										if (worker) {
											var port = Owner.WSPort;
											if (TLS)
												port = Owner.SSLWSPort;
											var w = new WDataContainer(Socket, app, SubStr(received_data, 0, pos), params, SubStr(received_data, pos + 2), method, this.ServerName, requested_path, port, cgi, host_root);
											worker.AddData(BinarizeObject(w));
											keep_alive = false;
											break;
										} else {
											var connection_policy;
											if (keep_alive)
												connection_policy = "keep-alive\r\n" + keep_alive_header;
											else
												connection_policy = "close";
											var last_mod = rtrim(asctime(_filelast_mod(app))) + " GMT";
											data = "";
											var skip_content = false;
											var content_length = 0;
											var eagain_time = 0;
											if (is_redirect) {
												var buffer = is_redirect;
												data = "0";
												is_redirect = "";
												skip_content = true;
											} else
											if ((!TLS) && (force_tls)) {
												buffer = Owner.RedirectHeader(orig_app, ServerName) ;
												connection_policy = "close";
												keep_alive = false;
												skip_content = true;
											} else
											if (((!is_root) || (!params)) && (if_modified == last_mod)) {
												buffer = "HTTP/1.1 304 Not Modified\r\nDate: $tstamp\r\nConnection: $connection_policy\r\nContent-Type: $content_type\r\nCache-Control: max-age=$max_age\r\nLast-Modified: $last_mod\r\n" + EXTRA_HEADER + "Server: " + SERVER_NAME + "\r\n\r\n";
												skip_content = true;
											} else {
												var extra_origin = "";
												if (is_root) {
													host = trim(host);

													data = ReadFile(app);
													if (params)
														data = StrReplace(data, "{APP}", target_app + "?" + params);
													else
														data = StrReplace(data, "{APP}", target_app);

													var secured = this.TLS;
													if ((!secured) && (Pos(host, ":" + Owner.SSLWSPort) > 0))
														secured = true;
													data = StrReplace(data, "{HOST}", trim(host));
													if (secured)
														data = StrReplace(data, "{PROTOCOL}", "concepts");
													else
														data = StrReplace(data, "{PROTOCOL}", "concept");
													content_length = length data;
													if (secured)
														extra_origin += "Content-Security-Policy: connect-src wss://$host\r\n";
												} else {
													content_length = _filesize(app);
												}
												buffer = "HTTP/1.1 200 OK\r\nDate: $tstamp\r\nConnection: $connection_policy\r\nContent-Type: $content_type\r\nCache-Control: max-age=$max_age\r\nLast-Modified: $last_mod\r\nServer: " + SERVER_NAME + "\r\n" + EXTRA_HEADER + extra_origin + "Strict-Transport-Security: max-age=31536000; includeSubDomains; preload\r\nContent-Length: $content_length\r\n\r\n" + data;
											}
											SocketSetBlocking(Socket.Socket, false);
											var buf_len = length buffer;
											if (data) {
												if ((this.TLS == 2) && (buf_len)) {
													Socket.WritePrepare(buffer);
													while (Socket.WriteIterate())
														yield();
													written = buf_len;
												} else
												while (buf_len > 0) {
													try {
														written = Socket.Write(buffer);
													} catch (exc) {
														// EAGAIN
														err = SocketErrno();
														if (((err != 11) && (err != 35) && (err != 10035)) || ((eagain_time) && (time() - eagain_time > EAGAIN_TIMEOUT_SECONDS)))
															break;
														if (!eagain_time)
															eagain_time = time();
														continue;
													}
													if (written <= 0)
														break;

													buf_len -= written;
													eagain_time = 0;
													if (buf_len > 0)
														buffer = SubStr(buffer, written, buf_len);
												}
											} else {
												if (!skip_content) {
													var file = new File("rb");
													file.Name = app;
													if (!file.Open())
														delete file;
												}

												if ((this.TLS == 2) && (buf_len)) {
													Socket.WritePrepare(buffer);
													while ((Socket.WriteIterate()) || (file)) {
														if (file) {
															if (file.Read(var buf2, READ_BUFFER) > 0) {
																Socket.WritePrepare(buf2);
															} else {
																file.Close();
																file = null;
															}
														}
														yield();
													}
													written = buf_len;
												} else
												while ((buf_len > 0) || (file)) {
													if ((file) && (length buffer < H1_MAX_FILE_BUFFER)) {
														if (file.Read(buf2, READ_BUFFER) > 0) {
															buffer += buf2;
															buf_len += length buf2;
														} else {
															file.Close();
															file = null;
															if (!buf_len)
																break;
														}
													}
													try {
														written = Socket.Write(buffer);
													} catch (exc) {
														// EAGAIN
														err = SocketErrno();
														if (((err != 11) && (err != 35) && (err != 10035)) || ((eagain_time) && (time() - eagain_time > EAGAIN_TIMEOUT_SECONDS))) {
															if (file) {
																file.Close();
																file = null;
															}
															break;
														}
														if (!eagain_time)
															eagain_time = time();
														continue;
													}
													if (written <= 0)
														break;
													buf_len -= written;
													eagain_time = 0;
													if (buf_len > 0)
														buffer = SubStr(buffer, written, buf_len);
													else
														buffer = "";
												}
												if (file) {
													file.Close();
													file = null;
												}
											}
										}
										//WriteExact("HTTP/1.1 200 OK\r\nDate: $tstamp\r\nConnection: close\r\nContent-Type: $content_type\r\nServer: " + SERVER_NAME + "\r\n\r\n" + data);
										ok = true;
										if ((keep_alive) && (written > 0)) {
											step = 2;
											received_data = "";
											host="";
											continue;
										}
									}
								}
								if (!ok) {
									data =  ReadFile(Owner.ConceptClient + "/errors/$err.html");
									if (!data)
										data = "Error $err in processing your request.";

									buffer = "HTTP/1.1 $err\r\nDate: $tstamp\r\nConnection: close\r\nContent-Type: text/html\r\n" + EXTRA_HEADER + "Server: " + SERVER_NAME + "\r\n\r\n" + data;
									buf_len = length buffer;
									SocketSetBlocking(Socket.Socket, false);
									if ((this.TLS == 2) && (buf_len)) {
										Socket.WritePrepare(buffer);
										while (Socket.WriteIterate())
											yield();
										written = buf_len;
									} else
									while (buf_len > 0) {
										try {
											written = Socket.Write(buffer);
										} catch (exc) {
											// EAGAIN
											err = SocketErrno();
											if ((err != 11) && (err != 35) && (err != 10035))
												break;
											continue;
										}
										if (written <= 0)
											break;

										buf_len -= written;
										if (buf_len > 0)
											buffer = SubStr(buffer, written, buf_len);
									}
									//WriteExact("HTTP/1.1 $err\r\nDate: $tstamp\r\nConnection: close\r\nContent-Type: text/html\r\nServer: " + SERVER_NAME + "\r\n\r\n" + data);
								}
								max_idle = microseconds() + orig_idle;
							}
							if (!done)
								step=4;
							break;
						}
					}
					var delta_ms = microseconds() - max_idle;
					if (delta_ms > 0) {
						Owner.Log(ip, "Timed out (${delta_ms/1000}ms)");
						break;
					}
					if (step==-1) {
						// restored
						Owner.Log(ip, "Session restored");
						break;
					}
				}
			} else {
				var key_path = this.Owner.IniGetPath("Paths", "Certificate", "");
				var public_key = ReadFile(key_path+"/server.certificate");
				var private_key = ReadFile(key_path+"/server.key");
				var allow_debug	 = value IniGet(Owner.IniFile, "Server", "AllowDebug", "1");
				if ((!public_key) || (!private_key)) {
					Owner.Log("ConceptServer", "Invalid key path $key_path");
					throw "Invalid keys";
				}

				if (WriteExact(public_key, true)==length public_key + 4) {
					while (step <= 2) {
						if (Socket.HasData) {
							data = Socket.Read();
							if (!data)
								throw "Broken socket";
							received_data+=data;
							Owner.Iterations++;

							if (length received_data>MAX_RECV_BUFFER)
								throw "Data too big";

							received_data = AnalyzeData(received_data, step, private_key, public_key, key_path, allow_debug);
						}

						if (microseconds()>=max_idle) {
							Owner.Log(ip, "Protocol negotiation timed out");
							break;
						}
						if (step==-1) {
							// restored
							Owner.Log(ip, "Session restored");
							break;
						}
					}
				} else
					Owner.Log(ip, "Broken socket on write");
			}

			var pid=this.PID;
			if ((step==3) && ((pid>0) || (pid==-2))) {
				Owner.Log(ip, "Executing");

				var pipein=this.PipeIn;
				var pipeout=this.PipeOut;

				var buf;
				var processed_buffer="";

				// local variables are slightly faster
				var ref_owner=this.Owner;
				var apid=this.APID;
				var hash=this.Hash;

				var ctx_in=this.ContextIn;

				var apidbuf="";
				var orig_host=this.HostID;
				var flush_iterations = 1;

				var execute_start = microseconds();
				// this should never happen
				while ((pid > 0) && (!ExecuteIsRunning(pid))) {
					if (microseconds() - execute_start >= 50000) {
						Owner.Log(ip, "Application failed to start in 50ms.");
						break;
					}
				}
				var apid_err = false;
				while ((this.PID==-2) || ((pid > 0) && (ExecuteIsRunning(pid)))) {
					if ((this.ContextIn>0) && (ctx_in>0)) {
						var r=read(this.ContextIn, var apidbuf2, 4);
						if (r>0) {
							this.Owner.Iterations++;
							apidbuf+=apidbuf2;
							if (length apidbuf>=4) {
								var app_id = tonumber(SubStr(apidbuf, 0, 4), 32);
								apidbuf = SubStr(apidbuf, 4, length apidbuf - 4);
								if (RemoveChild(app_id, ip)) {
									disconnected=true;
									pipein=-1;
									this.Disconnect(ip, "clean");
								}
								if (this.ChildCount<=0) {
									this.HostID="";
									// no children, unload from memory
									write(this.ContextOut, tobin(-1, 32));
									ctx_in = -1;
								}
							}
						}
					}

					if (pipein > 0)  {
						while ((!apid_err) && (read(pipein, buf, 0xFF) > 0)) {
							this.Owner.Iterations++;
							processed_buffer=ref_owner.ProcessMessage(apid, hash, processed_buffer + buf, apid_err);
							if ((max_iap) && (length processed_buffer > max_iap))
								processed_buffer="";
							if (processed_buffer)
								flush_iterations = 1000;
							else
								flush_iterations = 1;
						}
						var buf_out=this.APIDBuf;
						if (buf_out) {
							//var len;
							if (length buf_out > 1024)
								len = write(pipeout, SubStr(buf_out, 0, 1024));
							else
								len = write(pipeout, buf_out);

							if (len>0)
								this.APIDBuf = SubStr(this.APIDBuf, len, length this.APIDBuf);
						}
					}
				}
				if (this.Parent > 0)
					ref_owner.ProcessMessage(apid, hash, tobin(this.Parent, 32) + tobin(-6, 32) + tobin(4, 32) + "done", apid_err);

				if (orig_host)
					Owner.CloseChildren(this.APID);

				if (apid>0) {
					RemoveChild(apid, ip);
					Owner.Connections[""+apid] = null;
					Owner.PlaceHolders++;
				}

				if (pid > 0) {
					if (pipein > 0) {
						while (read(pipein, buf, 0xFF) > 0) {
							processed_buffer=ref_owner.ProcessMessage(apid, hash, processed_buffer + buf, apid_err);
							if (apid_err)
								break;
						}
					}
					var code=ExecuteJoin(pid);
					if (code)
						Owner.Log(ip, "$apid: Done (error code: $code)");
					else
					
						Owner.Log(ip, "$apid: Done");
				} else
					Owner.Log(ip, "$apid: Done (child)");
			}
		} catch (exc) {
			// broken socket
		}
		if (!disconnected)
			this.Disconnect(ip, "iterate");

		if (this.ContextIn>0) {
			close(this.ContextIn);
			this.ContextIn = -1;
		}
		if (this.ContextOut>0) {
			close(this.ContextOut);
			this.ContextOut = -1;
		}
		if (file) {
			file.Close();
			file = null;
		}
		this.Owner.threads--;
	}

	Disconnect(ip, reason = "") {
		if (this.DirectPipe>0) {
			close(this.DirectPipe);
			this.DirectPipe = -1;
		}
		if (this.PipeIn>0) {
			close(this.PipeIn);
			this.PipeIn = -1;
		}
		if (this.PipeOut>0) {
			close(this.PipeOut);
			this.PipeOut = -1;
		}

		if (this.Socket) {
			if (reason)
				reason = ", reason: " + reason;
			Owner.Log(ip, "Disconnected(${this.Socket.Socket}, ${this.APID}$reason)");
			SocketSetBlocking(this.Socket.Socket, false);
			this.Socket.Close();
		}
	}

	finalize() {
		Owner.ClientCount--;
		Owner.Log("ConceptServer", "${Owner.ClientCount} active client(s)");
		Owner.Clean();
	}
}

class ConceptCGIChild {
	var std_out;
	var std_in;
	var Socket;
	var pid;
	var std_in_buffer = "";
	var std_out_buffer = "";
	var h2;
	var stream;
	var h2headers;
	var is_post;
	var last_err_time;
	var last_pipe_err_time;
	var last_pipe_err_time_read;

	ConceptCGIChild(method, Socket, std_out, std_in, pid, buffer, h2 = null, stream = null, default_h2_header = null) {
		this.is_post = true;//(method != "GET");
		this.std_out = 	std_out;
		this.std_in = std_in;
		this.Socket = Socket;
		this.pid = pid;
		this.std_in_buffer = buffer;
		this.h2 = h2;
		this.stream = stream;
		this.h2headers = default_h2_header;

		SetNonBlocking(std_out, true);
		SetNonBlocking(std_in, true);
		SocketSetBlocking(Socket.Socket, false);

		if (h2) {
			h2.MaxOutputBuffer = H2_MAX_STDOUT_BUFFER;
			h2.MaxFileBuffer = H2_MAX_FILE_BUFFER;
		}
	}

	Join() {
		if (pid > 0) {
			if (ExecuteIsRunning(pid))
				kill(__PID(pid), SIGKILL);

			ExecuteJoin(pid);
			pid = 0;
		}
	}

	H2Close() {
		if ((h2) && (stream)) {
			Join();
			h2.UserData--;
			var exc;
			try {
				if (stream.Status == 2)
					stream.Write(h2, "", true);
				delete h2;
				delete stream;
				delete Socket;
			} catch (exc) {
				echo "ConceptCGIChild/HTTP/2 Socket close error: $exc\n";
			}
		}
	}

	Close() {
		Join();
		std_in_buffer = "";
		std_out_buffer = "";
		if ((h2) && (stream)) {
			try {
				stream.Close(h2);
				delete h2;
				delete stream;
				delete Socket;
			} catch (var exc) {
				echo "ConceptCGIChild/HTTP/2 Socket close error: $exc\n";
			}
		} else
		if (Socket) {
			try {
				Socket.Close();
				delete Socket;
			} catch (exc) {
				echo "ConceptCGIChild/Socket close error: $exc\n";
			}
		}

		if (std_out > 0) {
			close(std_out);
			std_out = 0;
		}
		if (std_in > 0) {
			close(std_in);
			std_in = 0;
		}
	}

	ParseHeaders(h2headers, buffer) {
		var arr = StrSplit(buffer, "\n");
		for (var i = 0; i < length arr; i++) {
			var e = arr[i];
			if (e) {
				var pos = Pos(e, ":");
				if (pos > 0) {
					var k = ToLower(trim(SubStr(e, 0, pos - 1)));
					var val = trim(SubStr(e, pos));
					h2headers[k] = val;
				}
			}
		}
	}

	Iterate(var ops) {
		var running = ExecuteIsRunning(pid);
		if (running) {
			try {
				if (stream) {
					if (stream.HasData()) {
						var buf = stream.Read();
						if (this.is_post)
							std_in_buffer += buf;
						ops++;
					}
				} else
				if (Socket.HasData) {
					buf = Socket.Read(MAX_RECV_BUFFER);
					if (!buf)
						return true;
					if (this.is_post)
						std_in_buffer += buf;
					ops ++;
				}
			} catch (var exc) {
				// socket closed
				return true;
			}

			if ((std_in) && (std_in_buffer)) {
				var res = write(std_in, std_in_buffer);
				if (res > 0) {
					ops ++;
					std_in_buffer = SubStr(std_in_buffer, res);
					last_pipe_err_time = 0;
				}
				if (res <= 0) {
					var pipe_err = _errno();
					if ((pipe_err != 11) && (pipe_err != 35) && (pipe_err != 28) && (pipe_err != 22)) {
						echo "CGI pipe write error: $pipe_err\n";
						return true;
					}
					if ((last_pipe_err_time) && (time() - last_pipe_err_time >= CGI_MAX_RETRY_SECONDS)) {
						echo "CGI write congestion\n";
						return true;
					}
					last_pipe_err_time = time();
				}
			}
		}

		if ((std_out) && (length std_out_buffer < PIPE_MAX_STDOUT_BUFFER)) {
			var s = microseconds();
			var bytes_read = 0;
			do {
				res = read(std_out, var buffer, MAX_RECV_BUFFER);
				if (res > 0) {
					bytes_read += res;
					std_out_buffer += buffer;
					ops ++;
					last_pipe_err_time_read = 0;
					// CPU time
					if ((microseconds() - s > PIPE_READ_CPU_TIME_US) || (bytes_read >= MAX_RECV_BUFFER))
						break;
				}
			} while (res > 0);
			// read returns 0 if pipe closed
			if (res <= 0) {
				pipe_err = _errno();
				if ((pipe_err != 11) && (pipe_err != 35) && (pipe_err != 28) && (pipe_err != 22) && (res)) {
					echo "CGI pipe read error: $pipe_err\n";
					return true;
				}
				if ((last_pipe_err_time_read) && (time() - last_pipe_err_time_read >= CGI_MAX_RETRY_SECONDS)) {
					echo "CGI pipe congestion\n";
					return true;
				}
				last_pipe_err_time_read = time();
			}

		}
		if (std_out_buffer) {
			if (stream) {
				var stream_write = true;
				try {
					if (h2headers) {
						var header_pos = Pos(std_out_buffer, "\r\n\r\n");
						if (header_pos > 0) {
							this.ParseHeaders(h2headers, SubStr(std_out_buffer, 0, header_pos));
							stream.Response(h2, h2headers);
							h2headers = null;
							std_out_buffer = SubStr(std_out_buffer, header_pos + 3);
						} else {
							if (!running) {
								// just dump the output ... no header was received
								stream.Response(h2, h2headers);
								h2headers = null;
							} else {
								// read 64k bytes, no header found
								if (length std_out_buffer >= MAX_RECV_BUFFER)
									return true;
								stream_write = false;
							}
						}
					}
					if (stream_write) {
						var close_stream = false;
						if ((!running) && (stream.AtomicWriteSize(length std_out_buffer) == length std_out_buffer))
							close_stream = true;
						res = stream.SafeWrite(h2, std_out_buffer, close_stream);
						if (res > 0) {
							std_out_buffer = SubStr(std_out_buffer, res);
							ops ++;
						}
					}
				} catch (exc) {
					return true;
				}
			} else
			if (Socket) {
				try {
					res = Socket.Write(std_out_buffer);
					if (res > 0) {
						std_out_buffer = SubStr(std_out_buffer, res);
						ops ++;
						if (length std_out_buffer > CGI_MAX_STDOUT_BUFFER) {
							echo "CGI stdout buffer overflow\n";
							return true;
						}
						last_err_time = 0;
					}
				} catch (exc) {
					// EAGAIN ?
					var err = SocketErrno();
					if ((err != 11) && (err != 35) && (err != 10035))
						return true;

					if ((last_err_time) && (time() - last_err_time >= CGI_MAX_RETRY_SECONDS)) {
						echo "CGI write congestion\n";
						return true;
					}
					last_err_time = time();
				}
			}
		}
		if ((!std_out_buffer) && (!running)) {
			H2Close();
			return true;
		}
		return false;
	}

	static CreatePipes(var std_out_r, var std_out_w, var std_in_r, var std_in_w, var err_text) {
		if (socketpair(std_out_r, std_out_w)) {
			err_text = "ConceptCGIChild: Error creating pipe (stdout)";
			return -1;
		}
		if (socketpair(std_in_r, std_in_w)) {
			close(std_out_r);
			close(std_out_w);
			err_text = "ConceptCGIChild: Error creating pipe (stdin)";
			return -1;
		}
		return 0;
	}

	finalize() {
		Close();
	}
}

class ConceptWorker {
pragma used
	protected var WorkerName;
	protected var[] Children;
	protected var Placeholders;

	GetHeader(job, header_name, var headers_lowercase) {
		var cookie = "";
		var needle = "\n$header_name:";
		var pos = Pos(headers_lowercase, needle);
		if (pos) {
			cookie = trim(SubStr(job.headers, pos + length needle));
			pos = Pos(cookie, "\n");
			if (pos > 0)
				cookie = trim(SubStr(cookie, 0, pos));
		}
		return cookie;
	}

	Create(Socket, job, var err_text) {
		if (ConceptCGIChild::CreatePipes(var std_out_r, var std_out_w, var std_in_r, var std_in_w, err_text))
			return null;

		var cgi_handler_path = job.cgihandler;

		var info = Socket.Info;
		var address = info["address"];
		var port = info["port"];
		var headers_lowercase = ToLower(job.headers);
		var env = [
				"DOCUMENT_ROOT=" + job.root,
				"GATEWAY_INTERFACE=CGI/1.1",
				"HTTP_COOKIE=" + this.GetHeader(job, "cookie", headers_lowercase),
				"HTTP_HOST=" + job.hostname,
				"HTTP_USER_AGENT=" + this.GetHeader(job, "user-agent", headers_lowercase),
				"PATH_INFO=" + job.path,
				"PATH_TRANSLATED=" + job.app,
				"QUERY_STRING=" + job.query,
				"REMOTE_ADDR=" + address,
				"REMOTE_HOST=" + address,
				"REMOTE_PORT=" + port,
				"REMOTE_USER=",
				"REQUEST_METHOD=" + job.method,
				"REQUEST_URI=" + job.path,
				"SCRIPT_FILENAME=" + job.app,
				"SCRIPT_NAME=" + cgi_handler_path,
				"SERVER_ADMIN=",
				"SERVER_NAME=" + job.hostname,
				"SERVER_PORT=" + job.port,
				"SERVER_PROTOCOL=HTTP/1.1",
				"SERVER_SOFTWARE=" + SERVER_SOFTWARE,
				"REDIRECT_STATUS=200",
				"REDIRECT_STATUS=CGI",
				"CONTENT_LENGTH=" + this.GetHeader(job, "content-length", headers_lowercase),
				"CONTENT_TYPE=" + this.GetHeader(job, "content-type", headers_lowercase),
				"HTTP_ACCEPT_LANGUAGE=" + this.GetHeader(job, "accept-language", headers_lowercase),
				"HTTP_ACCEPT_ENCODING=" + this.GetHeader(job, "accept-encoding", headers_lowercase),
				"HTTP_REFERER=" + this.GetHeader(job, "referer", headers_lowercase)
		];
		if (classof Socket == "TLSESocket") {
			env[length env] = "HTTPS=on";
			env[length env] = "HTTPS_CIPHER=" + Socket.CipherName;
		}

		var pid = ExecuteProcess(cgi_handler_path, "", [job.app], env, false, std_out_w, std_in_r);

		close(std_out_w);
		close(std_in_r);

		if (pid <= 0) {
			close(std_out_r);
			close(std_in_w);
			if (!err_text)
				err_text = "ConceptWorker: Error creating process\n";
			return null;
		}

		return new ConceptCGIChild(job.method, Socket, std_out_r, std_in_w, pid, job.snippet);
	}

	AddChild(child) {
		if (Placeholders > 0) {
			for (var i = 0; i < length Children; i++) {
				if (!Children[i]) {
					Children[i] = child;
					Placeholders--;
					return;
				}
			}
		}
		Children[length Children] = child;
	}

	Clean() {
		var new_children = new [];
		var children = this.Children;
		if (Placeholders == length children) {
			this.Children = new_children;
			Placeholders = 0;
			return;
		}

		for (var i = 0; i < length children; i++) {
			var child = children[i];
			if (child)
				new_children[length new_children] = child;
		}
		Placeholders = 0;
	}


	Iterate() {
		var children = this.Children;
		var res = 0;
		for (var i = 0; i < length children; i++) {
			var child = children[i];
			if (child) {
				if (child.Iterate(res)) {
					child.Close();
					children[i] = null;
					Placeholders ++;
				}
			}
		}
		if (Placeholders >= 20)
			this.Clean();
		return res;
	}

	static RealPath(path) {
		var res = "";
		var arr = StrSplit(path, "/");
		for (var i = length arr - 1; i >= 0; i--) {
			var e = arr[i];
			if (e == "..") {
				i--;
			} else {
				if (res)
					res = arr[i] + "/" + res;
				else
					res = arr[i];
			}
		}
		return res;
	}

	ConceptWorker(n) {
		WorkerName = n;
		var empty_iterations = 0;
		while (true) {
			var work_count = 0;
			if (Worker::Pending(var data)) {
				work_count++;
				var job = UnBinarizeObject(data);
				if (job) {
					if (Pos(job.app, ".."))
						job.app = this.RealPath(StrReplace(job.app, "\\", "/"));
					var Socket;
					try {
						if (job.tls) {
							Socket = new TLSESocket(job.socket);
							Socket.Restore(job.tls);
						} else
							Socket = new TCPSocket(job.socket);

						var child = this.Create(Socket, job, var err_text);
						if (child) {
							Socket.Write("HTTP/1.1 200 OK\r\nServer: " + SERVER_NAME + "\r\n");
							AddChild(child);
						} else {
							Socket.Write("HTTP/1.1 503 Service unavailable\r\nServer: " + SERVER_NAME + "\r\nContent-Type: text/html\r\n\r\n<html><head><title>HTTP 503 Service unavailable</title></head><body><h1>HTTP 503 Service unavailable</h1><br/>$err_text</body></html>");
							Socket.Close();
						}
					} catch (var exc) {
						echo "Exc: $exc\n";
						delete Socket;
					}
				}
			}
			work_count += this.Iterate();
			if (work_count) {
				empty_iterations = 0;
			} else {
				empty_iterations++;
				if (empty_iterations > IDLE_SLEEP_THRESHOLD)
					Sleep(IDLE_SLEEP_MS2);
				else
					Sleep(IDLE_SLEEP_MS);
			}

			// if (!work_count)
			//	Sleep(IDLE_SLEEP_MS);
		}
	}
}

class ConceptH2Worker extends RewriteContainer {
pragma used
	protected var WorkerName;
	protected var[] Children;
	protected var[] CGIChildren;
	protected var Placeholders;
	protected var CGIPlaceholders;
	protected var IniFile;
	protected var ConceptClient;
	protected var mimetypes;
	protected var conceptcgi;
	protected var cgiother;

	GetHeader(key, headers) {
		if (!IsSet(headers, key))
			return "";
		var val = headers[key];
		if (typeof val == "array") {
			var res = "";
			for (var i = 0; i < length val; i++) {
				if (res)
					res += ";";
				res += val[i];
			}
			return res;
		}
		return val;
	}

	CreateCGI(h2, stream, cgi_handler_path, root, path, app, query, hostname_port, var err_text) {
		if (ConceptCGIChild::CreatePipes(var std_out_r, var std_out_w, var std_in_r, var std_in_w, err_text))
			return null;

		var headers = stream.Headers;
		var Socket = h2.GetSocket();
		var info = Socket.Info;
		var address = info["address"];
		var port = info["port"];
		var host_arr = StrSplit(hostname_port, ":");
		var local_port = 443;
		var hostname;

		if (length host_arr > 1) {
			var tmp = value host_arr[length host_arr - 1];
			if (tmp) {
				local_port = tmp;
				hostname = SubStr(hostname_port, 0, (length hostname_port) - (length ":$tmp"));
			}
		} else
			hostname = hostname_port;
		var method = this.GetHeader(":method", headers) ?? "GET";
		var env = [
				"DOCUMENT_ROOT=" + root,
				"GATEWAY_INTERFACE=CGI/1.1",
				"HTTP_COOKIE=" + this.GetHeader("cookie", headers),
				"HTTP_HOST=" + hostname,
				"HTTP_USER_AGENT=" + this.GetHeader("user-agent", headers),
				"PATH_INFO=" + path,
				"PATH_TRANSLATED=" + app,
				"QUERY_STRING=" + query,
				"REMOTE_ADDR=" + address,
				"REMOTE_HOST=" + address,
				"REMOTE_PORT=" + port,
				"REMOTE_USER=",
				"REQUEST_METHOD=" + method,
				"REQUEST_URI=" + path,
				"SCRIPT_FILENAME=" + app,
				"SCRIPT_NAME=" + cgi_handler_path,
				"SERVER_ADMIN=",
				"SERVER_NAME=" + hostname,
				"SERVER_PORT=" + local_port,
				"SERVER_PROTOCOL=HTTP/2.0",
				"SERVER_SOFTWARE=" + SERVER_SOFTWARE,
				"REDIRECT_STATUS=200",
				"REDIRECT_STATUS=CGI",
				"CONTENT_LENGTH=" + this.GetHeader("content-length", headers),
				"CONTENT_TYPE=" + this.GetHeader("content-type", headers),
				"HTTP_ACCEPT_LANGUAGE=" + this.GetHeader("accept-language", headers),
				"HTTP_ACCEPT_ENCODING=" + this.GetHeader("accept-encoding", headers),
				"HTTP_REFERER=" + this.GetHeader("referer", headers)
		];

		if (classof Socket == "TLSESocket") {
			env[length env] = "HTTPS=on";
			env[length env] = "HTTPS_CIPHER=" + Socket.CipherName;
		}

		var pid = ExecuteProcess(cgi_handler_path, "", [app], env, false, std_out_w, std_in_r);

		close(std_out_w);
		close(std_in_r);

		if (pid <= 0) {
			close(std_out_r);
			close(std_in_w);
			if (!err_text)
				err_text = "ConceptWorker: Error creating process\n";
			return null;
		}

		var cgi = new ConceptCGIChild(method, Socket, std_out_r, std_in_w, pid, "", h2, stream);
		if (cgi) {
			CGIChildren[length CGIChildren] = cgi;
			h2.UserData++;
		}
		return cgi;
	}

	AddChild(child) {
		child.MaxErrorTimeout = CGI_MAX_RETRY_SECONDS;
		if (Placeholders > 0) {
			for (var i = 0; i < length Children; i++) {
				if (!Children[i]) {
					Children[i] = child;
					Placeholders--;
					return;
				}
			}
		}
		Children[length Children] = child;
	}

	Clean(children, var pholders) {
		var new_children = new [];

		if (pholders == length children) {
			pholders = 0;
			return new_children;
		}

		for (var i = 0; i < length children; i++) {
			var child = children[i];
			if (child)
				new_children[length new_children] = child;
		}
		pholders = 0;
		return new_children;
	}

	IniGetPath(category, key, default_value = "") {
		var res = trim(IniGet(IniFile, category, key, default_value));
		if (res[0] == ".")
			return getcwd() + "/" + res;
		return res;
	}

	GetRoot(servername) {
		var host_root="";

		if (servername)
			host_root = IniGetPath("Paths", "HostRoot($servername)", "");

		if (!host_root)
			host_root = IniGetPath("Paths", "ServerRoot", "");

		return host_root;
	}

	static SplitPath(var path) {
		var pparam = Pos(path, "?");
		var params = "";
		if (pparam > 0) {
			params = SubStr(path, pparam, length path - pparam);
			path = SubStr(path, 0, pparam - 1);
		}
		return params;
	}

	EmptyRequest(app) {
		if (FileExists(app + "/start.con"))
			return "start.con";
		else
		if (FileExists(app + "index.csp"))
			return "index.csp";
		else
			return "index.html";
		return "";
	}

	IsCGI(content_type) {
		var is_server_page = false;
		var cgi;
		if (content_type == "application/concept-server-page") {
			is_server_page = true;
			cgi = conceptcgi;
		} else
		if (cgiother) {
			if (IsSet(cgiother, content_type)) {
				is_server_page = true;
				cgi = cgiother[content_type];
			}
		}
		if (is_server_page)
			return cgi;

		return "";
	}

	InternalError(h2, stream, err_code) {
		stream.Response(h2, [
			":status" => "$err_code",
			"server" => "CAS5WS",
			"content-type" => "text/html"
		]);

		var data =  ReadFile(ConceptClient + "/errors/$err_code.html");
		if (!data)
			data = "Error $err_code in processing your request.";			
		stream.Write(h2, data, true);
	}

	Redirect(h2, stream, url, params) {
		if (params)
			url += "?" + params;
		var headers = [
			":status" => 302,
			"server" => "CAS5WS",
			H2_EXTRA_HEADER,
			"location" => url
		];
		stream.Response(h2, headers, true);
	}

	MaxAge() {
		return value IniGet(IniFile, "Server", "MaxAge", "604800");
	}

	OnRequest(h2, stream) {
		if (stream.Headers) {
			var method = stream.Headers[":method"];
			var path = stream.Headers[":path"];
			if (!path)
				return InternalError(h2, stream, 503);
			var server = stream.Headers[":authority"] ?? "";
			var app;
			var params = SplitPath(path);
			var empty_request = false;
			var orig_path = path;
			ConceptChild::CleanApp(path);
			switch (method) {
				case "GET":
				case "POST":
					if (this.Rewrite)
						path = this.Rewrite(path, params);

					if (!path)
						throw "Invalid request";
					var root = GetRoot(server);

					if (path[length path - 1] == "/")
						empty_request = true;

					path = ConceptChild::NormalizeFilename(path, var directory);

					var client_resource = (directory[0] + directory[1] + directory[2] == "/@/");
					var root_buffer = "";
					var content_type = "application/octet-stream";

					app = root + directory + path;
					if ((app) && (DirectoryExists(app))) {
						empty_request = true;
						if (path[length path - 1] != "/") {
							path += "/";
							// auto redirect if no / is present
							if ((orig_path) && (orig_path[length orig_path - 1] != "/")) {
								this.Redirect(h2, stream, directory + path, params);
								return;
							}
						}
					}
					if ((!client_resource) && (empty_request)) {
						path += this.EmptyRequest(app);
						path = ConceptChild::NormalizeFilename(path, var directory_empty);
						directory += directory_empty;
					}

					var ext = ToLower(Ext(path));
					if ((ext) && (IsSet(this.mimetypes, ext))) {
						content_type = this.mimetypes[ext];
						if (content_type == "application/concept-private")
							return InternalError(h2, stream, 403);
					}
					if (client_resource) {
						directory = SubStr(directory, 2);
						app = ConceptClient + directory + path;
					} else {
						app = root + directory + path;
						if (content_type == "application/concept") {
							if (FileExists(app)) {
								var local_app_index = root + directory + "/@index.html";
								if (FileExists(local_app_index))
									app = local_app_index;
								else
									app = ConceptClient + "/index.html";
								content_type = "text/html";
								root_buffer = ReadFile(app);
								root_buffer = StrReplace(root_buffer, "{PROTOCOL}", "wss");
								root_buffer = StrReplace(root_buffer, "{HOST}", server);
								var concept_app = directory + path;
								if (concept_app[0] == "/")
									concept_app = SubStr(concept_app, 1);
								if (params)
									concept_app += "?" + params;
								root_buffer = StrReplace(root_buffer, "{APP}", concept_app);
								client_resource = true;
							} else
								return InternalError(h2, stream, 404);
						}
					}

					var exists = FileExists(app);
					if ((!exists) && (path[0] == "@")) {
						app = this.ConceptClient + "/" + SubStr(path, 1);
						exists = FileExists(app);
					}
					var is_cgi = this.IsCGI(content_type);
					if (is_cgi) {
						if (Pos(app, ".."))
							app = ConceptWorker::RealPath(StrReplace(app, "\\", "/"));
						else
							app = StrReplace(app, "\\", "/");

						if (exists) {
							var default_header = [
								":status" => "200",
								"server" => "CAS5WS",
								"content-type" => "text/html"
							];
							var cgi = this.CreateCGI(h2, stream, is_cgi, root, orig_path, app, params, server, var err_text);
							cgi.h2headers = default_header;
							if (!cgi)
								throw err_text;
							return;
						}
					}

					var tstamp = StrReplace(StrReplace(asctime(time()), "\r", ""), "\n", "")+" GMT";
					var last_mod = rtrim(asctime(_filelast_mod(app))) + " GMT";
					var file = new File("rb");
					file.Name = app;

					if ((!is_cgi) && ((root_buffer) || (file.Open()))) {

						var headers = [
							":status" => 200,
							"server" => "CAS5WS",
							"cache-control" => "max-age=${this.MaxAge()}",
							"date" => tstamp,
							"last-modified" => last_mod,
							H2_EXTRA_HEADER,
							"content-type" => content_type
						];
						var no_content = false;
						var if_modified = stream.Headers["if-modified-since"];
						if (if_modified) {
							var cache_control = stream.Headers["cache-control"];
							if ((cache_control) && (cache_control == "no-cache"))
								if_modified = null;
						}
						if (root_buffer) {
							if ((!params) && (last_mod == if_modified)) {
								headers[":status"] = 304;
								stream.Response(h2, headers, true);
							} else {
								stream.Response(h2, headers, no_content);
								stream.Write(h2, root_buffer, true);
							}
						} else {
							if (last_mod == if_modified) {
								headers[":status"] = 304;
								file.Close();
								delete file;
								no_content = true;
							} else
								headers["content-length"] = file.Size;
							stream.Response(h2, headers, no_content);
							if (file)
								stream.ResponseFile = file;
						}
					} else {
						stream.Response(h2, [
							":status" => "404",
							"server" => "CAS5WS",
							"date" => tstamp,
							"content-type" => "text/html"
						]);
						var data =  ReadFile(ConceptClient + "/errors/404.html");
						if (!data)
							data = "Error 404 in processing your request.";
						
						stream.Write(h2, data, true);
						delete file;
					}
					break;
				default:
					InternalError(h2, stream, 501);
					throw "Unsupported method";
					break;
			}
		} else {
			InternalError(h2, stream, 503);
		}
	}
	
	IterateCGI() {
		var children = this.CGIChildren;
		var res = 0;
		var exc;
		for (var i = 0; i < length children; i++) {
			var child = children[i];
			if (child) {
				try {
					if (child.Iterate(res)) {
						child.Close();
						children[i] = null;
						CGIPlaceholders ++;
					}
				} catch (exc) {
					child.Close();
					children[i] = null;
					CGIPlaceholders ++;
				}
			}
		}
		if (CGIPlaceholders >= 20)
			this.CGIChildren = this.Clean(this.CGIChildren, CGIPlaceholders);
		return res;
	}

	CleanCGIChildren(h2) {
		var children = this.CGIChildren;
		var exc;
		for (var i = 0; i < length children; i++) {
			var child = children[i];
			if ((child) && (child.h2 == h2)) {
				try {
					child.Close();
					children[i] = null;
					CGIPlaceholders++;
				} catch (exc) {
					// nothing
				}
			}
		}
		if (CGIPlaceholders >= 20)
			this.CGIChildren = this.Clean(this.CGIChildren, CGIPlaceholders);
	}

	Iterate() {
		var children = this.Children;
		var res = 0;
		var exc;
		var t = time();

		for (var i = 0; i < length children; i++) {
			var child = children[i];
			if (child) {
				try {
					if (child.Iterate(this.OnRequest))
						res++;
					else
					if ((t - child.IdleSince > H2_MAX_IDLE_SECONDS) && (child.UserData <= 0))
						throw "Dropping connection (idle for maximum seconds)";
				} catch (exc) {
					CleanCGIChildren(child);
					child.Close();
					children[i] = null;
					Placeholders ++;
				}
			}
		}
		if (Placeholders >= 20)
			this.Children = this.Clean(this.Children, Placeholders);
		return res;
	}

	ConceptH2Worker(n) {
		super();

		var init_data = UnBinarizeObject(n);
		IniFile = init_data[0];
		ConceptClient = init_data[1];
		mimetypes = init_data[2];
		conceptcgi = init_data[3];
		cgiother = init_data[4];
		var exc;
		var empty_iterations = 0;
		while (true) {
			var work_count = 0;
			var Socket = null;
			if (Worker::Pending(var data)) {
				work_count++;
				var job = UnBinarizeObject(data);
				if (job) {
					try {
						if (job.tls) {
							Socket = new TLSESocket(job.socket);
							if (!Socket.Restore(job.tls))
								Socket = null;
						} else
							Socket = new TCPSocket(job.socket);

						if (Socket) {
							SocketSetBlocking(Socket.Socket, false);
							this.AddChild(HTTP2::Socket(Socket));
						}
					} catch (exc) {
						delete Socket;
					}
				}
			}
			work_count += this.Iterate();
			work_count += this.IterateCGI();
			if (work_count) {
				empty_iterations = 0;
			} else {
				empty_iterations++;
				if (empty_iterations > IDLE_SLEEP_THRESHOLD)
					Sleep(IDLE_SLEEP_MS2);
				else
					Sleep(IDLE_SLEEP_MS);
			}
		}
	}
}

class ConceptServer extends RewriteContainer {
	protected var Socket;
	protected var WSSocket;
	protected var TLSWSSocket;
	protected var SSLWSSocket;
	protected var SSLWSSocketName = "";

	public var Port;
	public var WSPort;
	public var SSLWSPort;

	public var IniFile;
	protected var Loop;

	public var APID;
	public var Iterations;
	public var ClientCount=0;
	public var[] Connections;
	public var PlaceHolders;
	public var LogFile;
	public var LogFileHandle;
	public var ConceptClient=".ConceptClient.js";

	public var mimetypes;
	public var threads=0;
	public var Running = true;
	public var ShuttingDown = false;
	public var cgi = "";
	public var[] cgiother;

	protected var[] Workers;
	protected var TargetWorker = 0;
	protected var[] H2Workers;
	protected var TargetH2Worker = 0;

	ConceptServer(inifile="") {
		super();
		this.mimetypes = [
				"ez" => "application/andrew-inset",
				"aw" => "application/applixware",
				"atom" => "application/atom+xml",
				"atomcat" => "application/atomcat+xml",
				"atomsvc" => "application/atomsvc+xml",
				"ccxml" => "application/ccxml+xml",
				"cdmia" => "application/cdmi-capability",
				"cdmic" => "application/cdmi-container",
				"cdmid" => "application/cdmi-domain",
				"cdmio" => "application/cdmi-object",
				"cdmiq" => "application/cdmi-queue",
				"cu" => "application/cu-seeme",
				"davmount" => "application/davmount+xml",
				"dbk" => "application/docbook+xml",
				"dssc" => "application/dssc+der",
				"xdssc" => "application/dssc+xml",
				"ecma" => "application/ecmascript",
				"emma" => "application/emma+xml",
				"epub" => "application/epub+zip",
				"exi" => "application/exi",
				"pfr" => "application/font-tdpfr",
				"gml" => "application/gml+xml",
				"gpx" => "application/gpx+xml",
				"gxf" => "application/gxf",
				"stk" => "application/hyperstudio",
				"ink" => "application/inkml+xml",
				"inkml" => "application/inkml+xml",
				"ipfix" => "application/ipfix",
				"jar" => "application/java-archive",
				"ser" => "application/java-serialized-object",
				"class" => "application/java-vm",
				"js" => "application/javascript",
				"json" => "application/json",
				"jsonml" => "application/jsonml+json",
				"lostxml" => "application/lost+xml",
				"hqx" => "application/mac-binhex40",
				"cpt" => "application/mac-compactpro",
				"mads" => "application/mads+xml",
				"mrc" => "application/marc",
				"mrcx" => "application/marcxml+xml",
				"ma" => "application/mathematica",
				"nb" => "application/mathematica",
				"mb" => "application/mathematica",
				"mathml" => "application/mathml+xml",
				"mbox" => "application/mbox",
				"mscml" => "application/mediaservercontrol+xml",
				"metalink" => "application/metalink+xml",
				"meta4" => "application/metalink4+xml",
				"mets" => "application/mets+xml",
				"mods" => "application/mods+xml",
				"m21" => "application/mp21",
				"mp21" => "application/mp21",
				"mp4s" => "application/mp4",
				"doc" => "application/msword",
				"dot" => "application/msword",
				"mxf" => "application/mxf",
				"bin" => "application/octet-stream",
				"dms" => "application/octet-stream",
				"lrf" => "application/octet-stream",
				"mar" => "application/octet-stream",
				"so" => "application/octet-stream",
				"dist" => "application/octet-stream",
				"distz" => "application/octet-stream",
				"pkg" => "application/octet-stream",
				"bpk" => "application/octet-stream",
				"dump" => "application/octet-stream",
				"elc" => "application/octet-stream",
				"deploy" => "application/octet-stream",
				"oda" => "application/oda",
				"opf" => "application/oebps-package+xml",
				"ogx" => "application/ogg",
				"omdoc" => "application/omdoc+xml",
				"onetoc" => "application/onenote",
				"onetoc2" => "application/onenote",
				"onetmp" => "application/onenote",
				"onepkg" => "application/onenote",
				"oxps" => "application/oxps",
				"xer" => "application/patch-ops-error+xml",
				"pdf" => "application/pdf",
				"pgp" => "application/pgp-encrypted",
				"asc" => "application/pgp-signature",
				"sig" => "application/pgp-signature",
				"prf" => "application/pics-rules",
				"p10" => "application/pkcs10",
				"p7m" => "application/pkcs7-mime",
				"p7c" => "application/pkcs7-mime",
				"p7s" => "application/pkcs7-signature",
				"p8" => "application/pkcs8",
				"ac" => "application/pkix-attr-cert",
				"cer" => "application/pkix-cert",
				"crl" => "application/pkix-crl",
				"pkipath" => "application/pkix-pkipath",
				"pki" => "application/pkixcmp",
				"pls" => "application/pls+xml",
				"ai" => "application/postscript",
				"eps" => "application/postscript",
				"ps" => "application/postscript",
				"cww" => "application/prs.cww",
				"pskcxml" => "application/pskc+xml",
				"rdf" => "application/rdf+xml",
				"rif" => "application/reginfo+xml",
				"rnc" => "application/relax-ng-compact-syntax",
				"rl" => "application/resource-lists+xml",
				"rld" => "application/resource-lists-diff+xml",
				"rs" => "application/rls-services+xml",
				"gbr" => "application/rpki-ghostbusters",
				"mft" => "application/rpki-manifest",
				"roa" => "application/rpki-roa",
				"rsd" => "application/rsd+xml",
				"rss" => "application/rss+xml",
				"rtf" => "application/rtf",
				"sbml" => "application/sbml+xml",
				"scq" => "application/scvp-cv-request",
				"scs" => "application/scvp-cv-response",
				"spq" => "application/scvp-vp-request",
				"spp" => "application/scvp-vp-response",
				"sdp" => "application/sdp",
				"setpay" => "application/set-payment-initiation",
				"setreg" => "application/set-registration-initiation",
				"shf" => "application/shf+xml",
				"smi" => "application/smil+xml",
				"smil" => "application/smil+xml",
				"rq" => "application/sparql-query",
				"srx" => "application/sparql-results+xml",
				"gram" => "application/srgs",
				"grxml" => "application/srgs+xml",
				"sru" => "application/sru+xml",
				"ssdl" => "application/ssdl+xml",
				"ssml" => "application/ssml+xml",
				"tei" => "application/tei+xml",
				"teicorpus" => "application/tei+xml",
				"tfi" => "application/thraud+xml",
				"tsd" => "application/timestamped-data",
				"plb" => "application/vnd.3gpp.pic-bw-large",
				"psb" => "application/vnd.3gpp.pic-bw-small",
				"pvb" => "application/vnd.3gpp.pic-bw-var",
				"tcap" => "application/vnd.3gpp2.tcap",
				"pwn" => "application/vnd.3m.post-it-notes",
				"aso" => "application/vnd.accpac.simply.aso",
				"imp" => "application/vnd.accpac.simply.imp",
				"acu" => "application/vnd.acucobol",
				"atc" => "application/vnd.acucorp",
				"acutc" => "application/vnd.acucorp",
				"air" => "application/vnd.adobe.air-application-installer-package+zip",
				"fcdt" => "application/vnd.adobe.formscentral.fcdt",
				"fxp" => "application/vnd.adobe.fxp",
				"fxpl" => "application/vnd.adobe.fxp",
				"xdp" => "application/vnd.adobe.xdp+xml",
				"xfdf" => "application/vnd.adobe.xfdf",
				"ahead" => "application/vnd.ahead.space",
				"azf" => "application/vnd.airzip.filesecure.azf",
				"azs" => "application/vnd.airzip.filesecure.azs",
				"azw" => "application/vnd.amazon.ebook",
				"acc" => "application/vnd.americandynamics.acc",
				"ami" => "application/vnd.amiga.ami",
				"apk" => "application/vnd.android.package-archive",
				"cii" => "application/vnd.anser-web-certificate-issue-initiation",
				"fti" => "application/vnd.anser-web-funds-transfer-initiation",
				"atx" => "application/vnd.antix.game-component",
				"mpkg" => "application/vnd.apple.installer+xml",
				"m3u8" => "application/vnd.apple.mpegurl",
				"swi" => "application/vnd.aristanetworks.swi",
				"iota" => "application/vnd.astraea-software.iota",
				"aep" => "application/vnd.audiograph",
				"mpm" => "application/vnd.blueice.multipass",
				"bmi" => "application/vnd.bmi",
				"rep" => "application/vnd.businessobjects",
				"cdxml" => "application/vnd.chemdraw+xml",
				"mmd" => "application/vnd.chipnuts.karaoke-mmd",
				"cdy" => "application/vnd.cinderella",
				"cla" => "application/vnd.claymore",
				"rp9" => "application/vnd.cloanto.rp9",
				"c4g" => "application/vnd.clonk.c4group",
				"c4d" => "application/vnd.clonk.c4group",
				"c4f" => "application/vnd.clonk.c4group",
				"c4p" => "application/vnd.clonk.c4group",
				"c4u" => "application/vnd.clonk.c4group",
				"c11amc" => "application/vnd.cluetrust.cartomobile-config",
				"c11amz" => "application/vnd.cluetrust.cartomobile-config-pkg",
				"cdbcmsg" => "application/vnd.contact.cmsg",
				"cmc" => "application/vnd.cosmocaller",
				"clkx" => "application/vnd.crick.clicker",
				"clkk" => "application/vnd.crick.clicker.keyboard",
				"clkp" => "application/vnd.crick.clicker.palette",
				"clkt" => "application/vnd.crick.clicker.template",
				"clkw" => "application/vnd.crick.clicker.wordbank",
				"wbs" => "application/vnd.criticaltools.wbs+xml",
				"pml" => "application/vnd.ctc-posml",
				"ppd" => "application/vnd.cups-ppd",
				"car" => "application/vnd.curl.car",
				"pcurl" => "application/vnd.curl.pcurl",
				"dart" => "application/vnd.dart",
				"rdz" => "application/vnd.data-vision.rdz",
				"uvf" => "application/vnd.dece.data",
				"uvvf" => "application/vnd.dece.data",
				"uvd" => "application/vnd.dece.data",
				"uvvd" => "application/vnd.dece.data",
				"uvt" => "application/vnd.dece.ttml+xml",
				"uvvt" => "application/vnd.dece.ttml+xml",
				"uvx" => "application/vnd.dece.unspecified",
				"uvvx" => "application/vnd.dece.unspecified",
				"uvz" => "application/vnd.dece.zip",
				"uvvz" => "application/vnd.dece.zip",
				"fe_launch" => "application/vnd.denovo.fcselayout-link",
				"dna" => "application/vnd.dna",
				"mlp" => "application/vnd.dolby.mlp",
				"dpg" => "application/vnd.dpgraph",
				"dfac" => "application/vnd.dreamfactory",
				"kpxx" => "application/vnd.ds-keypoint",
				"ait" => "application/vnd.dvb.ait",
				"svc" => "application/vnd.dvb.service",
				"geo" => "application/vnd.dynageo",
				"mag" => "application/vnd.ecowin.chart",
				"nml" => "application/vnd.enliven",
				"esf" => "application/vnd.epson.esf",
				"msf" => "application/vnd.epson.msf",
				"qam" => "application/vnd.epson.quickanime",
				"slt" => "application/vnd.epson.salt",
				"ssf" => "application/vnd.epson.ssf",
				"es3" => "application/vnd.eszigno3+xml",
				"et3" => "application/vnd.eszigno3+xml",
				"ez2" => "application/vnd.ezpix-album",
				"ez3" => "application/vnd.ezpix-package",
				"fdf" => "application/vnd.fdf",
				"mseed" => "application/vnd.fdsn.mseed",
				"seed" => "application/vnd.fdsn.seed",
				"dataless" => "application/vnd.fdsn.seed",
				"gph" => "application/vnd.flographit",
				"ftc" => "application/vnd.fluxtime.clip",
				"fm" => "application/vnd.framemaker",
				"frame" => "application/vnd.framemaker",
				"maker" => "application/vnd.framemaker",
				"book" => "application/vnd.framemaker",
				"fnc" => "application/vnd.frogans.fnc",
				"ltf" => "application/vnd.frogans.ltf",
				"fsc" => "application/vnd.fsc.weblaunch",
				"oas" => "application/vnd.fujitsu.oasys",
				"oa2" => "application/vnd.fujitsu.oasys2",
				"oa3" => "application/vnd.fujitsu.oasys3",
				"fg5" => "application/vnd.fujitsu.oasysgp",
				"bh2" => "application/vnd.fujitsu.oasysprs",
				"ddd" => "application/vnd.fujixerox.ddd",
				"xdw" => "application/vnd.fujixerox.docuworks",
				"xbd" => "application/vnd.fujixerox.docuworks.binder",
				"fzs" => "application/vnd.fuzzysheet",
				"txd" => "application/vnd.genomatix.tuxedo",
				"ggb" => "application/vnd.geogebra.file",
				"ggt" => "application/vnd.geogebra.tool",
				"gex" => "application/vnd.geometry-explorer",
				"gre" => "application/vnd.geometry-explorer",
				"gxt" => "application/vnd.geonext",
				"g2w" => "application/vnd.geoplan",
				"g3w" => "application/vnd.geospace",
				"gmx" => "application/vnd.gmx",
				"kml" => "application/vnd.google-earth.kml+xml",
				"kmz" => "application/vnd.google-earth.kmz",
				"gqf" => "application/vnd.grafeq",
				"gqs" => "application/vnd.grafeq",
				"gac" => "application/vnd.groove-account",
				"ghf" => "application/vnd.groove-help",
				"gim" => "application/vnd.groove-identity-message",
				"grv" => "application/vnd.groove-injector",
				"gtm" => "application/vnd.groove-tool-message",
				"tpl" => "application/vnd.groove-tool-template",
				"vcg" => "application/vnd.groove-vcard",
				"hal" => "application/vnd.hal+xml",
				"zmm" => "application/vnd.handheld-entertainment+xml",
				"hbci" => "application/vnd.hbci",
				"les" => "application/vnd.hhe.lesson-player",
				"hpgl" => "application/vnd.hp-hpgl",
				"hpid" => "application/vnd.hp-hpid",
				"hps" => "application/vnd.hp-hps",
				"jlt" => "application/vnd.hp-jlyt",
				"pcl" => "application/vnd.hp-pcl",
				"pclxl" => "application/vnd.hp-pclxl",
				"sfd-hdstx" => "application/vnd.hydrostatix.sof-data",
				"mpy" => "application/vnd.ibm.minipay",
				"afp" => "application/vnd.ibm.modcap",
				"listafp" => "application/vnd.ibm.modcap",
				"list3820" => "application/vnd.ibm.modcap",
				"irm" => "application/vnd.ibm.rights-management",
				"sc" => "application/vnd.ibm.secure-container",
				"icc" => "application/vnd.iccprofile",
				"icm" => "application/vnd.iccprofile",
				"igl" => "application/vnd.igloader",
				"ivp" => "application/vnd.immervision-ivp",
				"ivu" => "application/vnd.immervision-ivu",
				"igm" => "application/vnd.insors.igm",
				"xpw" => "application/vnd.intercon.formnet",
				"xpx" => "application/vnd.intercon.formnet",
				"i2g" => "application/vnd.intergeo",
				"qbo" => "application/vnd.intu.qbo",
				"qfx" => "application/vnd.intu.qfx",
				"rcprofile" => "application/vnd.ipunplugged.rcprofile",
				"irp" => "application/vnd.irepository.package+xml",
				"xpr" => "application/vnd.is-xpr",
				"fcs" => "application/vnd.isac.fcs",
				"jam" => "application/vnd.jam",
				"rms" => "application/vnd.jcp.javame.midlet-rms",
				"jisp" => "application/vnd.jisp",
				"joda" => "application/vnd.joost.joda-archive",
				"ktz" => "application/vnd.kahootz",
				"ktr" => "application/vnd.kahootz",
				"karbon" => "application/vnd.kde.karbon",
				"chrt" => "application/vnd.kde.kchart",
				"kfo" => "application/vnd.kde.kformula",
				"flw" => "application/vnd.kde.kivio",
				"kon" => "application/vnd.kde.kontour",
				"kpr" => "application/vnd.kde.kpresenter",
				"kpt" => "application/vnd.kde.kpresenter",
				"ksp" => "application/vnd.kde.kspread",
				"kwd" => "application/vnd.kde.kword",
				"kwt" => "application/vnd.kde.kword",
				"htke" => "application/vnd.kenameaapp",
				"kia" => "application/vnd.kidspiration",
				"kne" => "application/vnd.kinar",
				"knp" => "application/vnd.kinar",
				"skp" => "application/vnd.koan",
				"skd" => "application/vnd.koan",
				"skt" => "application/vnd.koan",
				"skm" => "application/vnd.koan",
				"sse" => "application/vnd.kodak-descriptor",
				"lasxml" => "application/vnd.las.las+xml",
				"lbd" => "application/vnd.llamagraphics.life-balance.desktop",
				"lbe" => "application/vnd.llamagraphics.life-balance.exchange+xml",
				"123" => "application/vnd.lotus-1-2-3",
				"apr" => "application/vnd.lotus-approach",
				"pre" => "application/vnd.lotus-freelance",
				"nsf" => "application/vnd.lotus-notes",
				"org" => "application/vnd.lotus-organizer",
				"scm" => "application/vnd.lotus-screencam",
				"lwp" => "application/vnd.lotus-wordpro",
				"portpkg" => "application/vnd.macports.portpkg",
				"mcd" => "application/vnd.mcd",
				"mc1" => "application/vnd.medcalcdata",
				"cdkey" => "application/vnd.mediastation.cdkey",
				"mwf" => "application/vnd.mfer",
				"mfm" => "application/vnd.mfmp",
				"flo" => "application/vnd.micrografx.flo",
				"igx" => "application/vnd.micrografx.igx",
				"mif" => "application/vnd.mif",
				"daf" => "application/vnd.mobius.daf",
				"dis" => "application/vnd.mobius.dis",
				"mbk" => "application/vnd.mobius.mbk",
				"mqy" => "application/vnd.mobius.mqy",
				"msl" => "application/vnd.mobius.msl",
				"plc" => "application/vnd.mobius.plc",
				"txf" => "application/vnd.mobius.txf",
				"mpn" => "application/vnd.mophun.application",
				"mpc" => "application/vnd.mophun.certificate",
				"xul" => "application/vnd.mozilla.xul+xml",
				"cil" => "application/vnd.ms-artgalry",
				"cab" => "application/vnd.ms-cab-compressed",
				"xls" => "application/vnd.ms-excel",
				"xlm" => "application/vnd.ms-excel",
				"xla" => "application/vnd.ms-excel",
				"xlc" => "application/vnd.ms-excel",
				"xlt" => "application/vnd.ms-excel",
				"xlw" => "application/vnd.ms-excel",
				"xlam" => "application/vnd.ms-excel.addin.macroenabled.12",
				"xlsb" => "application/vnd.ms-excel.sheet.binary.macroenabled.12",
				"xlsm" => "application/vnd.ms-excel.sheet.macroenabled.12",
				"xltm" => "application/vnd.ms-excel.template.macroenabled.12",
				"eot" => "application/vnd.ms-fontobject",
				"chm" => "application/vnd.ms-htmlhelp",
				"ims" => "application/vnd.ms-ims",
				"lrm" => "application/vnd.ms-lrm",
				"thmx" => "application/vnd.ms-officetheme",
				"cat" => "application/vnd.ms-pki.seccat",
				"stl" => "application/vnd.ms-pki.stl",
				"ppt" => "application/vnd.ms-powerpoint",
				"pps" => "application/vnd.ms-powerpoint",
				"pot" => "application/vnd.ms-powerpoint",
				"ppam" => "application/vnd.ms-powerpoint.addin.macroenabled.12",
				"pptm" => "application/vnd.ms-powerpoint.presentation.macroenabled.12",
				"sldm" => "application/vnd.ms-powerpoint.slide.macroenabled.12",
				"ppsm" => "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
				"potm" => "application/vnd.ms-powerpoint.template.macroenabled.12",
				"mpp" => "application/vnd.ms-project",
				"mpt" => "application/vnd.ms-project",
				"docm" => "application/vnd.ms-word.document.macroenabled.12",
				"dotm" => "application/vnd.ms-word.template.macroenabled.12",
				"wps" => "application/vnd.ms-works",
				"wks" => "application/vnd.ms-works",
				"wcm" => "application/vnd.ms-works",
				"wdb" => "application/vnd.ms-works",
				"wpl" => "application/vnd.ms-wpl",
				"xps" => "application/vnd.ms-xpsdocument",
				"mseq" => "application/vnd.mseq",
				"mus" => "application/vnd.musician",
				"msty" => "application/vnd.muvee.style",
				"taglet" => "application/vnd.mynfc",
				"nlu" => "application/vnd.neurolanguage.nlu",
				"ntf" => "application/vnd.nitf",
				"nitf" => "application/vnd.nitf",
				"nnd" => "application/vnd.noblenet-directory",
				"nns" => "application/vnd.noblenet-sealer",
				"nnw" => "application/vnd.noblenet-web",
				"ngdat" => "application/vnd.nokia.n-gage.data",
				"n-gage" => "application/vnd.nokia.n-gage.symbian.install",
				"rpst" => "application/vnd.nokia.radio-preset",
				"rpss" => "application/vnd.nokia.radio-presets",
				"edm" => "application/vnd.novadigm.edm",
				"edx" => "application/vnd.novadigm.edx",
				"ext" => "application/vnd.novadigm.ext",
				"odc" => "application/vnd.oasis.opendocument.chart",
				"otc" => "application/vnd.oasis.opendocument.chart-template",
				"odb" => "application/vnd.oasis.opendocument.database",
				"odf" => "application/vnd.oasis.opendocument.formula",
				"odft" => "application/vnd.oasis.opendocument.formula-template",
				"odg" => "application/vnd.oasis.opendocument.graphics",
				"otg" => "application/vnd.oasis.opendocument.graphics-template",
				"odi" => "application/vnd.oasis.opendocument.image",
				"oti" => "application/vnd.oasis.opendocument.image-template",
				"odp" => "application/vnd.oasis.opendocument.presentation",
				"otp" => "application/vnd.oasis.opendocument.presentation-template",
				"ods" => "application/vnd.oasis.opendocument.spreadsheet",
				"ots" => "application/vnd.oasis.opendocument.spreadsheet-template",
				"odt" => "application/vnd.oasis.opendocument.text",
				"odm" => "application/vnd.oasis.opendocument.text-master",
				"ott" => "application/vnd.oasis.opendocument.text-template",
				"oth" => "application/vnd.oasis.opendocument.text-web",
				"xo" => "application/vnd.olpc-sugar",
				"dd2" => "application/vnd.oma.dd2+xml",
				"oxt" => "application/vnd.openofficeorg.extension",
				"pptx" => "application/vnd.openxmlformats-officedocument.presentationml.presentation",
				"sldx" => "application/vnd.openxmlformats-officedocument.presentationml.slide",
				"ppsx" => "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
				"potx" => "application/vnd.openxmlformats-officedocument.presentationml.template",
				"xlsx" => "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
				"xltx" => "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
				"docx" => "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
				"dotx" => "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
				"mgp" => "application/vnd.osgeo.mapguide.package",
				"dp" => "application/vnd.osgi.dp",
				"esa" => "application/vnd.osgi.subsystem",
				"pdb" => "application/vnd.palm",
				"pqa" => "application/vnd.palm",
				"oprc" => "application/vnd.palm",
				"paw" => "application/vnd.pawaafile",
				"str" => "application/vnd.pg.format",
				"ei6" => "application/vnd.pg.osasli",
				"efif" => "application/vnd.picsel",
				"wg" => "application/vnd.pmi.widget",
				"plf" => "application/vnd.pocketlearn",
				"pbd" => "application/vnd.powerbuilder6",
				"box" => "application/vnd.previewsystems.box",
				"mgz" => "application/vnd.proteus.magazine",
				"qps" => "application/vnd.publishare-delta-tree",
				"ptid" => "application/vnd.pvi.ptid1",
				"qxd" => "application/vnd.quark.quarkxpress",
				"qxt" => "application/vnd.quark.quarkxpress",
				"qwd" => "application/vnd.quark.quarkxpress",
				"qwt" => "application/vnd.quark.quarkxpress",
				"qxl" => "application/vnd.quark.quarkxpress",
				"qxb" => "application/vnd.quark.quarkxpress",
				"bed" => "application/vnd.realvnc.bed",
				"mxl" => "application/vnd.recordare.musicxml",
				"musicxml" => "application/vnd.recordare.musicxml+xml",
				"cryptonote" => "application/vnd.rig.cryptonote",
				"cod" => "application/vnd.rim.cod",
				"rm" => "application/vnd.rn-realmedia",
				"rmvb" => "application/vnd.rn-realmedia-vbr",
				"link66" => "application/vnd.route66.link66+xml",
				"st" => "application/vnd.sailingtracker.track",
				"see" => "application/vnd.seemail",
				"sema" => "application/vnd.sema",
				"semd" => "application/vnd.semd",
				"semf" => "application/vnd.semf",
				"ifm" => "application/vnd.shana.informed.formdata",
				"itp" => "application/vnd.shana.informed.formtemplate",
				"iif" => "application/vnd.shana.informed.interchange",
				"ipk" => "application/vnd.shana.informed.package",
				"twd" => "application/vnd.simtech-mindmapper",
				"twds" => "application/vnd.simtech-mindmapper",
				"mmf" => "application/vnd.smaf",
				"teacher" => "application/vnd.smart.teacher",
				"sdkm" => "application/vnd.solent.sdkm+xml",
				"sdkd" => "application/vnd.solent.sdkm+xml",
				"dxp" => "application/vnd.spotfire.dxp",
				"sfs" => "application/vnd.spotfire.sfs",
				"sdc" => "application/vnd.stardivision.calc",
				"sda" => "application/vnd.stardivision.draw",
				"sdd" => "application/vnd.stardivision.impress",
				"smf" => "application/vnd.stardivision.math",
				"sdw" => "application/vnd.stardivision.writer",
				"vor" => "application/vnd.stardivision.writer",
				"sgl" => "application/vnd.stardivision.writer-global",
				"smzip" => "application/vnd.stepmania.package",
				"sm" => "application/vnd.stepmania.stepchart",
				"sxc" => "application/vnd.sun.xml.calc",
				"stc" => "application/vnd.sun.xml.calc.template",
				"sxd" => "application/vnd.sun.xml.draw",
				"std" => "application/vnd.sun.xml.draw.template",
				"sxi" => "application/vnd.sun.xml.impress",
				"sti" => "application/vnd.sun.xml.impress.template",
				"sxm" => "application/vnd.sun.xml.math",
				"sxw" => "application/vnd.sun.xml.writer",
				"sxg" => "application/vnd.sun.xml.writer.global",
				"stw" => "application/vnd.sun.xml.writer.template",
				"sus" => "application/vnd.sus-calendar",
				"susp" => "application/vnd.sus-calendar",
				"svd" => "application/vnd.svd",
				"sis" => "application/vnd.symbian.install",
				"sisx" => "application/vnd.symbian.install",
				"xsm" => "application/vnd.syncml+xml",
				"bdm" => "application/vnd.syncml.dm+wbxml",
				"xdm" => "application/vnd.syncml.dm+xml",
				"tao" => "application/vnd.tao.intent-module-archive",
				"pcap" => "application/vnd.tcpdump.pcap",
				"cap" => "application/vnd.tcpdump.pcap",
				"dmp" => "application/vnd.tcpdump.pcap",
				"tmo" => "application/vnd.tmobile-livetv",
				"tpt" => "application/vnd.trid.tpt",
				"mxs" => "application/vnd.triscape.mxs",
				"tra" => "application/vnd.trueapp",
				"ufd" => "application/vnd.ufdl",
				"ufdl" => "application/vnd.ufdl",
				"utz" => "application/vnd.uiq.theme",
				"umj" => "application/vnd.umajin",
				"unityweb" => "application/vnd.unity",
				"uoml" => "application/vnd.uoml+xml",
				"vcx" => "application/vnd.vcx",
				"vsd" => "application/vnd.visio",
				"vst" => "application/vnd.visio",
				"vss" => "application/vnd.visio",
				"vsw" => "application/vnd.visio",
				"vis" => "application/vnd.visionary",
				"vsf" => "application/vnd.vsf",
				"wbxml" => "application/vnd.wap.wbxml",
				"wmlc" => "application/vnd.wap.wmlc",
				"wmlsc" => "application/vnd.wap.wmlscriptc",
				"wtb" => "application/vnd.webturbo",
				"nbp" => "application/vnd.wolfram.player",
				"wpd" => "application/vnd.wordperfect",
				"wqd" => "application/vnd.wqd",
				"stf" => "application/vnd.wt.stf",
				"xar" => "application/vnd.xara",
				"xfdl" => "application/vnd.xfdl",
				"hvd" => "application/vnd.yamaha.hv-dic",
				"hvs" => "application/vnd.yamaha.hv-script",
				"hvp" => "application/vnd.yamaha.hv-voice",
				"osf" => "application/vnd.yamaha.openscoreformat",
				"osfpvg" => "application/vnd.yamaha.openscoreformat.osfpvg+xml",
				"saf" => "application/vnd.yamaha.smaf-audio",
				"spf" => "application/vnd.yamaha.smaf-phrase",
				"cmp" => "application/vnd.yellowriver-custom-menu",
				"zir" => "application/vnd.zul",
				"zirz" => "application/vnd.zul",
				"zaz" => "application/vnd.zzazz.deck+xml",
				"vxml" => "application/voicexml+xml",
				"wgt" => "application/widget",
				"hlp" => "application/winhlp",
				"wsdl" => "application/wsdl+xml",
				"wspolicy" => "application/wspolicy+xml",
				"7z" => "application/x-7z-compressed",
				"abw" => "application/x-abiword",
				"ace" => "application/x-ace-compressed",
				"dmg" => "application/x-apple-diskimage",
				"aab" => "application/x-authorware-bin",
				"x32" => "application/x-authorware-bin",
				"u32" => "application/x-authorware-bin",
				"vox" => "application/x-authorware-bin",
				"aam" => "application/x-authorware-map",
				"aas" => "application/x-authorware-seg",
				"bcpio" => "application/x-bcpio",
				"torrent" => "application/x-bittorrent",
				"blb" => "application/x-blorb",
				"blorb" => "application/x-blorb",
				"bz" => "application/x-bzip",
				"bz2" => "application/x-bzip2",
				"boz" => "application/x-bzip2",
				"cbr" => "application/x-cbr",
				"cba" => "application/x-cbr",
				"cbt" => "application/x-cbr",
				"cbz" => "application/x-cbr",
				"cb7" => "application/x-cbr",
				"vcd" => "application/x-cdlink",
				"cfs" => "application/x-cfs-compressed",
				"chat" => "application/x-chat",
				"pgn" => "application/x-chess-pgn",
				"nsc" => "application/x-conference",
				"cpio" => "application/x-cpio",
				"csh" => "application/x-csh",
				"deb" => "application/x-debian-package",
				"udeb" => "application/x-debian-package",
				"dgc" => "application/x-dgc-compressed",
				"dir" => "application/x-director",
				"dcr" => "application/x-director",
				"dxr" => "application/x-director",
				"cst" => "application/x-director",
				"cct" => "application/x-director",
				"cxt" => "application/x-director",
				"w3d" => "application/x-director",
				"fgd" => "application/x-director",
				"swa" => "application/x-director",
				"wad" => "application/x-doom",
				"ncx" => "application/x-dtbncx+xml",
				"dtb" => "application/x-dtbook+xml",
				"res" => "application/x-dtbresource+xml",
				"dvi" => "application/x-dvi",
				"evy" => "application/x-envoy",
				"eva" => "application/x-eva",
				"bdf" => "application/x-font-bdf",
				"gsf" => "application/x-font-ghostscript",
				"psf" => "application/x-font-linux-psf",
				"otf" => "application/x-font-otf",
				"pcf" => "application/x-font-pcf",
				"snf" => "application/x-font-snf",
				"ttf" => "application/x-font-ttf",
				"ttc" => "application/x-font-ttf",
				"pfa" => "application/x-font-type1",
				"pfb" => "application/x-font-type1",
				"pfm" => "application/x-font-type1",
				"afm" => "application/x-font-type1",
				"woff" => "application/x-font-woff",
				"arc" => "application/x-freearc",
				"spl" => "application/x-futuresplash",
				"gca" => "application/x-gca-compressed",
				"ulx" => "application/x-glulx",
				"gnumeric" => "application/x-gnumeric",
				"gramps" => "application/x-gramps-xml",
				"gtar" => "application/x-gtar",
				"hdf" => "application/x-hdf",
				"install" => "application/x-install-instructions",
				"iso" => "application/x-iso9660-image",
				"jnlp" => "application/x-java-jnlp-file",
				"latex" => "application/x-latex",
				"lzh" => "application/x-lzh-compressed",
				"lha" => "application/x-lzh-compressed",
				"mie" => "application/x-mie",
				"prc" => "application/x-mobipocket-ebook",
				"mobi" => "application/x-mobipocket-ebook",
				"application" => "application/x-ms-application",
				"lnk" => "application/x-ms-shortcut",
				"wmd" => "application/x-ms-wmd",
				"wmz" => "application/x-ms-wmz",
				"xbap" => "application/x-ms-xbap",
				"mdb" => "application/x-msaccess",
				"obd" => "application/x-msbinder",
				"crd" => "application/x-mscardfile",
				"clp" => "application/x-msclip",
				"exe" => "application/x-msdownload",
				"dll" => "application/x-msdownload",
				"com" => "application/x-msdownload",
				"bat" => "application/x-msdownload",
				"msi" => "application/x-msdownload",
				"mvb" => "application/x-msmediaview",
				"m13" => "application/x-msmediaview",
				"m14" => "application/x-msmediaview",
				"wmf" => "application/x-msmetafile",
				"wmz" => "application/x-msmetafile",
				"emf" => "application/x-msmetafile",
				"emz" => "application/x-msmetafile",
				"mny" => "application/x-msmoney",
				"pub" => "application/x-mspublisher",
				"scd" => "application/x-msschedule",
				"trm" => "application/x-msterminal",
				"wri" => "application/x-mswrite",
				"nc" => "application/x-netcdf",
				"cdf" => "application/x-netcdf",
				"nzb" => "application/x-nzb",
				"p12" => "application/x-pkcs12",
				"pfx" => "application/x-pkcs12",
				"p7b" => "application/x-pkcs7-certificates",
				"spc" => "application/x-pkcs7-certificates",
				"p7r" => "application/x-pkcs7-certreqresp",
				"rar" => "application/x-rar-compressed",
				"ris" => "application/x-research-info-systems",
				"sh" => "application/x-sh",
				"shar" => "application/x-shar",
				"swf" => "application/x-shockwave-flash",
				"xap" => "application/x-silverlight-app",
				"sql" => "application/x-sql",
				"sit" => "application/x-stuffit",
				"sitx" => "application/x-stuffitx",
				"srt" => "application/x-subrip",
				"sv4cpio" => "application/x-sv4cpio",
				"sv4crc" => "application/x-sv4crc",
				"t3" => "application/x-t3vm-image",
				"gam" => "application/x-tads",
				"tar" => "application/x-tar",
				"tcl" => "application/x-tcl",
				"tex" => "application/x-tex",
				"tfm" => "application/x-tex-tfm",
				"texinfo" => "application/x-texinfo",
				"texi" => "application/x-texinfo",
				"obj" => "application/x-tgif",
				"ustar" => "application/x-ustar",
				"src" => "application/x-wais-source",
				"der" => "application/x-x509-ca-cert",
				"crt" => "application/x-x509-ca-cert",
				"fig" => "application/x-xfig",
				"xlf" => "application/x-xliff+xml",
				"xpi" => "application/x-xpinstall",
				"xz" => "application/x-xz",
				"z1" => "application/x-zmachine",
				"z2" => "application/x-zmachine",
				"z3" => "application/x-zmachine",
				"z4" => "application/x-zmachine",
				"z5" => "application/x-zmachine",
				"z6" => "application/x-zmachine",
				"z7" => "application/x-zmachine",
				"z8" => "application/x-zmachine",
				"xaml" => "application/xaml+xml",
				"xdf" => "application/xcap-diff+xml",
				"xenc" => "application/xenc+xml",
				"xhtml" => "application/xhtml+xml",
				"xht" => "application/xhtml+xml",
				"xml" => "application/xml",
				"xsl" => "application/xml",
				"dtd" => "application/xml-dtd",
				"xop" => "application/xop+xml",
				"xpl" => "application/xproc+xml",
				"xslt" => "application/xslt+xml",
				"xspf" => "application/xspf+xml",
				"mxml" => "application/xv+xml",
				"xhvml" => "application/xv+xml",
				"xvml" => "application/xv+xml",
				"xvm" => "application/xv+xml",
				"yang" => "application/yang",
				"yin" => "application/yin+xml",
				"zip" => "application/zip",
				"adp" => "audio/adpcm",
				"au" => "audio/basic",
				"snd" => "audio/basic",
				"mid" => "audio/midi",
				"midi" => "audio/midi",
				"kar" => "audio/midi",
				"rmi" => "audio/midi",
				"mp4a" => "audio/mp4",
				"mpga" => "audio/mpeg",
				"mp2" => "audio/mpeg",
				"mp2a" => "audio/mpeg",
				"mp3" => "audio/mpeg",
				"m2a" => "audio/mpeg",
				"m3a" => "audio/mpeg",
				"oga" => "audio/ogg",
				"ogg" => "audio/ogg",
				"spx" => "audio/ogg",
				"s3m" => "audio/s3m",
				"sil" => "audio/silk",
				"uva" => "audio/vnd.dece.audio",
				"uvva" => "audio/vnd.dece.audio",
				"eol" => "audio/vnd.digital-winds",
				"dra" => "audio/vnd.dra",
				"dts" => "audio/vnd.dts",
				"dtshd" => "audio/vnd.dts.hd",
				"lvp" => "audio/vnd.lucent.voice",
				"pya" => "audio/vnd.ms-playready.media.pya",
				"ecelp4800" => "audio/vnd.nuera.ecelp4800",
				"ecelp7470" => "audio/vnd.nuera.ecelp7470",
				"ecelp9600" => "audio/vnd.nuera.ecelp9600",
				"rip" => "audio/vnd.rip",
				"weba" => "audio/webm",
				"aac" => "audio/x-aac",
				"aif" => "audio/x-aiff",
				"aiff" => "audio/x-aiff",
				"aifc" => "audio/x-aiff",
				"caf" => "audio/x-caf",
				"flac" => "audio/x-flac",
				"mka" => "audio/x-matroska",
				"m3u" => "audio/x-mpegurl",
				"wax" => "audio/x-ms-wax",
				"wma" => "audio/x-ms-wma",
				"ram" => "audio/x-pn-realaudio",
				"ra" => "audio/x-pn-realaudio",
				"rmp" => "audio/x-pn-realaudio-plugin",
				"wav" => "audio/x-wav",
				"xm" => "audio/xm",
				"cdx" => "chemical/x-cdx",
				"cif" => "chemical/x-cif",
				"cmdf" => "chemical/x-cmdf",
				"cml" => "chemical/x-cml",
				"csml" => "chemical/x-csml",
				"xyz" => "chemical/x-xyz",
				"bmp" => "image/bmp",
				"cgm" => "image/cgm",
				"g3" => "image/g3fax",
				"gif" => "image/gif",
				"ief" => "image/ief",
				"jpeg" => "image/jpeg",
				"jpg" => "image/jpeg",
				"jpe" => "image/jpeg",
				"ktx" => "image/ktx",
				"png" => "image/png",
				"btif" => "image/prs.btif",
				"sgi" => "image/sgi",
				"svg" => "image/svg+xml",
				"svgz" => "image/svg+xml",
				"tiff" => "image/tiff",
				"tif" => "image/tiff",
				"psd" => "image/vnd.adobe.photoshop",
				"uvi" => "image/vnd.dece.graphic",
				"uvvi" => "image/vnd.dece.graphic",
				"uvg" => "image/vnd.dece.graphic",
				"uvvg" => "image/vnd.dece.graphic",
				"sub" => "image/vnd.dvb.subtitle",
				"djvu" => "image/vnd.djvu",
				"djv" => "image/vnd.djvu",
				"dwg" => "image/vnd.dwg",
				"dxf" => "image/vnd.dxf",
				"fbs" => "image/vnd.fastbidsheet",
				"fpx" => "image/vnd.fpx",
				"fst" => "image/vnd.fst",
				"mmr" => "image/vnd.fujixerox.edmics-mmr",
				"rlc" => "image/vnd.fujixerox.edmics-rlc",
				"mdi" => "image/vnd.ms-modi",
				"wdp" => "image/vnd.ms-photo",
				"npx" => "image/vnd.net-fpx",
				"wbmp" => "image/vnd.wap.wbmp",
				"xif" => "image/vnd.xiff",
				"webp" => "image/webp",
				"3ds" => "image/x-3ds",
				"ras" => "image/x-cmu-raster",
				"cmx" => "image/x-cmx",
				"fh" => "image/x-freehand",
				"fhc" => "image/x-freehand",
				"fh4" => "image/x-freehand",
				"fh5" => "image/x-freehand",
				"fh7" => "image/x-freehand",
				"ico" => "image/x-icon",
				"sid" => "image/x-mrsid-image",
				"pcx" => "image/x-pcx",
				"pic" => "image/x-pict",
				"pct" => "image/x-pict",
				"pnm" => "image/x-portable-anymap",
				"pbm" => "image/x-portable-bitmap",
				"pgm" => "image/x-portable-graymap",
				"ppm" => "image/x-portable-pixmap",
				"rgb" => "image/x-rgb",
				"tga" => "image/x-tga",
				"xbm" => "image/x-xbitmap",
				"xpm" => "image/x-xpixmap",
				"xwd" => "image/x-xwindowdump",
				"eml" => "message/rfc822",
				"mime" => "message/rfc822",
				"igs" => "model/iges",
				"iges" => "model/iges",
				"msh" => "model/mesh",
				"mesh" => "model/mesh",
				"silo" => "model/mesh",
				"dae" => "model/vnd.collada+xml",
				"dwf" => "model/vnd.dwf",
				"gdl" => "model/vnd.gdl",
				"gtw" => "model/vnd.gtw",
				"mts" => "model/vnd.mts",
				"vtu" => "model/vnd.vtu",
				"wrl" => "model/vrml",
				"vrml" => "model/vrml",
				"x3db" => "model/x3d+binary",
				"x3dbz" => "model/x3d+binary",
				"x3dv" => "model/x3d+vrml",
				"x3dvz" => "model/x3d+vrml",
				"x3d" => "model/x3d+xml",
				"x3dz" => "model/x3d+xml",
				"appcache" => "text/cache-manifest",
				"ics" => "text/calendar",
				"ifb" => "text/calendar",
				"css" => "text/css",
				"csv" => "text/csv",
				"html" => "text/html",
				"htm" => "text/html",
				"n3" => "text/n3",
				"txt" => "text/plain",
				"text" => "text/plain",
				"conf" => "text/plain",
				"def" => "text/plain",
				"list" => "text/plain",
				"log" => "text/plain",
				"in" => "text/plain",
				"dsc" => "text/prs.lines.tag",
				"rtx" => "text/richtext",
				"sgml" => "text/sgml",
				"sgm" => "text/sgml",
				"tsv" => "text/tab-separated-values",
				"t" => "text/troff",
				"tr" => "text/troff",
				"roff" => "text/troff",
				"man" => "text/troff",
				"me" => "text/troff",
				"ms" => "text/troff",
				"ttl" => "text/turtle",
				"uri" => "text/uri-list",
				"uris" => "text/uri-list",
				"urls" => "text/uri-list",
				"vcard" => "text/vcard",
				"curl" => "text/vnd.curl",
				"dcurl" => "text/vnd.curl.dcurl",
				"scurl" => "text/vnd.curl.scurl",
				"mcurl" => "text/vnd.curl.mcurl",
				"sub" => "text/vnd.dvb.subtitle",
				"fly" => "text/vnd.fly",
				"flx" => "text/vnd.fmi.flexstor",
				"gv" => "text/vnd.graphviz",
				"3dml" => "text/vnd.in3d.3dml",
				"spot" => "text/vnd.in3d.spot",
				"jad" => "text/vnd.sun.j2me.app-descriptor",
				"wml" => "text/vnd.wap.wml",
				"wmls" => "text/vnd.wap.wmlscript",
				"s" => "text/x-asm",
				"asm" => "text/x-asm",
				"c" => "text/x-c",
				"cc" => "text/x-c",
				"cxx" => "text/x-c",
				"cpp" => "text/x-c",
				"h" => "text/x-c",
				"hh" => "text/x-c",
				"dic" => "text/x-c",
				"f" => "text/x-fortran",
				"for" => "text/x-fortran",
				"f77" => "text/x-fortran",
				"f90" => "text/x-fortran",
				"java" => "text/x-java-source",
				"opml" => "text/x-opml",
				"p" => "text/x-pascal",
				"pas" => "text/x-pascal",
				"nfo" => "text/x-nfo",
				"etx" => "text/x-setext",
				"sfv" => "text/x-sfv",
				"uu" => "text/x-uuencode",
				"vcs" => "text/x-vcalendar",
				"vcf" => "text/x-vcard",
				"3gp" => "video/3gpp",
				"3g2" => "video/3gpp2",
				"h261" => "video/h261",
				"h263" => "video/h263",
				"h264" => "video/h264",
				"jpgv" => "video/jpeg",
				"jpm" => "video/jpm",
				"jpgm" => "video/jpm",
				"mj2" => "video/mj2",
				"mjp2" => "video/mj2",
				"mp4" => "video/mp4",
				"mp4v" => "video/mp4",
				"mpg4" => "video/mp4",
				"mpeg" => "video/mpeg",
				"mpg" => "video/mpeg",
				"mpe" => "video/mpeg",
				"m1v" => "video/mpeg",
				"m2v" => "video/mpeg",
				"ogv" => "video/ogg",
				"qt" => "video/quicktime",
				"mov" => "video/quicktime",
				"uvh" => "video/vnd.dece.hd",
				"uvvh" => "video/vnd.dece.hd",
				"uvm" => "video/vnd.dece.mobile",
				"uvvm" => "video/vnd.dece.mobile",
				"uvp" => "video/vnd.dece.pd",
				"uvvp" => "video/vnd.dece.pd",
				"uvs" => "video/vnd.dece.sd",
				"uvvs" => "video/vnd.dece.sd",
				"uvv" => "video/vnd.dece.video",
				"uvvv" => "video/vnd.dece.video",
				"dvb" => "video/vnd.dvb.file",
				"fvt" => "video/vnd.fvt",
				"mxu" => "video/vnd.mpegurl",
				"m4u" => "video/vnd.mpegurl",
				"pyv" => "video/vnd.ms-playready.media.pyv",
				"uvu" => "video/vnd.uvvu.mp4",
				"uvvu" => "video/vnd.uvvu.mp4",
				"viv" => "video/vnd.vivo",
				"webm" => "video/webm",
				"f4v" => "video/x-f4v",
				"fli" => "video/x-fli",
				"flv" => "video/x-flv",
				"m4v" => "video/x-m4v",
				"mkv" => "video/x-matroska",
				"mk3d" => "video/x-matroska",
				"mks" => "video/x-matroska",
				"mng" => "video/x-mng",
				"asf" => "video/x-ms-asf",
				"asx" => "video/x-ms-asf",
				"vob" => "video/x-ms-vob",
				"wm" => "video/x-ms-wm",
				"wmv" => "video/x-ms-wmv",
				"wmx" => "video/x-ms-wmx",
				"wvx" => "video/x-ms-wvx",
				"avi" => "video/x-msvideo",
				"movie" => "video/x-sgi-movie",
				"smv" => "video/x-smv",
				"ice" => "x-conference/x-cooltalk",
				"php" => "application/php",
				"rb" => "application/ruby",
				"con" => "application/concept",
				"csp" => "application/concept-server-page",
				"accel" => "application/concept-private",
				"package" => "application/concept-private",
				"ini" => "application/concept-private"
		];

		var v6only=value IniGet(inifile, "Server", "IPv6", "0");
		if (v6only) {
			this.Socket = new TCPSocket(-1, true);
			this.Socket.SetOption(IPPROTO_IPV6, IPV6_V6ONLY, 0);

			this.WSSocket = new TCPSocket(-1, true);
			this.WSSocket.SetOption(IPPROTO_IPV6, IPV6_V6ONLY, 0);

			if (!USE_TLS_PROXY) {
				this.TLSWSSocket = new TLSESocket(-1, null, true);
				this.TLSWSSocket.SetOption(IPPROTO_IPV6, IPV6_V6ONLY, 0);
			}
		} else {
			this.Socket = new TCPSocket();
			this.WSSocket = new TCPSocket();
			this.TLSWSSocket = new TLSESocket();
		}
		this.SSLWSSocketName = IniGet(inifile, "Server", "SecureProxyUnixSocket", "");
		if (this.SSLWSSocketName) {
			_unlink(this.SSLWSSocketName);
			this.SSLWSSocket = new UNIXSocket();
			this.SSLWSSocket.SetOption(IPPROTO_TCP, TCP_NODELAY, 1);
		}


		this.Socket.SetOption(IPPROTO_TCP, TCP_NODELAY, 1);
		this.WSSocket.SetOption(IPPROTO_TCP, TCP_NODELAY, 1);
		if (this.TLSWSSocket)
			this.TLSWSSocket.SetOption(IPPROTO_TCP, TCP_NODELAY, 1);

		this.Port = value IniGet(inifile, "Server", "Port", "2662");
		this.WSPort = value IniGet(inifile, "Server", "WebPort", "2680");
		this.SSLWSPort = value IniGet(inifile, "Server", "SecureWebPort", "2681");

		this.IniFile = inifile;

		for (var i = 0; i < DEFAULT_CGI_WORKERS; i++) {
			Workers[i] = new Worker("ConceptWorker", "Worker${i+1}");
			Sleep(100);
		}
	}

	LoadKeys() {
		var public_key = IniGet(this.IniFile, "Server", "WebSocketCertificate", "ssl/publickey.cer");
		var private_key = IniGet(this.IniFile, "Server", "WebSocketPrivateKey", "ssl/privatekey.pem");

		if (!this.TLSWSSocket.LoadKeys(public_key, private_key))
			this.Log("ConceptServer", "Warning: Error loading TLS/SSL keys. HTTPS/WSS will not be supported.");
	}

	NormalizeName(name, var hash_base) {
		name=StrReplace(name, "\\", "/");
		hash_base=name;

		var arr=StrSplit(name, "/");
		var len=length arr;
		var res="";
		for (var i=0;i<len;i++) {
			var e=arr[i];
			var e_next=arr[i+1];
			if ((e_next) && (e_next=="..")) {
				i++;
			} else
			if ((e != "..") && (e != ".")) {
				if (res)
					res+="/";
				else
					hash_base=e;
				res+=e;
			}
		}
		return res;
	}

	RouteMessage(source_apid, hash, apid, msg_id, msg, var err) {
		if (apid>0) {
			var connection=this.GetConnection(apid);
			if (connection) {
				this.Iterations++;
				var buf=tobin(source_apid, 32)+tobin(msg_id, 32)+tobin(length msg, 32)+msg;
				connection.Send(buf);
			} else {
				this.Log("ConceptServer", "Unknown APID: $apid (message sent by $source_apid)");
				err = true;
			}
		} else {
			this.Iterations++;
			buf=tobin(source_apid, 32)+tobin(msg_id, 32)+tobin(length msg, 32)+msg;

			var clients=this.Connections;
			var len=length clients;
			for (var i=0;i<len;i++) {
				connection=clients[i];
				if ((connection) && (connection.APID!=source_apid) && (connection.Hash==hash))
					connection.Send(buf);
			}
		}
	}

	ProcessMessage(apid, hash, var buf, var err) {
		err = false;
		while ((true) && (!err)) {
			var lbuf = length buf;
			if (lbuf >= 12) {
				var target_apid=tonumber(buf[0]+buf[1]+buf[2]+buf[3], 32);
				var msg_id=tonumber(buf[4]+buf[5]+buf[6]+buf[7], 32);
				var len=tonumber(buf[8]+buf[9]+buf[10]+buf[11], 32);
				if (lbuf >= len + 12) {
					var msg = SubStr(buf, 12, len);
					buf = SubStr(buf, 12 + len, lbuf);
					this.RouteMessage(apid, hash, target_apid, msg_id, msg, err);
				} else
					break;
			} else
				break;
		}
		return buf;
	}

	public GetConnection(apid) {
		var key=""+apid;
		if (IsSet(this.Connections, key))
			return this.Connections[key];
		return null;
	}

	public GetSession(session) {
		var clients=this.Connections;
		var len=length clients;
		for (var i=0;i<len;i++) {
			var c=clients[i];
			if ((c) && (c.Session==session))
				return c;
		}
		return null;
	}

	public GetHost(host) {
		var clients=this.Connections;
		var len=length clients;
		for (var i=0;i<len;i++) {
			var c=clients[i];
			if ((c) && (c.HostID == host) && (c.ChildCount < c.MaxChilds) && (c.ChildCount >= 0))
				return c;
		}
		return null;
	}

	public CloseChildren(apid) {
		var clients=this.Connections;
		var len=length clients;
		for (var i=0;i<len;i++) {
			var c=clients[i];
			if ((c) && (c.UsingHost==apid))
				c.PID = -3;
		}
	}



	public Statistics() {
		/*var clients=this.Connections;
		var len=length clients;
		var cpu=0;
		var t=0;
		var f=0;
		var real_len=0;
		for (var i=0;i<len;i++) {
			var c=clients[i];
			if (c) {
				real_len++;
				if (c.PID>0) {
					var ru=getrusage(c.PID);
					if (ru) {
						cpu+=(ru["ru_utime"]+ru["ru_stime"])/1000;
						t+=ru["ru_maxrss"];
						f+=ru["ru_majflt"];
					}
				}
			}
		}
		var file=new File("a+");
		file.Name="statistics.txt";
		file.Open();
		file.Write("$real_len\t$cpu\t$t\t$f\n");
		file.Close();*/
	}

	public Clean() {
		if (this.PlaceHolders>=50) {
			this.PlaceHolders=0;
			var clients=this.Connections;
			var len=length clients;
			var res=new [];
			var cleaned=0;
			for (var i=0;i<len;i++) {
				var c=clients[i];
				if (c)
					res[""+c.APID]=c;
				else
					cleaned++;
			}
			if (cleaned) {
				this.Log("ConceptServer", "$cleaned placeholders cleaned");
				this.Connections=res;
			}
		}
	}

	private AcceptChild(loop, socket, websocket=false, tls=false) {
		this.Statistics();
		var child = new ConceptChild(this, socket);
		if (tls)
			child.TLS = tls;
		child.IsWebSocket = websocket;
		threads++;
		loop.Add(child.Iterate);
	}

	private RunService(loop, servicename) {
		var child = new ConceptChild(this, null);
		child.ServerName = servicename;
		loop.Add(child.IterateService);
	}

	Log(domain, text) {
		try {
			var t=StrReplace(StrReplace(ctime(time()), "\r", ""), "\n", "");
			var str="$t $domain: $text\n";
			if (this.LogFile) {
				if (!LogFileHandle) {
					var f=new File("a");
					f.Name=this.LogFile;
					if (f.Open())
						LogFileHandle = f;
					else
						echo str + " (log I/O error)";
					// f.Write(str);
					// f.Close();
				}
				if (LogFileHandle)
					LogFileHandle.Write(str);
			} else
				echo str;
		} catch (var e) {
			echo "Log IO exception: ";
			echo e;
			echo "\n";
			echo "$domain: $text\n";
		}
	}

	ChooseWorker() {
		if (Workers) {
			if (TargetWorker >= length Workers)
				TargetWorker = 0;
			return Workers[TargetWorker++];
		}
		return null;
	}

	ChooseH2Worker() {
		if (H2Workers) {
			if (TargetH2Worker >= length H2Workers)
				TargetH2Worker = 0;
			return H2Workers[TargetH2Worker++];
		}
		return null;
	}

	BackgroundTasks() {
		var loop = this.Loop;

		this.RunService(loop, "ServiceManager.con");

		var socket = this.Socket;
		var wsocket =  this.WSSocket;
		var sslwsocket = this.SSLWSSocket;
		var tlswssocket = this.TLSWSSocket;

		var iterations;
		var timeout = 0;
		var empty_iterations = 0;
		var sock_fd = socket.Socket;
		var wsock_fd = wsocket.Socket;
		var sockets = [sock_fd, wsock_fd];
		var sslsock_fd = -1;
		var tlssock_fd = -1;
		if (sslwsocket) {
			sslsock_fd = sslwsocket.Socket;
			sockets[2] = sslsock_fd;
		}
		if (tlswssocket) {
			tlssock_fd = tlswssocket.Socket;
			sockets[3] = tlssock_fd;
		}
		while (Running) {
			try {
				if ((SocketPoll(sockets, var outsockets, timeout)) && (outsockets)) {
					// check for connection
					if ((outsockets[0] == sock_fd) || (outsockets[1] == sock_fd) || (outsockets[2] == sock_fd)) {
					//if (socket.GetHasData(timeout)) {
						this.Iterations++;
						var s = socket.Accept();
						if ((s) && (s.Socket > 0))
							AcceptChild(loop, s);
						else
							this.Log("ConceptServer", "Invalid socket in accept");
					}
					//if (wsocket.GetHasData()) {
					if ((outsockets[0] == wsock_fd) || (outsockets[1] == wsock_fd) || (outsockets[2] == wsock_fd)) {
						this.Iterations++;
						s = wsocket.Accept();
						if ((s) && (s.Socket>0))
							AcceptChild(loop, s, true);
						else
							this.Log("ConceptServer", "Invalid socket in accept (websocket)");
					}
					//if ((sslwsocket) && (sslwsocket.GetHasData())) {
					if ((outsockets[0] == sslsock_fd) || (outsockets[1] == sslsock_fd) || (outsockets[2] == sslsock_fd)) {
						this.Iterations++;
						s = sslwsocket.Accept();
						if ((s) && (s.Socket>0))
							AcceptChild(loop, s, true, true);
						else
							this.Log("ConceptServer", "Invalid socket in accept (websocket)");
					}
					if ((outsockets[0] == tlssock_fd) || (outsockets[1] == tlssock_fd) || (outsockets[2] == tlssock_fd)) {
						this.Iterations++;
						s = tlswssocket.AcceptTCP();
						if ((s) && (s.Socket>0))
							AcceptChild(loop, s, true, 2);
						else
							this.Log("ConceptServer", "Invalid socket in accept (websocket)");
					}
				}
				if (iterations == this.Iterations) {
					// nothing happened, give CPU a chance to do something else
					timeout = 5;
					empty_iterations++;
				} else {
					this.Iterations = 0;
					iterations = 0;
					empty_iterations = 0;
					timeout = 0;
				}

				if (empty_iterations > 1000) {
					// help the CPU
					//Sleep(50);
					timeout = 100;
				} else
				if (empty_iterations > 100) {
					// help the CPU
					//Sleep(10);
					timeout = 20;
				}
			} catch (var exc) {
				this.Log("ConceptServer", exc);
			}
		}
		this.CloseClients();
	}

	ServerCloses(signum) {
		Running = false;
	}

	CloseClients() {
		if (ShuttingDown) {
			echo "Please wait while shutting down ...\n";
			return;
		}
		ShuttingDown = true;
		var connections = this.Connections;
		for (var i = 0; i < length connections; i++) {
			var client = connections[i];	
			if (client) {
				try {
					client.Disconnect("Server shutdown");
				} catch (var exc) {
					echo "Uncaught exception: $exc\n";
				}
				if (client.PID > 0) {
					kill(__PID(client.PID), SIGTERM);
					client.PID = -1;
				}
			}	
		}
		this.Log("ConceptServer", "Clean shut down ...");
		echo "Shutting down...\n";
	}

	IniGetPath(category, key, default_value = "") {
		var res = trim(IniGet(this.IniFile, category, key, default_value));
		if (res[0] == ".")
			return getcwd() + "/" + res;
		return res;
	}

	BrokenPipe(signum) {
		echo "Broken pipe received $signum\n";
		// nothing
	}

	RedirectHeader(var orig_app, var ServerName) {
		var tstamp = StrReplace(StrReplace(asctime(time()), "\r", ""), "\n", "")+" GMT";
		var location = "https://" + ServerName;
		if (SSLWSPort != 443)
			location += ":" + SSLWSPort;
		if ((orig_app) && (orig_app[0] != "/"))
			location += "/";
		location += orig_app;
		return "HTTP/1.1 302 Found\r\nDate: $tstamp\r\nConnection: close\r\nLocation: $location\r\nServer: " + SERVER_NAME + "\r\n\r\n";
	}

	Redirect(location, params) {
		if (params)
			location += "?" + params;
		return "HTTP/1.1 302 Found\r\nConnection: close\r\nLocation: $location\r\nServer: " + SERVER_NAME + "\r\n\r\n";
	}

	Start() {
		var max_connections = value IniGet(this.IniFile, "Server", "MaxConnections", "1024");
		var interface = IniGet(this.IniFile, "Server", "Interface", "");
		this.ConceptClient = this.IniGetPath("Paths", "ConceptClient", "./ConceptClient.js");
		this.cgi = this.IniGetPath("Paths", "CGIHandler", "conceptcgi");
		var cgi_other = IniGet(this.IniFile, "Paths", "OtherCGI", "");
		if (cgi_other) {
			var arr = StrSplit(cgi_other, ";");
			for (var i = 0; i < length arr; i++) {
				var e = StrSplit("" + arr[i], "=");
				var type = trim(e[0]);
				var val = trim(e[1]);
				if ((length e == 2) && (type) && (val))
					this.cgiother[type] = val;
			}
		}
		var max_fd=max_connections*5+10;
		if (setrlimit(RLIMIT_NOFILE, max_fd)) {
			// try to set it as super user
			if (setrlimit(RLIMIT_NOFILE, max_fd, max_fd))
				this.Log("ConceptServer", "WARNING: cannot set the maximum connection count to $max_fd");
		}

		if (Socket.Listen(this.Port, max_connections, interface))
			throw "Error initializing Concept server (port ${this.Port} already in use)";

		if (WSSocket.Listen(this.WSPort, max_connections, interface))
			throw "Error initializing Concept server WS socket (port ${this.WSPort} already in use)";

		if ((SSLWSSocket) && (SSLWSSocket.Listen(this.SSLWSSocketName, max_connections)))
			throw "Error initializing Concept server SSL WS socket (port ${this.SSLWSSocketName} already in use)";

		if (TLSWSSocket) {
			if (TLSWSSocket.Listen(this.SSLWSPort, max_connections, interface)) {
				throw "Error initializing Concept server TLS WS socket (port ${this.SSLWSPort} already in use)";
			} else {
				this.LoadKeys();
				if (value IniGet(this.IniFile, "Server", "HTTP2", "1")) {
					TLSWSSocket.AddALPN("h2");
					var h2worker_init_parameters = BinarizeObject([this.IniFile, this.ConceptClient, this.mimetypes, this.cgi, this.cgiother]);
					for (i = 0; i < DEFAULT_H2_WORKERS; i++) {
						H2Workers[i] = new Worker("ConceptH2Worker", h2worker_init_parameters);
						Sleep(100);
					}
				}
			}
		}

		var user = IniGet(this.IniFile, "Server", "User", "concept");
		var pwd  = IniGet(this.IniFile, "Server", "UserPassword", "");

		if (!SetCurrentUser(user, pwd))
			this.Log("ConceptServer", "WARNING: cannot change user to $user");
		pwd = "";

		this.LogFile = IniGetPath("Paths", "LogFile", "");
		var loop = new Greenloop();
		this.Loop = loop;

		// signal(SIGINT, this.ServerCloses);
		// signal(SIGQUIT, this.ServerCloses);
		// signal(SIGHUP, this.ServerCloses);
		// signal(SIGTERM, this.ServerCloses);
		signal(SIGPIPE, this.BrokenPipe);
		loop.Run([this.BackgroundTasks]);
		if (Running)
			throw "Broken socket";
	}
}

class Main {
	Main() {
		var ini_file="/usr/local/etc/concept.ini";
		if (!FileExists(ini_file))
			ini_file="/usr/etc/concept.ini";
		if (!FileExists(ini_file))
			ini_file="/etc/concept.ini";
		if (!FileExists(ini_file))
			ini_file=getcwd()+"/concept.ini";
		
		var s=new ConceptServer(ini_file);
		if (USE_TLS_PROXY) {
			if (ExecuteProcess("concept", ".", ["-mt", "ConceptTLSProxyServer.con"], [ ], false) < 0)
				s.Log("ConceptServer", "Error initializing Concept SSL proxy");
		}
		if (USE_DB_SERVICE) {
			if (ExecuteProcess("concept", ".", ["TinDB.con"], [ ], false) < 0) {
				if (ExecuteProcess(getcwd() + "/concept", ".", ["TinDB.con"], [ ], false) < 0)
					s.Log("ConceptServer", "Error running database service");
			}
		}
		try {
			s.Start();
		} catch (var exc) {
			echo exc;
			return -1;
		}
	}
}
