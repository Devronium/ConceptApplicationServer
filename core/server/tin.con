#!/usr/local/bin/concept

import standard.C.io
import standard.lang.cli
import standard.lib.preg
import standard.lib.json
include Worker.con
include TinDataBases.con
include CSV.con
include SQLParser.con

include Charset.con
include PDFGenerator.con

define REPORT_COLOR	"0.34 0.37 0.53"
define INVERSE_COLOR	"1.0 1.0 1.0"
define TITLE_FONT_SIZE	10
define REPORT_FONT_SIZE	8

class Container {
	var Data;

	Container(data) {
		this.Data = data;
	}
}

class Utils {
	static report_table(p, ref_text, title, values, header = null) {
		p.Font = "Helvetica-Bold";
		p.FontSize = REPORT_FONT_SIZE;
		if (title) {
			title = Charset::latin10(title);
			p = p.Append(title);
		}
		if (ref_text) {
			p.Push();
			p.FillColor = INVERSE_COLOR;
			p.Print(p.MarginLeft - 26, p.TextY - 18, ref_text, 36);
			p.Pop();
		}
		p.Font = "Helvetica";
		p.FontSize = REPORT_FONT_SIZE;
		var header_visible = true;
		if ((!header) && (values)) {
			var first_len = length values[0];
			header = new [];
			header[0] = ["Field", 0.3, 0, ["background": REPORT_COLOR, "text-color": INVERSE_COLOR, "color": INVERSE_COLOR]];
			for (var i = 1; i < first_len; i++)
				header[i] = "$i";

			header_visible = false;
		}
		p.Table(header,
			values,
			["header": ["background": REPORT_COLOR, "text-color": INVERSE_COLOR, "visible": header_visible], "border": 0.1, "padding":1]
		);
		return p;
	}

	static filter_keys(arr) {
		var keys = GetKeys(arr);
		if ((IsSet(arr, '$')) || (IsSet(arr, 'id'))) {
			var new_keys = new [];
			for (var i = 0; i < length keys; i++) {
				var k = keys[i];
				if ((k) && (k != '$') && (k != "id"))
					new_keys[length new_keys] = k;
			}
			return new_keys;
		}
		return keys;
	}

	protected static _pdfinit(title, author, landscape, var page) {
		var p;
		// landscape
		if (landscape)
			p = new PDFGenerator(PDF_A4_H, PDF_A4_W);
		else
			p = new PDFGenerator();
		p.Title = Charset::latin10(title);
		author = Charset::latin10(author);
		p.Creator = author;
		p.Author = author;
		p.Subject = title;
		p.Producer = "GyroGears";
		p.UseCompression = true;
		p.Encoding = "iso-8859-2";
		p.MarginLeft = 50;

		page = p.NewPage();
		page.Color = REPORT_COLOR;
		page.FillColor = REPORT_COLOR;
		page.Rectangle(0, 0, p.MarginLeft - 5, page.Height, true);
		page.FontSize = REPORT_FONT_SIZE;
		// page.LineWidth = 0.5;
		p.UseTemplate(page);

		p.Footer.TextY = 10;
		p.Footer.Color = REPORT_COLOR;
		p.Footer.FillColor = REPORT_COLOR;
		p.Footer.FontSize = REPORT_FONT_SIZE;
		p.Footer.Append("[#]", 1);

		return p;
	}

	static tostring(array, separator = ", ") {
		var str =  "";
		for (var i = 0; i < length array; i++) {
			var e = array[i];
			if ((typeof e == "string") || (typeof e == "numeric")) {
				if (str)
					str += separator;
				str += e;
			}
		}
		return str;
	}

	static pdfdocument(title, author = "", landscape = false) {
		var p = Utils::_pdfinit(title, author, landscape, null);
		// reset pages
		p.Pages = new [];
		return p;
	}

	static report(o, show_keys = null, title = "", sub_title = "", info_text = "", author = "") {
		var p;
		// landscape
		var header_size = 0;
		if (show_keys) {
			header_size = length show_keys;
		} else
		if ((o) && (typeof o == "array") && (typeof o[0] == "array")) {
			header_size = length Utils::filter_keys(o[0]);
		}

		if (header_size >= 9)
			p = Utils::_pdfinit(title, author, true, var page);
		else
			p = Utils::_pdfinit(title, author, false, page);

		if (title) {
			title = Charset::latin10(title);
			page = page.Append("$title\n", 0.5);
		}
		page.FontSize = REPORT_FONT_SIZE;
		if (sub_title) {
			sub_title = Charset::latin10(sub_title);
			page = page.Append("$sub_title\n", 0.5);
		}
		page.Rule();

		if (info_text)
			page = page << info_text;
		if (typeof o == "class")
			o = ToArray(o);
		if (typeof o == "array") {
			var keys = GetKeys(o);
			if ((keys) && (keys[0])) {
				// object info
				if (!show_keys)
					show_keys = keys;
			} else {
				if (!show_keys) {
					var first_o = o[0];
					if (typeof first_o == "class")
						first_o = ToArray(first_o);
					if (typeof first_o == "array")
						show_keys = Utils::filter_keys(first_o);
					if ((show_keys) && (!show_keys[0]))
						show_keys = null;
				}
				if (show_keys) {
					var values = new [];
					var headers = new [];
					for (var i = 0; i < length o; i++) {
						var obj = o[i];
						if (typeof obj == "class")
							obj = ToArray(obj);
						if (typeof obj == "array") {
							var val = new [];
							for (var j = 0; j < length show_keys; j++) {
								var k = show_keys[j];
								if (!j) {
									var vcol = i + 1;
									val[0] = vcol;
									headers[0] = [" ", ceil(length ("" + vcol) * 1.8), 1];
								}
								if ((k) && (IsSet(obj, k))) {
									var v = obj[k];
									var is_container = false;
									if (typeof v == "array") {
										v = Utils::tostring(v);
									} else
									if ((typeof v != "string") && (typeof v != "numeric")) {
										v = typeof v;
										is_container = true;
									}

									val[length val] = Charset::latin10("" + v);
									var prec_headers = headers[k];
									var len;
									if (v)
										len = length (StrSplit(("" + v), "\n")[0]);
									else
										len = 1;
									if (len < length k)
										len = length k;
									if ((typeof v == "string") && (v == ToUpper(v))) {
										// uppercase letter take more space
										len = ceil(len * 1.5);
									}
									if (len > 20)
										len = 20;
									if ((prec_headers) && (len < prec_headers[1]))
										len = prec_headers[1];
									if (len < length k)
										len = length k;

									if (typeof v == "numeric")
										headers[k] = [StrReplace(k, "_", " "), len, 1];
									else
									if (is_container)
										headers[k] = [StrReplace(k, "_", " "), len, 0.5];
									else
										headers[k] = [StrReplace(k, "_", " "), len, 0];
								} else
								if (k) {
									val[length val] = "";
									if (!headers[k]) {
										len = length k;
										if (len > 20)
											len = 20;
										headers[k] = [StrReplace(k, "_", " "), len, 0.5];
									}
								}
							}
							values[length values] = val;
						}
					}
					page = Utils::report_table(page, "*", "", values, headers);
				}
			}
		}
		return p.Generate();
	}
}

class IOWorker extends Worker{
	IOWorker(dummy) {
		var s = "";
		var sent = false;
		while (true) {
			if (s) {
				s += "\n";
			} else {
				if (sent) {
					while (!this.Pending(dummy, -1))
						Sleep(20);
					sent = false;
				}
				echo "> ";
			}

			s += trim(gets());
			if ((s) && (s[length s - 1] == '\\')) {
				s = SubStr(s, 0, length s - 1);
			} else
			if (s) {
			// if ((s) && (s[length s - 1] == ";")) {
				AddWorkerResultData(s);
				var s2 = s;
				while ((s2) && (s2[length s2 - 1] == ";"))
					s2 = SubStr(s2, 0, length s2 - 1);
				s2 = trim(s2);
				s = "";
				sent = true;
				if ((s2 == "exit") || (s2 == "quit") || (s2 == "done"))
					break;
			}
		}
	}
}

class Main {
	var connected = true;
	var db;
	var user;
	var password;
	var host;
	var port;
	var connection;
	var io;
	var queries;
	var output;
	var reconnecting = false;
	var close = false;
	var[] variables;

	static em(text, add_quote = false) {
		if (ON_MSWINDOWS) {
			if (add_quote)
				return "\"$text\"";
			return text;
		}
		return "\x1b[31;1m" + text + "\x1b[0m";
	}

	static bold(text, add_quote = false) {
		if (ON_MSWINDOWS) {
			if (add_quote)
				return "\"$text\"";
			return text;
		}
		return "\x1b[1m" + text + "\x1b[0m";
	}

	static is_string(text, add_quote = false) {
		if (ON_MSWINDOWS) {
			if (add_quote)
				return "\"$text\"";
			return text;
		}
		return "\x1b[33;1m" + text + "\x1b[0m";
	}

	GetParameters(arg, var db) {
		var[] parameters;
		for (var i = 0; i < length arg; i++) {
			var key = arg[i];
			if (key) {
				if (key[0] == "-") {
					while ((key) && (key[0] == "-"))
						key++;
					if (key) {
						var val = arg[++i];
						parameters[key] = val;
					}
				} else
					db = key;
			}
		}
		return parameters;
	}

	Connect(host, port, db) {
		connection = new TinConnection();
		if (connection.DriverOpen(db, host, port))
			return connection;

		return null;
	}

	space(key, len) {
		while (length key < len)
			key += " ";
		return key;
	}

	prefix(key, len) {
		while (length key < len)
			key = " " + key;
		return key;
	}

	safeoid(val) {
		for (var i = 0; i < length val; i++) {
			var v = val[i];
			if (((v < '0') || (v > '9')) && ((v < 'a') || (v > 'f')))
				return StringToHex(val);
		}
		return val;
	}

	print(obj, level = 0, var backref = null, prec_level_str = "") {
		if (typeof obj == "array") {
			if (level <= 1)
				backref = new [];
			backref["" + ClsPtr(obj)] = true;
			var level_str = "";
			for (var i = 0; i < level ; i++)
				level_str += "  ";
			var keys = GetKeys(obj);
			var max_len = 0;
			var is_static = true;
			for (i = 0; i < length keys; i++) {
				var key = keys[i];
				if ((key) && (length key > max_len)) {
					max_len = length key;
					is_static = false;
				} else {
					var val = obj[i];
					if ((typeof val != "string") && (typeof val != "numeric"))
						is_static = false;
				}
			}
			var is_object = max_len;
			if (level) {
				if (is_object) {
					echo "{";
				} else
					echo "[";
			}
			if (is_static) {
				echo " ";
				level_str = "";
				prec_level_str = "";
			} else
				echo "\n";
			for (i = 0; i < length obj; i++) {
				key = keys[i];
				var keystr;
				if (typeof key == "string")
					keystr = bold(space(key, max_len)) + ": ";
				else
					keystr = "";
				val = obj[i];
				echo "$level_str$keystr";
				if (typeof val == "array") {
					var backref_ptr = ""+ClsPtr(val);
					if (backref[backref_ptr]) {
						echo em("(reference to already printed object)");
						if (i < length obj - 1)
							echo ",";
						echo "\n";
					} else {
						backref[backref_ptr] = true;
						print(val, level + 1, backref, level_str);
					}
				} else {
					if ((key) && (key == "\$oid"))
						val = safeoid(val);
					if (typeof val == "string")
						val = is_string(val, true);
					echo val;
					if (is_static)
						echo " ";
					else
						echo "\n";
				}
			}
			if (level) {
				if (is_object)
					echo "$prec_level_str}\n";
				else
					echo "$prec_level_str]\n";
			}
			return;
		}
		echo obj;
	}

	notifycallback(subject, obj) {
		echo "Notification received\n";
		if (subject)
			echo "Subject: ${em(subject)}\n";
		echo "Content:\n";
		print(obj);
		echo "\nEnd content\n";
	}

	DoneQuery() {
		queries--;
		if ((this.close) && (!queries)) {
			echo "Done\n";
			panicexit(0);
		}
	}

	callback(r, id, err) {
		if (err) {
			connected = false;
			echo "${err[1]}\n";
			return false;
		}
		echo "OK\n";
		connection.OnNotify = notifycallback;
		if (!io)
			io = new Worker("IOWorker");
		DoneQuery();
	}

	SafeCSV(k, separator) {
		if (Pos(k, separator) > 0) {
			k = StrReplace(k, "\\", "\\\\");
			k = StrReplace(k, '"', "\\\"");
			k = "\"" + k + "\"";
		}
		return k;
	}

	WriteCSV(data, output, separator = ",", line_ending = "\n") {
		if (data) {
			var[] all_keys;
			for (var i = 0; i < length data; i++) {
				var obj = data[i];
				if (obj) {
					var keys = GetKeys(obj);
					for (var j = 0; j < length keys; j++) {
						var k = keys[j];
						if (typeof k == "string")
							all_keys[k] = k;
					}
				}
			}
			var csv = "";
			for (i = 0; i < length all_keys; i++) {
				k = SafeCSV(all_keys[i], separator);
				if (csv)
					csv += separator;
				csv +=  k;
			}
			if (!csv) {
				echo "Dataset contains no keys\n";
				return;
			}
			csv += line_ending;
			for (i = 0; i < length data; i++) {
				obj = data[i];
				if (obj) {
					var line = "";
					for (j = 0; j < length all_keys; j++) {
						k = all_keys[j];
						if (line)
							line += separator;
						if (IsSet(obj, k)) {
							var v = obj[k];
							switch (typeof v) {
								case "string":
								case "numeric":
									line += SafeCSV("" + v, separator);
									break;
								default:
									line += "/" + typeof v + "/";
							}
						}
					}
					if (line)
						csv += line + line_ending;
				}
			}
			WriteFile(csv, output);
		} else
			echo "${em("Dataset is empty")}\n";
	}

	TimeDelta(t) {
		return number_format((microseconds() - t)/1000000, 3, ".", "") + " seconds";
	}

	WritePDF(data, output, title = "") {
		if (data)
			WriteFile(Utils::report(data, null, title), output);
		else
			echo "${em("Dataset is empty")}\n";
	}

	querycallback(r, id, err, userdata = null) {
		if (userdata) {
			var query = userdata[0];
			var time = TimeDelta(userdata[1]);
		} else {
			query = "(info query)";
			time = "0 seconds";
			userdata = new [];
		}

		if (err) {
			echo "$query ($time):\n";
			echo "${em(err[1])}\n";
		} else {
			var count = 0;
			if (typeof r != "array")
				r = [r];
			if (r)
				count = length r;
			if (output) {
				echo "$query ($time), ${em(count)} records to file ${em(output)}\n";
				var ext = ToLower(Ext(output));
				switch (ext) {
					case "bin":
						WriteFile(BinarizeObject(r), output);
						break;
					case "xml":
						WriteFile(ToXML(new Container(r), true), output);
						break;
					case "csv":
						WriteCSV(r, output);
						break;
					case "pdf":
						WritePDF(r, output, query);
						break;
					default:
						WriteFile(JSONSerialize(r, true), output);
						break;
				}
			} else {
				if ((r) && (userdata[2]) && (userdata[2] == "count"))
					count = r[0];
				else
					print(r);
				echo "\n$query ($time), ${em(count)} records\n";
			}
		}
		DoneQuery();
	}

	storecallback(r, id, err, userdata) {
		var query = userdata[0];
		var time = TimeDelta(userdata[1]);

		if (err) {
			echo "$query ($time):\n";
			echo "${em(err[1])}\n";
		} else {
			if (typeof id == "array") {
				if (length id < 10)
					echo id;
				else
					echo "${length id} records stored\n";
				echo "\n$query ($time)\n";
			} else {
				echo id;
				echo "\n$query ($time)\n";
			}
		}
		DoneQuery();
	}

	requestcallback(r, id, err, userdata) {
		var query = userdata[0];
		var time = TimeDelta(userdata[1]);
		if (err) {
			echo "$query ($time):\n";
			echo "${em(err[1])}\n";
		} else {
			echo "$query ($time): OK\n";
		}
		DoneQuery();
	}

	LoadCSV(var data) {
		data = CSV::Do(data, null, var error, var error_text);
		if ((error) && (error_text)) {
			echo "Error in CSV: $error_text\n";
			return null;
		}
		var header = data[0];
		var objects = new [];
		if (header) {
			for (var i = 1; i < length data; i++) {
				var line = data[i];
				if (line) {
					var obj = new [];
					for (var j = 0; j < length header; j++) {
						var v = line[j];
						var h = header[j] ?? "_field_${j+1}";
						// skip ids
						if (h != '$') {
							var v_val = value v;
							if ("" + v_val == v)
								obj[h] = v_val;
							else
								obj[h] = v;
						}
					}
					if (obj)
						objects[length objects] = obj;
				}
			}
		}
		return objects;
	}

	SkipID(obj) {
		if (obj) {
			if (IsSet(obj, '$'))  {
				var keys = GetKeys(obj);
				var c = new [];
				for (var i = 0; i < length keys; i++) {
					var k = keys[i];
					if ((k) && (k != '$'))
						c[k] = obj[k];
				}
				return c;
			}
		}
		return obj;
	}

	SkipIDS(data) {
		if (data) {
			var keys = GetKeys(data);
			var is_set = true;
			if ((keys) && (keys[0]))
				is_set = false;
			if (is_set) {
				for (var i =0; i < length data; i++)
					data[i] = SkipID(data[i]);
			}
			return SkipID(data);
		}
		return data;
	}

	GetObjects(var data, ext) {
		switch (ext) {
			case "csv":
			case "txt":
				return LoadCSV(data);
			case "bin":
				return SkipIDS(UnBinarizeObject(data));
			case "json":
			default:					
				return SkipIDS(JSONDeserialize(data));
		}
	}
	
	SQL(s, orig_query = "", var err = "") {
		err = "";
		if (!orig_query)
			orig_query = s;
		var sql = SQLParser::parse(s, err, variables);
		if ((sql) && (!err)) {
			var dataset, fields, collection, lang, keys;
			for (var i = 0; i < length sql; i++) {
				var q = sql[i];
				if (q) {
					if (IsSet(q, "SELECT")) {
						fields = q["SELECT"];
						if (q["DUMMY"]) {
							queries++;
							querycallback(fields, 0, null, [orig_query, microseconds()]);
							break;
						}
						if ((fields) && (length fields == 1) && (fields[0] == "*"))
							fields = null;	

						collection = q["FROM"];
						var where = q["WHERE"] ?? [ ];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						var mod = q["MOD"];
						var join = q["JOIN"];
						var reduce = q["REDUCE"];
						if (mod) {
							var agg = mod[0][0];
							if (agg == "COUNT") {
								dataset.Query(["#" => where], querycallback, fields, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1), q["PRIORITY"], false, reduce);
							} else {
								echo "Unsupported SQL function ${em(agg)}\n";
								break;
							}
						} else
						if (join) {
							var join_query = [where];	
							for (var j = 0; j < length join; j++)
								join_query[length join_query] = join[j];
							dataset.Join(join_query, querycallback, fields, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1), q["PRIORITY"], false, reduce);
						} else {
							dataset.Query(where, querycallback, fields, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1), q["PRIORITY"], false, reduce);
						}
						queries++;
						echo "SQL-like query sent, waiting response (${queries} in queue, including this one)...\n";
					} else
					if (IsSet(q, "INSERT")) {
						collection = q["INTO"];
						var values = q["INSERT"];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds(), s];
						keys = GetKeys(values);
						dataset.Store(values, ((!keys) || (!keys[0])), storecallback);
						queries++;
						echo "Object sent, waiting response (${queries} in queue, including this one)...\n";
					} else
					if (IsSet(q, "DELETE")) {
						collection = q["FROM"];
						where = q["WHERE"] ?? [ ];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						dataset.Delete(where, querycallback);
						queries++;
						echo "Delete request sent, waiting response (${queries} in queue, including this one)...\n";
					} else
					if (IsSet(q, "UPDATE")) {
						collection = q["UPDATE"];
						where = q["WHERE"] ?? [ ];
						values = q["SET"];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						dataset.Update(where, values, querycallback, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1));
						queries++;
						echo "Update request sent, waiting response (${queries} in queue, including this one)...\n";
					} else
					if (IsSet(q, "DROP")) {
						collection = q["DROP"];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						dataset.Drop(requestcallback);
						queries++;
						echo "Request sent, waiting response (${queries} in queue, including this one)...\n";
					} else
					if (IsSet(q, "INDEX")) {
						collection = q["INDEX"];
						values = q["ON"];
						dataset = new TinDataSet(connection, collection);
						if (q["BM25"]) {
							if (!values)
								values = null;
							lang = q["LANG"];
							if (!lang)
								lang = "en";
							dataset = new TinDataSet(connection, collection);
							dataset.EnsureFullText(values, lang);
						} else {
							if (length values > 1)
								values = [values];
							dataset.EnsureIndexes(values);
						}
						echo "OK\n";
					} else
					if (IsSet(q, "DROP INDEX")) {
						collection = q["DROP INDEX"];
						values = q["ON"];
						if (length values > 1)
							values = [values];
						dataset = new TinDataSet(connection, collection);
						dataset.DropIndexes(values);
						echo "OK\n";
					} else
					if (IsSet(q, "DROP BM25")) {
						collection = q["DROP BM25"];
						values = q["ON"];
						dataset = new TinDataSet(connection, collection);
						dataset.DropFullText();
						echo "OK\n";
					} else
					if (IsSet(q, "SEQUENCE")) {
						collection = q["SEQUENCE"];
						var increment = q["INCREMENT"];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						dataset.Generate(collection, querycallback, increment);
						queries++;
						echo "Sequence request sent, waiting response (${queries} in queue, including this one)...\n";
					} else
					if (IsSet(q, "CODE")) {
						var code = q["CODE"];
						dataset = new TinDataSet(connection, "db");
						dataset.UserData = [orig_query, microseconds()];
						dataset.js(code, querycallback);
						queries++;
						echo "JS code sent, waiting response (${queries} in queue, including this one)...\n";
					}
				}
			}
			return true;
		}
		return false;
	}

	Command(s) {
		if (!s)
			return;
		while ((s) && (s[length s - 1] == ";"))
			s = trim(SubStr(s, 0, length s - 1));

		if (!s)
			return;

		var orig_query = s;
		var query_arr = preg(s, '^([A-Za-z0-9\_]+)\\.([A-Za-z0-9\_]+)\\((.*)\\)$');
		var collection = "";
		var parameters = "";

		if (length query_arr > 2) {
			s = ToLower("" + query_arr[2]);
			collection = query_arr[1];
			if (length query_arr > 3) {
				parameters = trim("" + query_arr[3]);
				if (parameters) {
					if (((parameters[0] == "{") || (parameters[0] == "[")) && (s != "search")) {
						var orig_params = parameters;
						parameters = JSONDeserialize(parameters);
						if (typeof parameters != "array")
							echo "Error parsing JSON: '$orig_params'\n\n";
					} else
					if ((parameters[0] != "'") && (parameters[0] != "\""))
						parameters = value parameters;
					else
					if (parameters[0] == parameters[length parameters - 1])
						parameters = SubStr(parameters, 1, length parameters - 2);
				}
			}
		} else
		if (length s >= 3) {
			var s_lower = ToLower(s);
			if ((SubStr(s_lower, 0, 3) == "use") && ((s[3] == " ") || (s[3] == "\t"))) {
				parameters = trim(SubStr(s, 4));
				s = "use";
			} else
			if (length s >= 6) {
				if (s_lower == "output") {
					output = null;
					echo "Output results to stdout\n";
					return;
				} else
				if ((SubStr(s_lower, 0, 6) == "output") && ((s[6] == " ") || (s[6] == "\t"))) {
					output = trim(SubStr(s, 7));
					if ((length output > 1) && (((output[0] == "'") || (output[0] == "\"")) && (output[0] == output[length output - 1])))
						output = SubStr(output, 1, length output - 2);
					if (output)
						echo "Output results to '$output'\n";
					else
						echo "Output results to stdout\n";
					return;
				}
			}

			switch (s_lower) {
				case "databases":
				case "collections":
				case "top":
				case "version":
					connection.Info(s_lower, querycallback);
					queries++;
					echo "Request sent, waiting response (${queries} in queue, including this one)...\n";
					return;
			}
		}
		switch (s) {
			case "query":
				if (!collection) {
					echo "No collection selected\n";
					return;
				}
				if (!parameters)
					parameters = new [];
				var dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Query(parameters, querycallback);
				queries++;
				echo "Query sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "count":
				if (!collection) {
					echo "No collection selected\n";
					return;
				}
				if (!parameters)
					parameters = new [];
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds(), s];
				dataset.Query(["#" => parameters], querycallback);
				queries++;
				echo "Query sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "aggregate":
			case "join":
				if (!collection) {
					echo "No collection selected\n";
					return;
				}
				if (!parameters)
					parameters = new [];
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Join(parameters, querycallback);
				queries++;
				echo "Query sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "search":
				if (!collection) {
					echo "No collection selected\n";
					return;
				}
				parameters = "" + parameters;
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Search(parameters, querycallback);
				queries++;
				echo "Search '$parameters' sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "store":
				if (!collection) {
					echo "No collection selected\n";
					return;
				}
				if (typeof parameters != "array")
					parameters = ["_" => parameters];
				if (!parameters)
					parameters = new [];
				dataset = new TinDataSet(connection, collection);
				var keys = GetKeys(parameters);
				dataset.UserData = [orig_query, microseconds(), s];
				dataset.Store(parameters, ((!keys) || (!keys[0])), storecallback);
				queries++;
				echo "Object sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "drop":
				if (!collection) {
					echo "No collection selected\n";
					return;
				}
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Drop(requestcallback);
				queries++;
				echo "Request sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "info":
				if (queries) {
					if (queries == 1)
						echo "1 query queued\n";
					else
						echo "${queries} queries queued\n";
				} else
					echo "No queries queued\n";
				break;
			case "index":
			case "ensureindex":
			case "ensureindexes":
				if (!collection) {
					echo "No collection selected\n";
					return;
				}
				if (!parameters) {
					echo "No index specified\n";
					return;
				}
				if (typeof parameters != "array")
					parameters = [parameters];
				dataset = new TinDataSet(connection, collection);
				dataset.EnsureIndexes(parameters);
				echo "OK\n";
				break;
			case "fulltext":
				if (!collection) {
					echo "No collection selected\n";
					return;
				}
				var lang = "en";
				var fields = null;
				if (parameters) {
					if (typeof parameters == "string") {
						lang = parameters;
					} else
					if (typeof parameters == "array") {
						keys = GetKeys(parameters);
						if ((keys) && (keys[0])) {
							fields = parameters["fields"];
							lang = parameters["language"] ?? "en";
						} else
							fields = parameters;
					}
				}
				dataset = new TinDataSet(connection, collection);
				dataset.EnsureFullText(fields, lang);
				echo "Full text index request sent, for \"$lang\" language\n";
				if (fields) {
					echo "Index will use fields:\n";
					echo fields;
					echo "\n";
				}
				break;
			case "delete":
				if (!collection) {
					echo "No collection selected\n";
					return;
				}
				if (!parameters)
					parameters = new [];
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Delete(parameters, querycallback);
				queries++;
				echo "Delete request sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "update":
				if (!collection) {
					echo "No collection selected\n";
					return;
				}
				if ((!parameters) || (typeof parameters != "array") || (!parameters["set"]) || (typeof parameters["set"] != "array")) {
					echo em("Nothing to update") + "\n";
					break;
				}
				if (!parameters["select"])
					parameters["select"] = new [];
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Update(parameters["select"], parameters["set"], querycallback);
				queries++;
				echo "Update request sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "addsubject":
			case "removesubject":
				if (typeof parameters != "string")
					parameters = "";
				if (s == "addsubject")
					connection.AddSubject(parameters);
				else
					connection.RemoveSubject(parameters);
				echo "OK\n";
				break;
			case "notify":
				var subject = "";
				if (typeof parameters == "array") {
					if (IsSet(parameters, "subject"))
						subject = parameters["subject"];

					if (IsSet(parameters, "object"))
						parameters = parameters["object"];
				}
				connection.Notify(parameters, subject);
				break;
			case "load":
				if (!collection) {
					echo "No collection selected\n";
					return;
				}
				if ((!parameters) || (typeof parameters != "string")) {
					echo "No file specified.\n";
					return;
				}
				var data = ReadFile(parameters);
				if (!data) {
					echo "File '$parameters' is empty or does not exists.\n";
					return;
				}
				var objects = GetObjects(data, ToLower(Ext(parameters)));
				if (!objects) {
					echo "File '$parameters' contains no usable objects.\n";
					return;
				}
				dataset = new TinDataSet(connection, collection);
				keys = GetKeys(objects);
				var is_set = ((!keys) || (!keys[0]));
				dataset.UserData = [orig_query, microseconds(), s];
				dataset.Store(objects, is_set, storecallback);
				queries++;
				if (is_set)
					echo "${length objects} objects sent, waiting response (${queries} in queue, including this one)...\n";
				else
					echo "1 object sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "done":
				if (queries) {
					this.close = true;
					echo "Waiting for ${em(queries)} queries to finish\n";
					break;
				}
				// no break here
			case "quit":
			case "exit":
				if (connection) {
					connection.Disconnect();
					connection = null;
				}
				connected = false;
				break;
			case "use":
				if ((!parameters) || (typeof parameters != "string")) {
					echo "No database specified\n";
					return;
				}
				connection.Database = parameters;
				echo "Using database ${parameters}\n";
				break;
			case "help":
				echo "Local commands: info, quit, exit, done, output [outputfilename], use dbname, databases, collections, top, version\n";
				echo "TinDB commands:\n";
				echo "    ${em("collection.query")}(criteria_object);\n";
				echo "        Search object, matching criteria\n";
				echo "        eg: student.query({\"Name\": \"Jane\"});\n";
				echo "    ${em("collection.count")}(criteria_object);\n";
				echo "        Count objects in collection matching criteria\n";
				echo "    ${em("collection.delete")}(criteria_object);\n";
				echo "        delete an object from collection, matching criteria\n";
				echo "        eg: student.delete({\"Name\": \"Jane\"});\n";
				echo "    ${em("collection.store")}(object);\n";
				echo "        store an arbitray object, eg:. student.store({\"Name\": \"George\"})\n";
				echo "        may also use arrays, eg:. student.store([{\"Name\": \"George\"}, {\"Name\": \"Jane\"}])\n";
				echo "    ${em("collection.update")}({\"select\": query, \"set\": object});\n";
				echo "        update multiple objects, eg:. student.update({\"select\": {\"Year\": 1}, \"set\": {\"Year\": 2}})\n";
				echo "    ${em("collection.load")}(filename);\n";
				echo "        load objects from JSON or CSV file\n";
				echo "    ${em("collection.search")}(searchstring);\n";
				echo "        perform bm25 search\n";
				echo "    ${em("collection.drop")}();\n";
				echo "        drop collection\n";
				echo "    ${em("collection.index")}(index);\n";
				echo "        create btree index\n";
				echo "    ${em("collection.fulltext")}(string language | array fields | {\"language\": \"en\", \"fields\": array);\n";
				echo "        create full text index\n";
				echo "\n";
				break;
			default:
				if (!SQL(s, orig_query, var err)) {
					if (err)
						echo em(err) + "\n";
					if (length s > 20)
						s = SubStr(s, 0, 20) + "...";
					echo "Command '$s' not understood\n";
				}
		}
	}

	Loop() {
		var connection = Connect(host, port, db);
		echo "Connecting ...\n";
		if (!connection) {
			echo "Error connecting to database $host:$port/$db\n";
			if (reconnecting)
				return 0;
			return -1;
		}
		reconnecting = true;
		echo "Authorizing ...\n";

		var dataset = new TinDataSet(connection, "users");
		queries++;
		dataset.Auth(user, password, db, callback);
		while (connected) {
			if (!connection.Iterate(true)) {
				echo "Disconnected\n";
				return 0;
			}
			if (io) {
				if (io.GetResult(var s) > 0) {
					if (s) {
						Command(s);
						io.AddData("ok");
						continue;
					}
				}
			}
			if (queries <= 0)
				Sleep(20);
			else
				Sleep(1);
		}
		return true;
	}

	Main() {
		echo "TinDB client console application v0.1\n";
		echo "Developed by Eduard Suica, released into public domain\n";
		echo "Type ${em("help", true)} for help\n\n";
		db = "appdb";
		var parameters = GetParameters(CLArg(), db);
		user = parameters["u"] ?? "sysdbadministrator";
		password = parameters["p"] ?? "sysdbadministrator";
		host = parameters["h"] ?? "localhost";
		port = value (parameters["P"] ?? "2668");

		while ((!Loop()) && (connected)) {
			echo "Reconnecting...\n";
			Sleep(1000);
			queries = 0;
		}
	}
}
