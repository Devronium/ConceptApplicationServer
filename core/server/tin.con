#!/usr/local/bin/concept

import standard.C.io
import standard.lang.cli
import standard.lib.preg
import standard.lib.json
import standard.lib.readline

include Worker.con
include TinDataBases.con
include File.con
include CSV.con
include SpreadsheetML.con
include SQLParser.con

include Charset.con
include PDFGenerator.con

define REPORT_COLOR	"0.34 0.37 0.53"
define INVERSE_COLOR	"1.0 1.0 1.0"
define SSREPORT_COLOR	"#565E87"
define SSINVERSE_COLOR	"#FFFFFF"
define TITLE_FONT_SIZE	10
define REPORT_FONT_SIZE	8
define NEW_LINE		"\r\n"
define CSV_BIG_FILE	0x100000
define WRITE_BUFFER	0xFFFF

class Container {
	var Data;

	Container(data) {
		this.Data = data;
	}
}

class Utils {
	static report_table(p, ref_text, title, values, header = null) {
		p.Font = "Helvetica-Bold";
		p.FontSize = REPORT_FONT_SIZE;
		if (title) {
			title = Charset::latin10(title);
			p = p.Append(title);
		}
		if (ref_text) {
			p.Push();
			p.FillColor = INVERSE_COLOR;
			p.Print(p.MarginLeft - 26, p.TextY - 18, ref_text, 36);
			p.Pop();
		}
		p.Font = "Helvetica";
		p.FontSize = REPORT_FONT_SIZE;
		var header_visible = true;
		if ((!header) && (values)) {
			var first_len = length values[0];
			header = new [];
			header[0] = ["Field", 0.3, 0, ["background": REPORT_COLOR, "text-color": INVERSE_COLOR, "color": INVERSE_COLOR]];
			for (var i = 1; i < first_len; i++)
				header[i] = "$i";

			header_visible = false;
		}
		p.Table(header,
			values,
			["header": ["background": REPORT_COLOR, "text-color": INVERSE_COLOR, "visible": header_visible], "border": 0.1, "padding":1]
		);
		return p;
	}

	static filter_keys(arr) {
		var keys = GetKeys(arr);
		if ((IsSet(arr, '$')) || (IsSet(arr, 'id'))) {
			var new_keys = new [];
			for (var i = 0; i < length keys; i++) {
				var k = keys[i];
				if ((k) && (k != '$') && (k != "id"))
					new_keys[length new_keys] = k;
			}
			return new_keys;
		}
		return keys;
	}

	protected static _pdfinit(title, author, landscape, var page) {
		var p;
		// landscape
		if (landscape)
			p = new PDFGenerator(PDF_A4_H, PDF_A4_W);
		else
			p = new PDFGenerator();
		p.Title = Charset::latin10(title);
		author = Charset::latin10(author);
		p.Creator = author;
		p.Author = author;
		p.Subject = title;
		p.Producer = "GyroGears";
		p.UseCompression = true;
		p.Encoding = "iso-8859-2";
		p.MarginLeft = 50;

		page = p.NewPage();
		page.Color = REPORT_COLOR;
		page.FillColor = REPORT_COLOR;
		page.Rectangle(0, 0, p.MarginLeft - 5, page.Height, true);
		page.FontSize = REPORT_FONT_SIZE;
		// page.LineWidth = 0.5;
		p.UseTemplate(page);

		p.Footer.TextY = 10;
		p.Footer.Color = REPORT_COLOR;
		p.Footer.FillColor = REPORT_COLOR;
		p.Footer.FontSize = REPORT_FONT_SIZE;
		p.Footer.Append("[#]", 1);

		return p;
	}

	static tostring(array, separator = ", ") {
		var str =  "";
		for (var i = 0; i < length array; i++) {
			var e = array[i];
			if ((typeof e == "string") || (typeof e == "numeric")) {
				if (str)
					str += separator;
				str += e;
			}
		}
		return str;
	}

	static pdfdocument(title, author = "", landscape = false) {
		var p = Utils::_pdfinit(title, author, landscape, null);
		// reset pages
		p.Pages = new [];
		return p;
	}

	static report(o, show_keys = null, title = "", sub_title = "", info_text = "", author = "") {
		var p;
		// landscape
		var header_size = 0;
		if (show_keys) {
			header_size = length show_keys;
		} else
		if ((o) && (typeof o == "array") && (typeof o[0] == "array")) {
			header_size = length Utils::filter_keys(o[0]);
		}

		if (header_size >= 9)
			p = Utils::_pdfinit(title, author, true, var page);
		else
			p = Utils::_pdfinit(title, author, false, page);

		if (title) {
			title = Charset::latin10(title);
			page = page.Append("$title\n", 0.5);
		}
		page.FontSize = REPORT_FONT_SIZE;
		if (sub_title) {
			sub_title = Charset::latin10(sub_title);
			page = page.Append("$sub_title\n", 0.5);
		}
		page.Rule();

		if (info_text)
			page = page << info_text;
		if (typeof o == "class")
			o = ToArray(o);
		if (typeof o == "array") {
			var keys = GetKeys(o);
			if ((keys) && (keys[0])) {
				// object info
				if (!show_keys)
					show_keys = keys;
			} else {
				if (!show_keys) {
					var first_o = o[0];
					if (typeof first_o == "class")
						first_o = ToArray(first_o);
					if (typeof first_o == "array")
						show_keys = Utils::filter_keys(first_o);
					if ((show_keys) && (!show_keys[0]))
						show_keys = null;
				}
				if (show_keys) {
					var values = new [];
					var headers = new [];
					for (var i = 0; i < length o; i++) {
						var obj = o[i];
						if (typeof obj == "class")
							obj = ToArray(obj);
						if (typeof obj == "array") {
							var val = new [];
							for (var j = 0; j < length show_keys; j++) {
								var k = show_keys[j];
								if (!j) {
									var vcol = i + 1;
									val[0] = vcol;
									headers[0] = [" ", ceil(length ("" + vcol) * 1.8), 1];
								}
								if ((k) && (IsSet(obj, k))) {
									var v = obj[k];
									var is_container = false;
									if (typeof v == "array") {
										v = Utils::tostring(v);
									} else
									if ((typeof v != "string") && (typeof v != "numeric")) {
										v = typeof v;
										is_container = true;
									}

									val[length val] = Charset::latin10("" + v);
									var prec_headers = headers[k];
									var len;
									if (v)
										len = length (StrSplit(("" + v), "\n")[0]);
									else
										len = 1;
									if (len < length k)
										len = length k;
									if ((typeof v == "string") && (v == ToUpper(v))) {
										// uppercase letter take more space
										len = ceil(len * 1.5);
									}
									if (len > 20)
										len = 20;
									if ((prec_headers) && (len < prec_headers[1]))
										len = prec_headers[1];
									if (len < length k)
										len = length k;

									if (typeof v == "numeric")
										headers[k] = [StrReplace(k, "_", " "), len, 1];
									else
									if (is_container)
										headers[k] = [StrReplace(k, "_", " "), len, 0.5];
									else
										headers[k] = [StrReplace(k, "_", " "), len, 0];
								} else
								if (k) {
									val[length val] = "";
									if (!headers[k]) {
										len = length k;
										if (len > 20)
											len = 20;
										headers[k] = [StrReplace(k, "_", " "), len, 0.5];
									}
								}
							}
							values[length values] = val;
						}
					}
					page = Utils::report_table(page, "*", "", values, headers);
				}
			}
		}
		return p.Generate();
	}
}

class IOWorker extends Worker{
	Word(buf) {
		buf = trim(buf);
		buf = StrReplace(buf, "\t", " ");
		var buf_arr = StrSplit(buf, " ");
		if (buf_arr)
			return buf_arr[length buf_arr - 1];
		return "";
	}

	Completion(buf) {
		var word = ToUpper(Word(buf));
		buf = rtrim(buf);
		var buffer_upercase = StrReplace(ToUpper(buf), "\t", " ");
		if (buffer_upercase) {
			var syntax = ["INSERT INTO ", "DELETE FROM ", "REDUCE { ", "CODE { ", "CREATE ", "AFTER ", "BEFORE ", "SELECT ", "FROM ", "UPDATE ", "CREATE BM25 INDEX ON ", "CREATE INDEX(", "CREATE TRIGGER ", "SEQUENCE ", "USE ", "VALUES ", "* FROM ", "WHERE ", "OFFSET ", "LIMIT ", "LEFT JOIN ", "ORDER ASC", "ORDER DESC", "GROUP BY", "COLLECTIONS", "TOP", "GC", "CLEAR", "MEMORY", "VERSION", "IN (", "AND ", "{ }", "QUIT", "DROP COLLECTION ", "DROP INDEX(", "DROP BM25 INDEX ON ", "SET ", "DONE", "NODE", "RING", "OUTPUT ", "EXPLAIN SELECT ", "PING"];
			var[] values;
			for (var i = 0; i < length syntax; i++) {
				var k = syntax[i];
				if (k) {
					var pos = Pos(k, word);
					if (pos == 1) {
						var buf2 = SubStr(buf, 0, length buf - length word);
						values[length values] = buf2 + k;
					}
				}			
			}
			return values;
		}
	}

	Hint(buf) {
		var word = ToUpper(Word(buf));
		switch (word) {
			case "SELECT":
				return " *";
			case "FROM":
				return " collection";
			case "OFFSET":
				return " start";
			case "LIMIT":
				return " records_count";
			case "REDUCE":
				return " { js }";
			case "INSERT":
				return " INTO";
			case "DELETE":
				return " FROM";
			case "UPDATE":
				return " collection";
			case "CREATE":
				return " INDEX";
			case "OUTPUT":
				return " [file.csv|file.json|file.xml|file.bin|file.xls|]";
		}
	}

	IOWorker(dummy) {
		var s = "";
		var sent = false;
		ttyloadhistory();
		ttymaxhistory(500);
		while (true) {
			if (s) {
				s += NEW_LINE;
			} else {
				if (sent) {
					while (!this.Pending(dummy, -1))
						Sleep(20);
					sent = false;
				}
				// echo "> ";
			}

			s += trim(ttyreadline("tin> ", this.Completion, this.Hint));
			if ((s) && (s[length s - 1] == '\\')) {
				s = SubStr(s, 0, length s - 1);
			} else
			if (s) {
				ttysavehistory();
			// if ((s) && (s[length s - 1] == ";")) {
				AddWorkerResultData(s);
				var s2 = s;
				while ((s2) && (s2[length s2 - 1] == ";"))
					s2 = SubStr(s2, 0, length s2 - 1);
				s2 = trim(s2);
				s = "";
				sent = true;
				if ((s2 == "exit") || (s2 == "quit") || (s2 == "done"))
					break;
			}
		}
	}
}

class Main {
	var connected = true;
	var db;
	var user;
	var password;
	var host;
	var port;
	var connection;
	var io;
	var queries;
	var output;
	var reconnecting = false;
	var close = false;
	var[] variables;

	static em(text, add_quote = false) {
		if (vt100())
			return "\x1b[31;1m" + text + "\x1b[0m";
		if (add_quote)
			return "\"$text\"";
		return text;
	}

	static bold(text, add_quote = false) {
		if (vt100())
			return "\x1b[1m" + text + "\x1b[0m";

		if (add_quote)
			return "\"$text\"";
		return text;
	}

	static is_string(text, add_quote = false) {
		if (vt100())
			return "\x1b[33;1m" + text + "\x1b[0m";

		if (add_quote)
			return "\"$text\"";
		return text;
	}

	GetParameters(arg, var db) {
		var[] parameters;
		for (var i = 0; i < length arg; i++) {
			var key = arg[i];
			if (key) {
				if (key[0] == "-") {
					while ((key) && (key[0] == "-"))
						key++;
					if (key) {
						var val = arg[++i];
						parameters[key] = val;
					}
				} else
					db = key;
			}
		}
		return parameters;
	}

	Connect(host, port, db) {
		connection = new TinConnection();
		if (connection.DriverOpen(db, host, port))
			return connection;

		return null;
	}

	space(key, len) {
		while (length key < len)
			key += " ";
		return key;
	}

	prefix(key, len) {
		while (length key < len)
			key = " " + key;
		return key;
	}

	safeoid(val) {
		for (var i = 0; i < length val; i++) {
			var v = val[i];
			if (((v < '0') || (v > '9')) && ((v < 'a') || (v > 'f')))
				return StringToHex(val);
		}
		return val;
	}

	print(obj, level = 0, var backref = null, prec_level_str = "") {
		if (typeof obj == "array") {
			if (level <= 1)
				backref = new [];
			backref["" + ClsPtr(obj)] = true;
			var level_str = "";
			for (var i = 0; i < level ; i++)
				level_str += "  ";
			var keys = GetKeys(obj);
			var max_len = 0;
			var is_static = true;
			for (i = 0; i < length keys; i++) {
				var key = keys[i];
				if ((key) && (length key > max_len)) {
					max_len = length key;
					is_static = false;
				} else {
					var val = obj[i];
					if ((typeof val != "string") && (typeof val != "numeric"))
						is_static = false;
				}
			}
			var is_object = max_len;
			if (level) {
				if (is_object) {
					echo "{";
				} else
					echo "[";
			}
			if (is_static) {
				echo " ";
				level_str = "";
				prec_level_str = "";
			} else
				echo NEW_LINE;
			for (i = 0; i < length obj; i++) {
				key = keys[i];
				var keystr;
				if (typeof key == "string")
					keystr = bold(space(key, max_len)) + ": ";
				else
					keystr = "";
				val = obj[i];
				echo "$level_str$keystr";
				if (typeof val == "array") {
					var backref_ptr = ""+ClsPtr(val);
					if (backref[backref_ptr]) {
						echo em("(reference to already printed object)");
						if (i < length obj - 1)
							echo ",";
						echo NEW_LINE;
					} else {
						backref[backref_ptr] = true;
						print(val, level + 1, backref, level_str);
					}
				} else {
					if ((key) && ((key == "\$oid") || (key == "\$v")))
						val = safeoid(val);
					if (typeof val == "string")
						val = is_string(val, true);
					echo val;
					if (is_static)
						echo " ";
					else
						echo NEW_LINE;
				}
			}
			if (level) {
				if (is_object)
					echo "$prec_level_str}" + NEW_LINE;
				else
					echo "$prec_level_str]" + NEW_LINE;
			}
			return;
		}
		echo obj;
	}

	notifycallback(subject, obj) {
		echo "Notification received" + NEW_LINE;
		if (subject)
			echo "Subject: ${em(subject)}" + NEW_LINE;
		echo "Content:" + NEW_LINE;
		print(obj);
		echo NEW_LINE + "End content" + NEW_LINE;
	}

	DoneQuery() {
		queries--;
		if ((this.close) && (!queries)) {
			echo "Done" + NEW_LINE;
			panicexit(0);
		}
	}

	callback(r, id, err) {
		if (err) {
			connected = false;
			echo "${err[1]}" + NEW_LINE;
			return false;
		}
		echo "OK" + NEW_LINE;
		connection.OnNotify = notifycallback;
		if (!io)
			io = new Worker("IOWorker");
		DoneQuery();
	}

	SafeCSV(k, separator) {
		if ((Pos(k, separator) > 0) || (Pos(k, "\n") > 0)) {
			k = StrReplace(k, '"', '""');
			k = "\"" + k + "\"";
		}
		return k;
	}

	array_to_str(v, max_level = 10) {
		if (max_level <= 0)
			return "..";
		if (typeof v == "array") {
			var str = "";
			for (var i = 0; i < length v; i++) {
				var e = v[i];
				switch (typeof e) {
					case "string":
					case "numeric":
						if (str)
							str += ", ";
						str += e;
						break;
					case "array":
						if (str)
							str += ", ";
						str += "[" + this.array_to_str(e, max_level - 1) + "]";
						break;
				}
			}
			return str;
		}
		return v;
	}

	WriteXLS(data, output) {
		var sml = new SpreadsheetML();
		if (data) {
			var[] all_keys;
			var[] text_keys;
			sml.style("Header", ["Interior" => ["ss:Color" => SSREPORT_COLOR, "ss:Pattern" => "Solid"], "Font" => ["ss:Color" => SSINVERSE_COLOR, "ss:Bold" => "1"]]);

			var sheet = sml << "Datasheet";
			for (var i = 0; i < length data; i++) {
				var obj = data[i];
				if (obj) {
					if (typeof obj == "class") {
						obj = ToArray(obj);
						data[i] = obj;
					}
					var keys = GetKeys(obj);
					for (var j = 0; j < length keys; j++) {
						var k = keys[j];
						if ((typeof k == "string") && (k != "id") && (k[0] != '$') && (Pos(k, "_sha256") <= 0)) {
							all_keys[k] = k;
							text_keys[k] = StrReplace(k, "_", " ");
						}
					}
				}
			}
			var table = sheet.Table();
			table.style(0, "Header") << text_keys;

			for (i = 0; i < length data; i++) {
				obj = data[i];
				if (obj) {
					var line = new [];
					for (j = 0; j < length all_keys; j++) {
						k = all_keys[j];
						if (IsSet(obj, k)) {
							var v = obj[k];
							switch (typeof v) {
								case "string":
								case "numeric":
									line[length line] = v;
									break;
								case "array":
									line[length line] = "[" + this.array_to_str(v) + "]";
									break;
								default:
									line[length line] = "/" + typeof v + "/";
							}
						} else
							line[length line] = "";
					}
					if (line)
						table << line;
				}
			}
		}
		_unlink(output);
		var f = new File("wb");
		f.Name = output;
		if (f.Open()) {
			sml.Generate(f);
			f.Close();
		}
	}

	WriteCSV(data, output, separator = ",", line_ending = "\n") {
		if (data) {
			var[] all_keys;
			for (var i = 0; i < length data; i++) {
				var obj = data[i];
				if (typeof obj == "array") {
					var keys = GetKeys(obj);
					for (var j = 0; j < length keys; j++) {
						var k = keys[j];
						if (typeof k == "string")
							all_keys[k] = k;
					}
				}
			}
			var csv = "";
			for (i = 0; i < length all_keys; i++) {
				k = SafeCSV(all_keys[i], separator);
				if (csv)
					csv += separator;
				csv +=  k;
			}
			if (!csv) {
				echo "Dataset contains no keys" + NEW_LINE;
				return;
			}
			csv += line_ending;
			_unlink(output);
			var f = new File("wb");
			f.Name = output;
			if (f.Open()) {
				for (i = 0; i < length data; i++) {
					obj = data[i];
					if (typeof obj == "array") {
						var line = "";
						for (j = 0; j < length all_keys; j++) {
							k = all_keys[j];
							if (line)
								line += separator;
							if (IsSet(obj, k)) {
								var v = obj[k];
								switch (typeof v) {
									case "string":
									case "numeric":
										line += SafeCSV("" + v, separator);
										break;
									default:
										line += "/" + typeof v + "/";
								}
							}
						}
						if (line)
							csv += line + line_ending;
					}
					if (length csv > WRITE_BUFFER) {
						f.Write(csv);
						csv=  "";
					}
				}
				if (csv)
					f.Write(csv);
				f.Close();
			}
		} else
			echo "${em("Dataset is empty")}" + NEW_LINE;
	}

	TimeDelta(t) {
		return number_format((microseconds() - t)/1000000, 3, ".", "") + " seconds";
	}

	WritePDF(data, output, title = "") {
		if (data)
			WriteFile(Utils::report(data, null, title), output);
		else
			echo "${em("Dataset is empty")}" + NEW_LINE;
	}

	querycallback(r, id, err, userdata = null) {
		if (userdata) {
			var query = userdata[0];
			var time = TimeDelta(userdata[1]);
		} else {
			query = "(info query)";
			time = "0 seconds";
			userdata = new [];
			if ((r) && (typeof r == "array") && (IsSet(r, "Timestamp"))) {
				time = TimeDelta(r["Timestamp"]);
				query = "ping";
			}
		}

		if (err) {
			echo "$query ($time):" + NEW_LINE;
			if (typeof err == "array") {
				var et = err[1];
				if (typeof et == "array") {
					echo et;
					echo NEW_LINE;
				} else
					echo "${em(et)}" + NEW_LINE;
			} else
				echo "${em(err)}" + NEW_LINE;
		} else {
			var count = 0;
			if (typeof r != "array")
				r = [r];
			if (r)
				count = length r;
			if (output) {
				echo "$query ($time), ${em(count)} records to file ${em(output)}" + NEW_LINE;
				var ext = ToLower(Ext(output));
				switch (ext) {
					case "bin":
						WriteFile(BinarizeObject(r), output);
						break;
					case "xml":
						WriteFile(ToXML(new Container(r), true), output);
						break;
					case "csv":
						WriteCSV(r, output);
						break;
					case "pdf":
						WritePDF(r, output, query);
						break;
					case "xls":
						WriteXLS(r, output);
						break;
					default:
						WriteFile(JSONSerialize(r, true), output);
						break;
				}
			} else {
				if ((r) && (userdata[2]) && (userdata[2] == "count"))
					count = r[0];
				else
					print(r);
				echo NEW_LINE + "$query ($time), ${em(count)} records" + NEW_LINE;
			}
		}
		DoneQuery();
	}

	storecallback(r, id, err, userdata) {
		var query = userdata[0];
		var time = TimeDelta(userdata[1]);

		if (err) {
			echo "$query ($time):" + NEW_LINE;
			echo "${em(err[1])}" + NEW_LINE;
		} else {
			if (typeof id == "array") {
				if (length id < 10)
					echo id;
				else
					echo "${length id} records stored" + NEW_LINE;
				echo NEW_LINE + "$query ($time)" + NEW_LINE;
			} else {
				echo id;
				echo NEW_LINE + "$query ($time)" + NEW_LINE;
			}
		}
		DoneQuery();
	}

	requestcallback(r, id, err, userdata) {
		var query = userdata[0];
		var time = TimeDelta(userdata[1]);
		if (err) {
			echo "$query ($time):" + NEW_LINE;
			echo "${em(err[1])}" + NEW_LINE;
		} else {
			echo "$query ($time): OK" + NEW_LINE;
		}
		DoneQuery();
	}

	LoadCSV(var data) {
		data = CSV::Do(data, null, var error, var error_text);
		if ((error) && (error_text)) {
			echo "Error in CSV: $error_text" + NEW_LINE;
			return null;
		}
		var header = data[0];
		var objects = new [];
		if (header) {
			for (var i = 1; i < length data; i++) {
				var line = data[i];
				if (line) {
					var obj = new [];
					for (var j = 0; j < length header; j++) {
						var v = line[j];
						var h = header[j] ?? "_field_${j+1}";
						// skip ids
						if (h != '$') {
							var v_val = value v;
							if ("" + v_val == v)
								obj[h] = v_val;
							else
								obj[h] = v;
						}
					}
					if (obj)
						objects[length objects] = obj;
				}
			}
		}
		return objects;
	}

	LoadBigCSV(csvname, collection, orig_query, s) {
		var f = new File("rb");
		f.Name = csvname;
		if (!f.Open()) {
			echo "Error opening CSV file $csvname" + NEW_LINE;
			return;
		}
		var csv = new CSV();

		var header = null;
		var start = 0;
		do {
			if (f.Read(var buffer, CSV_BIG_FILE) <= 0)
				break;
			if (buffer) {
				var data = csv.Parse(buffer, length buffer < CSV_BIG_FILE);
				if ((data) && (!header)) {
					header = data[0];
					start = 1;
				} else
					start = 0;

				if ((csv.Error) && (csv.ErrorText)) {
					echo "Error in CSV: ${csv.ErrorText}" + NEW_LINE;
					f.Close();
					return;
				}
				var objects = new [];
				if (header) {
					for (var i = start; i < length data; i++) {
						var line = data[i];
						if (line) {
							var obj = new [];
							for (var j = 0; j < length header; j++) {
								var v = line[j];
								var h = header[j] ?? "_field_${j+1}";
								// skip ids
								if (h != '$') {
									var v_val = value v;
									if ("" + v_val == v)
										obj[h] = v_val;
									else
										obj[h] = v;
								}
							}
							if (obj)
								objects[length objects] = obj;
						}
					}
					if (objects) {
						var dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds(), s];
						dataset.Store(objects, true, storecallback);
						queries++;
						echo "${length objects} objects sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					}
				}
			}
		} while (data);
		f.Close();
	}

	SkipID(obj) {
		if (obj) {
			if (IsSet(obj, '$'))  {
				var keys = GetKeys(obj);
				var c = new [];
				for (var i = 0; i < length keys; i++) {
					var k = keys[i];
					if ((k) && (k != '$'))
						c[k] = obj[k];
				}
				return c;
			}
		}
		return obj;
	}

	SkipIDS(data) {
		if (data) {
			var keys = GetKeys(data);
			var is_set = true;
			if ((keys) && (keys[0]))
				is_set = false;
			if (is_set) {
				for (var i =0; i < length data; i++)
					data[i] = SkipID(data[i]);
			}
			return SkipID(data);
		}
		return data;
	}

	GetObjects(var data, ext) {
		switch (ext) {
			case "csv":
			case "txt":
				return LoadCSV(data);
			case "bin":
				return SkipIDS(UnBinarizeObject(data));
			case "json":
			default:					
				return SkipIDS(JSONDeserialize(data));
		}
	}
	
	SQL(s, orig_query = "", var err = "") {
		err = "";
		if (!orig_query)
			orig_query = s;
		var sql = SQLParser::parse(s, err, variables);
		if ((sql) && (!err)) {
			var dataset, fields, collection, lang, keys;
			for (var i = 0; i < length sql; i++) {
				var q = sql[i];
				if (q) {
					if (IsSet(q, "SELECT")) {
						fields = q["SELECT"];
						if (q["DUMMY"]) {
							queries++;
							querycallback(fields, 0, null, [orig_query, microseconds()]);
							continue;
						}
						if ((fields) && (length fields == 1) && (fields[0] == "*"))
							fields = null;	

						collection = q["FROM"];
						var where = q["WHERE"] ?? [ ];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						var mod = q["MOD"];
						var join = q["JOIN"];
						var reduce = q["REDUCE"];
						if (q["EXPLAIN"]) {
							dataset.Explain(where, querycallback);
						} else
						if (mod) {
							var agg = mod[0][0];
							if (agg == "COUNT") {
								dataset.Query(["#" => where], querycallback, fields, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1), q["PRIORITY"], false, reduce, q["CACHE"], q["RENEW"], q["GROUP"]);
							} else {
								echo "Unsupported SQL function ${em(agg)}" + NEW_LINE;
								break;
							}
						} else
						if (join) {
							var join_query = [where];	
							for (var j = 0; j < length join; j++)
								join_query[length join_query] = join[j];
							dataset.Join(join_query, querycallback, fields, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1), q["PRIORITY"], reduce, q["CACHE"], q["RENEW"], q["GROUP"]);
						} else {
							dataset.Query(where, querycallback, fields, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1), q["PRIORITY"], false, reduce, q["CACHE"], q["RENEW"], q["GROUP"]);
						}
						queries++;
						echo "SQL-like query sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					} else
					if (IsSet(q, "INSERT")) {
						collection = q["INTO"];
						var values = q["INSERT"];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds(), s];
						keys = GetKeys(values);
						dataset.Store(values, ((!keys) || (!keys[0])), storecallback);
						queries++;
						echo "Object sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					} else
					if (IsSet(q, "DELETE")) {
						collection = q["FROM"];
						where = q["WHERE"] ?? [ ];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						dataset.Delete(where, querycallback, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1));
						queries++;
						echo "Delete request sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					} else
					if (IsSet(q, "UPDATE")) {
						collection = q["UPDATE"];
						where = q["WHERE"] ?? [ ];
						values = q["SET"] ?? [ ];
						reduce = q["REDUCE"] ?? "";
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						dataset.Update(where, values, querycallback, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1), q["PRIORITY"], reduce);
						queries++;
						echo "Update request sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					} else
					if (IsSet(q, "DROP")) {
						collection = q["DROP"];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						dataset.Drop(requestcallback);
						queries++;
						echo "Request sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					} else
					if (IsSet(q, "INDEX")) {
						collection = q["INDEX"];
						values = q["ON"];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						if (q["BM25"]) {
							if (!values)
								values = null;
							lang = q["LANG"];
							if (!lang)
								lang = "en";
							dataset = new TinDataSet(connection, collection);
							dataset.EnsureFullText(values, lang, querycallback);
						} else {
							if (length values > 1)
								values = [values];
							dataset.EnsureIndexes(values, querycallback);
						}
						queries++;
						echo "Request sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					} else
					if (IsSet(q, "DROP INDEX")) {
						collection = q["DROP INDEX"];
						values = q["ON"];
						if (length values > 1)
							values = [values];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						dataset.DropIndexes(values, querycallback);
						queries++;
						echo "Request sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					} else
					if (IsSet(q, "DROP BM25")) {
						collection = q["DROP BM25"];
						values = q["ON"];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						dataset.DropFullText(querycallback);
						queries++;
						echo "Request sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					} else
					if (IsSet(q, "SEQUENCE")) {
						collection = q["SEQUENCE"];
						var increment = q["INCREMENT"];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						dataset.Generate(collection, querycallback, increment);
						queries++;
						echo "Sequence request sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					} else
					if (IsSet(q, "CODE")) {
						var code = q["CODE"];
						dataset = new TinDataSet(connection, "db");
						dataset.UserData = [orig_query, microseconds()];
						dataset.js(code, querycallback);
						queries++;
						echo "JS code sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					} else
					if (IsSet(q, "EXEC")) {
						code = q["EXEC"];
						dataset = new TinDataSet(connection, "db");
						dataset.UserData = [orig_query, microseconds()];
						dataset.exec(code, null, querycallback);
						queries++;
						echo "Code sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					} else
					if (IsSet(q, "TRIGGER")) {
						code = q["TRIGGERCODE"];
						collection = q["TRIGGER"];
						dataset = new TinDataSet(connection, collection);
						dataset.UserData = [orig_query, microseconds()];
						dataset.jstriggers([q["EVENT"] => code], q["BEFORE"], querycallback);
						queries++;
						echo "Trigger code sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					}
				}
			}
			return true;
		}
		return false;
	}

	Command(s) {
		if (!s)
			return;
		while ((s) && (s[length s - 1] == ";"))
			s = trim(SubStr(s, 0, length s - 1));

		if (!s)
			return;

		var orig_query = s;
		var query_arr = preg(s, '^([A-Za-z0-9\_]+)\\.([A-Za-z0-9\_]+)\\((.*)\\)$');
		var collection = "";
		var parameters = "";

		if (length query_arr > 2) {
			s = ToLower("" + query_arr[2]);
			collection = query_arr[1];
			if (length query_arr > 3) {
				parameters = trim("" + query_arr[3]);
				if (parameters) {
					if (((parameters[0] == "{") || (parameters[0] == "[")) && (s != "search")) {
						var orig_params = parameters;
						parameters = JSONDeserialize(parameters);
						if (typeof parameters != "array")
							echo "Error parsing JSON: '$orig_params'\n" + NEW_LINE;
					} else
					if ((parameters[0] != "'") && (parameters[0] != "\""))
						parameters = value parameters;
					else
					if (parameters[0] == parameters[length parameters - 1])
						parameters = SubStr(parameters, 1, length parameters - 2);
				}
			}
		} else
		if (length s >= 2) {
			var s_lower = ToLower(s);
			if ((SubStr(s_lower, 0, 3) == "use") && ((s[3] == " ") || (s[3] == "\t"))) {
				parameters = trim(SubStr(s, 4));
				s = "use";
			} else
			if (length s >= 6) {
				if (s_lower == "output") {
					output = null;
					echo "Output results to stdout" + NEW_LINE;
					return;
				} else
				if ((SubStr(s_lower, 0, 6) == "output") && ((s[6] == " ") || (s[6] == "\t"))) {
					output = trim(SubStr(s, 7));
					if ((length output > 1) && (((output[0] == "'") || (output[0] == "\"")) && (output[0] == output[length output - 1])))
						output = SubStr(output, 1, length output - 2);
					if (output)
						echo "Output results to '$output'" + NEW_LINE;
					else
						echo "Output results to stdout" + NEW_LINE;
					return;
				}
			}
			switch (s_lower) {
				case "databases":
				case "collections":
				case "top":
				case "version":
				case "node":
				case "ring":
				case "memory":
				case "gc":
				case "clear":
					connection.Info(s_lower, querycallback);
					queries++;
					echo "Request sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					return;
				case "ping":
					connection.Ping(querycallback);
					queries++;
					echo "Ping sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					return;
			}
		}
		switch (s) {
			case "query":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				if (!parameters)
					parameters = new [];
				var dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Query(parameters, querycallback);
				queries++;
				echo "Query sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
				break;
			case "count":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				if (!parameters)
					parameters = new [];
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds(), s];
				dataset.Query(["#" => parameters], querycallback);
				queries++;
				echo "Query sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
				break;
			case "aggregate":
			case "join":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				if (!parameters)
					parameters = new [];
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Join(parameters, querycallback);
				queries++;
				echo "Query sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
				break;
			case "search":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				parameters = "" + parameters;
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Search(parameters, querycallback);
				queries++;
				echo "Search '$parameters' sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
				break;
			case "store":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				if (typeof parameters != "array")
					parameters = ["_" => parameters];
				if (!parameters)
					parameters = new [];
				dataset = new TinDataSet(connection, collection);
				var keys = GetKeys(parameters);
				dataset.UserData = [orig_query, microseconds(), s];
				dataset.Store(parameters, ((!keys) || (!keys[0])), storecallback);
				queries++;
				echo "Object sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
				break;
			case "storefile":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				if ((!parameters) || (typeof parameters != "string")) {
					echo "No file" + NEW_LINE;
					return;
				}
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds(), s];

				var fname_arr = StrSplit(StrReplace(parameters, "\\", "/"), "/");
				var fdata = ReadFile(parameters);
				if (!fdata) {
					echo "File does not exists or is empty" + NEW_LINE;
					return;
				}
				var fname = parameters;
				if (fname_arr)
					fname = fname_arr[length fname_arr - 1];
				dataset.StoreFile(fname, fdata, querycallback);
				queries++;
				echo "Object sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
				break;
			case "deletefile":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				if ((!parameters) || (typeof parameters != "string")) {
					echo "No file" + NEW_LINE;
					return;
				}
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds(), s];

				dataset.DeleteFile(parameters, querycallback);
				queries++;
				echo "Object sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
				break;
			case "file":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				if ((!parameters) || (typeof parameters != "string")) {
					echo "No file" + NEW_LINE;
					return;
				}
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds(), s];

				dataset.GetFile(parameters, querycallback);
				queries++;
				echo "Object sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
				break;
			case "drop":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Drop(requestcallback);
				queries++;
				echo "Request sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
				break;
			case "info":
				if (queries) {
					if (queries == 1)
						echo "1 query queued" + NEW_LINE;
					else
						echo "${queries} queries queued" + NEW_LINE;
				} else
					echo "No queries queued" + NEW_LINE;
				break;
			case "index":
			case "ensureindex":
			case "ensureindexes":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				if (!parameters) {
					echo "No index specified" + NEW_LINE;
					return;
				}
				if (typeof parameters != "array")
					parameters = [parameters];
				dataset = new TinDataSet(connection, collection);
				dataset.EnsureIndexes(parameters);
				echo "OK" + NEW_LINE;
				break;
			case "fulltext":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				var lang = "en";
				var fields = null;
				if (parameters) {
					if (typeof parameters == "string") {
						lang = parameters;
					} else
					if (typeof parameters == "array") {
						keys = GetKeys(parameters);
						if ((keys) && (keys[0])) {
							fields = parameters["fields"];
							lang = parameters["language"] ?? "en";
						} else
							fields = parameters;
					}
				}
				dataset = new TinDataSet(connection, collection);
				dataset.EnsureFullText(fields, lang);
				echo "Full text index request sent, for \"$lang\" language" + NEW_LINE;
				if (fields) {
					echo "Index will use fields:" + NEW_LINE;
					echo fields;
					echo NEW_LINE;
				}
				break;
			case "delete":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				if (!parameters)
					parameters = new [];
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Delete(parameters, querycallback);
				queries++;
				echo "Delete request sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
				break;
			case "update":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				if ((!parameters) || (typeof parameters != "array") || (!parameters["set"]) || (typeof parameters["set"] != "array")) {
					echo em("Nothing to update") + NEW_LINE;
					break;
				}
				if (!parameters["select"])
					parameters["select"] = new [];
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Update(parameters["select"], parameters["set"], querycallback);
				queries++;
				echo "Update request sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
				break;
			case "addsubject":
			case "removesubject":
				if (typeof parameters != "string")
					parameters = "";
				if (s == "addsubject")
					connection.AddSubject(parameters);
				else
					connection.RemoveSubject(parameters);
				echo "OK" + NEW_LINE;
				break;
			case "notify":
				var subject = "";
				if (typeof parameters == "array") {
					if (IsSet(parameters, "subject"))
						subject = parameters["subject"];

					if (IsSet(parameters, "object"))
						parameters = parameters["object"];
				}
				connection.Notify(parameters, subject);
				break;
			case "load":
				if (!collection) {
					echo "No collection selected" + NEW_LINE;
					return;
				}
				if ((!parameters) || (typeof parameters != "string")) {
					echo "No file specified." + NEW_LINE;
					return;
				}
				var ext = ToLower(Ext(parameters));
				if ((ext == "csv") && (filesize(parameters) > CSV_BIG_FILE)) {
					LoadBigCSV(parameters, collection, orig_query, s);
				} else {
					var data = ReadFile(parameters);
					if (!data) {
						echo "File '$parameters' is empty or does not exists." + NEW_LINE;
						return;
					}
					var objects = GetObjects(data, ext);
					if (!objects) {
						echo "File '$parameters' contains no usable objects." + NEW_LINE;
						return;
					}
					dataset = new TinDataSet(connection, collection);
					keys = GetKeys(objects);
					var is_set = ((!keys) || (!keys[0]));
					dataset.UserData = [orig_query, microseconds(), s];
					dataset.Store(objects, is_set, storecallback);
					queries++;
					if (is_set)
						echo "${length objects} objects sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
					else
						echo "1 object sent, waiting response (${queries} in queue, including this one)..." + NEW_LINE;
				}
				break;
			case "done":
				if (queries) {
					this.close = true;
					echo "Waiting for ${em(queries)} queries to finish" + NEW_LINE;
					break;
				}
				// no break here
			case "quit":
			case "exit":
				if (connection) {
					connection.Disconnect();
					connection = null;
				}
				connected = false;
				break;
			case "use":
				if ((!parameters) || (typeof parameters != "string")) {
					echo "No database specified" + NEW_LINE;
					return;
				}
				connection.Database = parameters;
				echo "Using database ${parameters}" + NEW_LINE;
				break;
			case "help":
				echo "Local commands: info, quit, exit, done, output [outputfilename], use dbname, databases, collections, top, version" + NEW_LINE;
				echo "TinDB commands:" + NEW_LINE;
				echo "    ${em("collection.query")}(criteria_object);" + NEW_LINE;
				echo "        Search object, matching criteria" + NEW_LINE;
				echo "        eg: student.query({\"Name\": \"Jane\"});" + NEW_LINE;
				echo "    ${em("collection.count")}(criteria_object);" + NEW_LINE;
				echo "        Count objects in collection matching criteria" + NEW_LINE;
				echo "    ${em("collection.delete")}(criteria_object);" + NEW_LINE;
				echo "        delete an object from collection, matching criteria" + NEW_LINE;
				echo "        eg: student.delete({\"Name\": \"Jane\"});" + NEW_LINE;
				echo "    ${em("collection.store")}(object);" + NEW_LINE;
				echo "        store an arbitray object, eg:. student.store({\"Name\": \"George\"})" + NEW_LINE;
				echo "        may also use arrays, eg:. student.store([{\"Name\": \"George\"}, {\"Name\": \"Jane\"}])" + NEW_LINE;
				echo "    ${em("collection.update")}({\"select\": query, \"set\": object});" + NEW_LINE;
				echo "        update multiple objects, eg:. student.update({\"select\": {\"Year\": 1}, \"set\": {\"Year\": 2}})" + NEW_LINE;
				echo "    ${em("collection.load")}(filename);" + NEW_LINE;
				echo "        load objects from JSON or CSV file" + NEW_LINE;
				echo "    ${em("collection.search")}(searchstring);" + NEW_LINE;
				echo "        perform bm25 search" + NEW_LINE;
				echo "    ${em("collection.drop")}();" + NEW_LINE;
				echo "        drop collection" + NEW_LINE;
				echo "    ${em("collection.index")}(index);" + NEW_LINE;
				echo "        create btree index" + NEW_LINE;
				echo "    ${em("collection.fulltext")}(string language | array fields | {\"language\": \"en\", \"fields\": array);" + NEW_LINE;
				echo "        create full text index" + NEW_LINE;
				echo "    ${em("collection.storefile")}(filename);" + NEW_LINE;
				echo "        store file in collection file storage" + NEW_LINE;
				echo "    ${em("collection.deletefile")}(filename);" + NEW_LINE;
				echo "        delete file in collection file storage" + NEW_LINE;
				echo "    ${em("collection.file")}(filename);" + NEW_LINE;
				echo "        fetch file from collection file storage" + NEW_LINE;
				echo NEW_LINE;
				break;
			default:
				if (!SQL(s, orig_query, var err)) {
					if (err)
						echo em(err) + NEW_LINE;
					if (length s > 20)
						s = SubStr(s, 0, 20) + "...";
					echo "Command '$s' not understood" + NEW_LINE;
				}
		}
	}

	Loop() {
		var connection = Connect(host, port, db);
		echo "Connecting ..." + NEW_LINE;
		if (!connection) {
			echo "Error connecting to database $host:$port/$db" + NEW_LINE;
			if (reconnecting)
				return 0;
			return -1;
		}
		reconnecting = true;
		echo "Authorizing ..." + NEW_LINE;

		var dataset = new TinDataSet(connection, "users");
		queries++;
		dataset.Auth(user, password, db, callback);
		while (connected) {
			if (!connection.Iterate(true)) {
				echo "Disconnected" + NEW_LINE;
				return 0;
			}
			if (io) {
				if (io.GetResult(var s) > 0) {
					if (s) {
						Command(s);
						io.AddData("ok");
						continue;
					}
				}
			}
			if (queries <= 0)
				Sleep(20);
			else
				Sleep(1);
		}
		return true;
	}

	Main() {
		enablevt100();
		echo "TinDB client console application v0.1" + NEW_LINE;
		echo "Developed by Eduard Suica, released into public domain" + NEW_LINE;
		echo "Type ${em("help", true)} for help\n" + NEW_LINE;
		db = "appdb";
		var parameters = GetParameters(CLArg(), db);
		user = parameters["u"] ?? "sysdbadministrator";
		password = parameters["p"] ?? "sysdbadministrator";
		host = parameters["h"] ?? "localhost";
		port = value (parameters["P"] ?? "2668");

		while ((!Loop()) && (connected)) {
			echo "Reconnecting..." + NEW_LINE;
			Sleep(1000);
			queries = 0;
		}
	}
}
