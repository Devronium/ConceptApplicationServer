#!/usr/local/bin/concept

import standard.C.io
import standard.lang.cli
import standard.lib.preg
import standard.lib.json
include Worker.con
include TinDataBases.con
include CSV.con
include SQLParser.con

class Container {
	var Data;

	Container(data) {
		this.Data = data;
	}
}

class IOWorker extends Worker{
	IOWorker(dummy) {
		var s = "";
		var sent = false;
		while (true) {
			if (s) {
				s += "\n";
			} else {
				if (sent) {
					while (!this.Pending(dummy, -1))
						Sleep(20);
					sent = false;
				}
				echo "> ";
			}

			s += trim(gets());
			if ((s) && (s[length s - 1] == '\\')) {
				s = SubStr(s, 0, length s - 1);
			} else
			if (s) {
			// if ((s) && (s[length s - 1] == ";")) {
				AddWorkerResultData(s);
				var s2 = s;
				while ((s2) && (s2[length s2 - 1] == ";"))
					s2 = SubStr(s2, 0, length s2 - 1);
				s2 = trim(s2);
				s = "";
				sent = true;
				if ((s2 == "exit") || (s2 == "quit") || (s2 == "done"))
					break;
			}
		}
	}
}

class Main {
	var connected = true;
	var db;
	var user;
	var password;
	var host;
	var port;
	var connection;
	var io;
	var queries;
	var output;
	var reconnecting = false;
	var close = false;

	static em(text, add_quote = false) {
		if (ON_MSWINDOWS) {
			if (add_quote)
				return "\"$text\"";
			return text;
		}
		return "\x1b[31;1m" + text + "\x1b[0m";
	}

	GetParameters(arg, var db) {
		var[] parameters;
		for (var i = 0; i < length arg; i++) {
			var key = arg[i];
			if (key) {
				if (key[0] == "-") {
					while ((key) && (key[0] == "-"))
						key++;
					if (key) {
						var val = arg[++i];
						parameters[key] = val;
					}
				} else
					db = key;
			}
		}
		return parameters;
	}

	Connect(host, port, db) {
		connection = new TinConnection();
		if (connection.DriverOpen(db, host, port))
			return connection;

		return null;
	}

	notifycallback(subject, obj) {
		echo "Notification received\n";
		if (subject)
			echo "Subject: ${em(subject)}\n";
		echo "Content:\n";
		echo obj;
		echo "\nEnd content\n";
	}

	DoneQuery() {
		queries--;
		if ((this.close) && (!queries)) {
			echo "Done\n";
			panicexit(0);
		}
	}

	callback(r, id, err) {
		if (err) {
			connected = false;
			echo "${err[1]}\n";
			return false;
		}
		echo "OK\n";
		connection.OnNotify = notifycallback;
		if (!io)
			io = new Worker("IOWorker");
		DoneQuery();
	}

	SafeCSV(k, separator) {
		if (Pos(k, separator) > 0) {
			k = StrReplace(k, "\\", "\\\\");
			k = StrReplace(k, '"', "\\\"");
			k = "\"" + k + "\"";
		}
		return k;
	}

	WriteCSV(data, output, separator = ",", line_ending = "\n") {
		if (data) {
			var[] all_keys;
			for (var i = 0; i < length data; i++) {
				var obj = data[i];
				if (obj) {
					var keys = GetKeys(obj);
					for (var j = 0; j < length keys; j++) {
						var k = keys[j];
						if (typeof k == "string")
							all_keys[k] = k;
					}
				}
			}
			var csv = "";
			for (i = 0; i < length all_keys; i++) {
				k = SafeCSV(all_keys[i], separator);
				if (csv)
					csv += separator;
				csv +=  k;
			}
			if (!csv) {
				echo "Dataset contains no keys\n";
				return;
			}
			csv += line_ending;
			for (i = 0; i < length data; i++) {
				obj = data[i];
				if (obj) {
					var line = "";
					for (j = 0; j < length all_keys; j++) {
						k = all_keys[j];
						if (line)
							line += separator;
						if (IsSet(obj, k)) {
							var v = obj[k];
							switch (typeof v) {
								case "string":
								case "numeric":
									line += SafeCSV("" + v, separator);
									break;
								default:
									line += "/" + typeof v + "/";
							}
						}
					}
					if (line)
						csv += line + line_ending;
				}
			}
			WriteFile(csv, output);
		} else
			echo "${em("Dataset is empty")}\n";
	}

	querycallback(r, id, err, userdata) {
		var query = userdata[0];
		var time = (microseconds() - userdata[1])/1000000;

		time = "${time} seconds";

		if (err) {
			echo "$query ($time):\n";
			echo "${em(err[1])}\n";
		} else {
			var count = 0;
			if (r)
				count = length r;
			if (output) {
				echo "$query ($time), ${em(count)} records to file ${em(output)}\n";
				var ext = ToLower(Ext(output));
				switch (ext) {
					case "bin":
						WriteFile(BinarizeObject(r), output);
						break;
					case "xml":
						WriteFile(ToXML(new Container(r), true), output);
						break;
					case "csv":
						WriteCSV(r, output);
						break;
					default:
						WriteFile(JSONSerialize(r, true), output);
						break;
				}
			} else {
				if ((r) && (userdata[2]) && (userdata[2] == "count"))
					count = r[0];
				else
					echo r;
				echo "\n$query ($time), ${em(count)} records\n";
			}
		}
		DoneQuery();
	}

	storecallback(r, id, err, userdata) {
		var query = userdata[0];
		var time = (microseconds() - userdata[1])/1000;

		if (time > 60000) {
			time /= 1000;
			time = "${time} seconds";
		} else
			time = "${time}ms";

		if (err) {
			echo "$query ($time):\n";
			echo "${em(err[1])}\n";
		} else {
			if (typeof id == "array") {
				if (length id < 10)
					echo id;
				else
					echo "${length id} records stored\n";
				echo "\n$query ($time)\n";
			} else {
				echo id;
				echo "\n$query ($time)\n";
			}
		}
		DoneQuery();
	}

	requestcallback(r, id, err, userdata) {
		var query = userdata[0];
		var time = (microseconds() - userdata[1])/1000;

		if (time > 60000) {
			time /= 1000;
			time = "${time} seconds";
		} else
			time = "${time}ms";

		if (err) {
			echo "$query ($time):\n";
			echo "${em(err[1])}\n";
		} else {
			echo "$query ($time): OK\n";
		}
		DoneQuery();
	}

	LoadCSV(var data) {
		data = CSV::Do(data, null, var error, var error_text);
		if ((error) && (error_text)) {
			echo "Error in CSV: $error_text\n";
			return null;
		}
		var header = data[0];
		var objects = new [];
		if (header) {
			for (var i = 1; i < length data; i++) {
				var line = data[i];
				if (line) {
					var obj = new [];
					for (var j = 0; j < length header; j++) {
						var v = line[j];
						var h = header[j] ?? "_field_${j+1}";
						// skip ids
						if (h != '$') {
							var v_val = value v;
							if ("" + v_val == v)
								obj[h] = v_val;
							else
								obj[h] = v;
						}
					}
					if (obj)
						objects[length objects] = obj;
				}
			}
		}
		return objects;
	}

	SkipID(obj) {
		if (obj) {
			if (IsSet(obj, '$'))  {
				var keys = GetKeys(obj);
				var c = new [];
				for (var i = 0; i < length keys; i++) {
					var k = keys[i];
					if ((k) && (k != '$'))
						c[k] = obj[k];
				}
				return c;
			}
		}
		return obj;
	}

	SkipIDS(data) {
		if (data) {
			var keys = GetKeys(data);
			var is_set = true;
			if ((keys) && (keys[0]))
				is_set = false;
			if (is_set) {
				for (var i =0; i < length data; i++)
					data[i] = SkipID(data[i]);
			}
			return SkipID(data);
		}
		return data;
	}

	GetObjects(var data, ext) {
		switch (ext) {
			case "csv":
			case "txt":
				return LoadCSV(data);
			case "bin":
				return SkipIDS(UnBinarizeObject(data));
			case "json":
			default:					
				return SkipIDS(JSONDeserialize(data));
		}
	}

	Command(s) {
		if (!s)
			return;
		while ((s) && (s[length s - 1] == ";"))
			s = trim(SubStr(s, 0, length s - 1));

		if (!s)
			return;

		var orig_query = s;
		var query_arr = preg(s, '^([A-Za-z0-9\_]+)\\.([A-Za-z0-9\_]+)\\((.*)\\)$');
		var collection = "";
		var parameters = "";

		if (length query_arr > 2) {
			s = ToLower("" + query_arr[2]);
			collection = query_arr[1];
			if (length query_arr > 3) {
				parameters = trim("" + query_arr[3]);
				if (parameters) {
					if (((parameters[0] == "{") || (parameters[0] == "[")) && (s != "search")) {
						var orig_params = parameters;
						parameters = JSONDeserialize(parameters);
						if (typeof parameters != "array")
							echo "Error parsing JSON: '$orig_params'\n\n";
					} else
					if ((parameters[0] != "'") && (parameters[0] != "\""))
						parameters = value parameters;
					else
					if (parameters[0] == parameters[length parameters - 1])
						parameters = SubStr(parameters, 1, length parameters - 2);
				}
			}
		} else
		if (length s >= 6) {
			if (s == "output") {
				output = null;
				echo "Output results to stdout\n";
				return;
			} else
			if ((SubStr(s, 0, 6) == "output") && ((s[6] == " ") || (s[6] == "\t"))) {
				output = trim(SubStr(s, 7));
				if ((length output > 1) && (((output[0] == "'") || (output[0] == "\"")) && (output[0] == output[length output - 1])))
					output = SubStr(output, 1, length output - 2);
				if (output)
					echo "Output results to '$output'\n";
				else
					echo "Output results to stdout\n";
				return;
			}
		}
		switch (s) {
			case "query":
				if (!parameters)
					parameters = new [];
				var dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Query(parameters, querycallback);
				queries++;
				echo "Query sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "count":
				if (!parameters)
					parameters = new [];
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds(), s];
				dataset.Query(["#" => parameters], querycallback);
				queries++;
				echo "Query sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "aggregate":
			case "join":
				if (!parameters)
					parameters = new [];
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Join(parameters, querycallback);
				queries++;
				echo "Query sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "search":
				parameters = "" + parameters;
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Search(parameters, querycallback);
				queries++;
				echo "Search '$parameters' sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "store":
				if (typeof parameters != "array")
					parameters = ["_" => parameters];
				if (!parameters)
					parameters = new [];
				dataset = new TinDataSet(connection, collection);
				var keys = GetKeys(parameters);
				dataset.UserData = [orig_query, microseconds(), s];
				dataset.Store(parameters, ((!keys) || (!keys[0])), storecallback);
				queries++;
				echo "Object sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "drop":
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Drop(requestcallback);
				queries++;
				echo "Request sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "info":
				if (queries) {
					if (queries == 1)
						echo "1 query queued\n";
					else
						echo "${queries} queries queued\n";
				} else
					echo "No queries queued\n";
				break;
			case "index":
			case "ensureindex":
			case "ensureindexes":
				if (!parameters) {
					echo "No index specified\n";
					return;
				}
				if (typeof parameters != "array")
					parameters = [parameters];
				dataset = new TinDataSet(connection, collection);
				dataset.EnsureIndexes(parameters);
				echo "OK\n";
				break;
			case "fulltext":
				var lang = "en";
				var fields = null;
				if (parameters) {
					if (typeof parameters == "string") {
						lang = parameters;
					} else
					if (typeof parameters == "array") {
						keys = GetKeys(parameters);
						if ((keys) && (keys[0])) {
							fields = parameters["fields"];
							lang = parameters["language"] ?? "en";
						} else
							fields = parameters;
					}
				}
				dataset = new TinDataSet(connection, collection);
				dataset.EnsureFullText(fields, lang);
				echo "Full text index request sent, for \"$lang\" language\n";
				if (fields) {
					echo "Index will use fields:\n";
					echo fields;
					echo "\n";
				}
				break;
			case "delete":
				if (!parameters)
					parameters = new [];
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Delete(parameters, querycallback);
				queries++;
				echo "Delete request sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "update":
				if ((!parameters) || (typeof parameters != "array") || (!parameters["set"]) || (typeof parameters["set"] != "array")) {
					echo em("Nothing to update") + "\n";
					break;
				}
				if (!parameters["select"])
					parameters["select"] = new [];
				dataset = new TinDataSet(connection, collection);
				dataset.UserData = [orig_query, microseconds()];
				dataset.Update(parameters["select"], parameters["set"], querycallback);
				queries++;
				echo "Update request sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "addsubject":
			case "removesubject":
				if (typeof parameters != "string")
					parameters = "";
				if (s == "addsubject")
					connection.AddSubject(parameters);
				else
					connection.RemoveSubject(parameters);
				echo "OK\n";
				break;
			case "notify":
				var subject = "";
				if (typeof parameters == "array") {
					if (IsSet(parameters, "subject"))
						subject = parameters["subject"];

					if (IsSet(parameters, "object"))
						parameters = parameters["object"];
				}
				connection.Notify(parameters, subject);
				break;
			case "load":
				if ((!parameters) || (typeof parameters != "string")) {
					echo "No file specified.\n";
					return;
				}
				var data = ReadFile(parameters);
				if (!data) {
					echo "File '$parameters' is empty or does not exists.\n";
					return;
				}
				var objects = GetObjects(data, ToLower(Ext(parameters)));
				if (!objects) {
					echo "File '$parameters' contains no usable objects.\n";
					return;
				}
				dataset = new TinDataSet(connection, collection);
				keys = GetKeys(objects);
				var is_set = ((!keys) || (!keys[0]));
				dataset.UserData = [orig_query, microseconds(), s];
				dataset.Store(objects, is_set, storecallback);
				queries++;
				if (is_set)
					echo "${length objects} objects sent, waiting response (${queries} in queue, including this one)...\n";
				else
					echo "1 object sent, waiting response (${queries} in queue, including this one)...\n";
				break;
			case "done":
				if (queries) {
					this.close = true;
					echo "Waiting for ${em(queries)} queries to finish\n";
					break;
				}
				// no break here
			case "quit":
			case "exit":
				if (connection) {
					connection.Disconnect();
					connection = null;
				}
				connected = false;
				break;
			case "help":
				echo "Local commands: info, quit, exit, done, output [outputfilename]\n";
				echo "TinDB commands:\n";
				echo "    ${em("collection.query")}(criteria_object);\n";
				echo "        Search object, matching criteria\n";
				echo "        eg: student.query({\"Name\": \"Jane\"});\n";
				echo "    ${em("collection.count")}(criteria_object);\n";
				echo "        Count objects in collection matching criteria\n";
				echo "    ${em("collection.delete")}(criteria_object);\n";
				echo "        delete an object from collection, matching criteria\n";
				echo "        eg: student.delete({\"Name\": \"Jane\"});\n";
				echo "    ${em("collection.store")}(object);\n";
				echo "        store an arbitray object, eg:. student.store({\"Name\": \"George\"})\n";
				echo "        may also use arrays, eg:. student.store([{\"Name\": \"George\"}, {\"Name\": \"Jane\"}])\n";
				echo "    ${em("collection.update")}({\"select\": query, \"set\": object});\n";
				echo "        update multiple objects, eg:. student.update({\"select\": {\"Year\": 1}, \"set\": {\"Year\": 2}})\n";
				echo "    ${em("collection.load")}(filename);\n";
				echo "        load objects from JSON or CSV file\n";
				echo "    ${em("collection.search")}(searchstring);\n";
				echo "        perform bm25 search\n";
				echo "    ${em("collection.drop")}();\n";
				echo "        drop collection\n";
				echo "    ${em("collection.index")}(index);\n";
				echo "        create btree index\n";
				echo "    ${em("collection.fulltext")}(string language | array fields | {\"language\": \"en\", \"fields\": array);\n";
				echo "        create full text index\n";
				echo "\n";
				break;
			default:
				var sql = SQLParser::parse(s, var err);
				if ((sql) && (!err)) {
					for (var i = 0; i < length sql; i++) {
						var q = sql[i];
						if (q) {
							if (IsSet(q, "SELECT")) {
								fields = q["SELECT"];
								if ((fields) && (length fields == 1) && (fields[0] == "*"))
									fields = null;	

								collection = q["FROM"];
								var where = q["WHERE"] ?? [ ];
								dataset = new TinDataSet(connection, collection);
								dataset.UserData = [orig_query, microseconds()];
								var mod = q["MOD"];
								var join = q["JOIN"];
								if (mod) {
									var agg = mod[0][0];
									if (agg == "COUNT") {
										dataset.Query(["#" => where], querycallback, fields, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1));
									} else {
										echo "Unsupported SQL function ${em(agg)}\n";
										break;
									}
								} else
								if (join) {
									var join_query = [where];	
									for (var j = 0; j < length join; j++)
										join_query[length join_query] = join[j];
									dataset.Join(join_query, querycallback, fields, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1));
								} else {
									dataset.Query(where, querycallback, fields, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1));
								}
								queries++;
								echo "SQL-like query sent, waiting response (${queries} in queue, including this one)...\n";
							} else
							if (IsSet(q, "INSERT")) {
								collection = q["INTO"];
								var values = q["INSERT"];
								dataset = new TinDataSet(connection, collection);
								dataset.UserData = [orig_query, microseconds(), s];
								keys = GetKeys(values);
								dataset.Store(values, ((!keys) || (!keys[0])), storecallback);
								queries++;
								echo "Object sent, waiting response (${queries} in queue, including this one)...\n";
							} else
							if (IsSet(q, "DELETE")) {
								collection = q["FROM"];
								where = q["WHERE"] ?? [ ];
								dataset = new TinDataSet(connection, collection);
								dataset.UserData = [orig_query, microseconds()];
								dataset.Delete(where, querycallback);
								queries++;
								echo "Delete request sent, waiting response (${queries} in queue, including this one)...\n";
							} else
							if (IsSet(q, "UPDATE")) {
								collection = q["UPDATE"];
								where = q["WHERE"] ?? [ ];
								values = q["SET"];
								dataset = new TinDataSet(connection, collection);
								dataset.UserData = [orig_query, microseconds()];
								dataset.Update(where, values, querycallback, q["LIMIT"], q["OFFSET"], (q["ORDER"] == -1));
								queries++;
								echo "Update request sent, waiting response (${queries} in queue, including this one)...\n";
							} else
							if (IsSet(q, "DROP")) {
								collection = q["DROP"];
								dataset = new TinDataSet(connection, collection);
								dataset.UserData = [orig_query, microseconds()];
								dataset.Drop(requestcallback);
								queries++;
								echo "Request sent, waiting response (${queries} in queue, including this one)...\n";
							} else
							if (IsSet(q, "INDEX")) {
								collection = q["INDEX"];
								values = q["ON"];
								if (length values > 1)
									values = [values];
								dataset = new TinDataSet(connection, collection);
								dataset.EnsureIndexes(values);
								echo "OK\n";
							} else
							if (IsSet(q, "DROP INDEX")) {
								collection = q["DROP INDEX"];
								values = q["ON"];
								if (length values > 1)
									values = [values];
								dataset = new TinDataSet(connection, collection);
								dataset.DropIndexes(values);
								echo "OK\n";
							}
						}
					}
				} else {
					if (err)
						echo em(err) + "\n";
					if (length s > 20)
						s = SubStr(s, 0, 20) + "...";
					echo "Command '$s' not understood\n";
				}
		}
	}

	Loop() {
		var connection = Connect(host, port, db);
		echo "Connecting ...\n";
		if (!connection) {
			echo "Error connecting to database $host:$port/$db\n";
			if (reconnecting)
				return 0;
			return -1;
		}
		reconnecting = true;
		echo "Authorizing ...\n";

		var dataset = new TinDataSet(connection, "users");
		queries++;
		dataset.Auth(user, password, db, callback);
		while (connected) {
			if (!connection.Iterate(true)) {
				echo "Disconnected\n";
				return 0;
			}
			if (io) {
				if (io.GetResult(var s) > 0) {
					if (s) {
						Command(s);
						io.AddData("ok");
						continue;
					}
				}
			}
			if (queries <= 0)
				Sleep(20);
			else
				Sleep(1);
		}
		return true;
	}

	Main() {
		echo "TinDB client console application v0.1\n";
		echo "Developed by Eduard Suica, released into public domain\n";
		echo "Type ${em("help", true)} for help\n\n";
		db = "appdb";
		var parameters = GetParameters(CLArg(), db);
		user = parameters["u"] ?? "sysdbadministrator";
		password = parameters["p"] ?? "sysdbadministrator";
		host = parameters["h"] ?? "localhost";
		port = value (parameters["P"] ?? "2668");

		while ((!Loop()) && (connected)) {
			echo "Reconnecting...\n";
			Sleep(1000);
			queries = 0;
		}
	}
}
